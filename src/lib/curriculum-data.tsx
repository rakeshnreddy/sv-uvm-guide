// This file is auto-generated by scripts/generate-curriculum-data.ts. Do not edit manually.

export interface Topic {
  title: string;
  slug: string;
  description: string;
}

export interface Section {
  title: string;
  slug: string;
  topics: Topic[];
}

export interface Module {
  title: string;
  slug: string;
  tier: string;
  sections: Section[];
}

export const curriculumData: Module[] = [
  {
    "title": "Foundational",
    "slug": "T1_Foundational",
    "tier": "T1",
    "sections": [
      {
        "title": "F1: Why Verification?",
        "slug": "F1_Why_Verification",
        "topics": [
          {
            "title": "F1: Why Verification?",
            "slug": "index",
            "description": "An introduction to the world of hardware verification."
          }
        ]
      },
      {
        "title": "F2: SystemVerilog Data Types",
        "slug": "F2_Data_Types",
        "topics": [
          {
            "title": "F2: SystemVerilog Data Types",
            "slug": "index",
            "description": "Understand SystemVerilog data types: the crucial difference between 2-state (bit, int) and 4-state (logic, wire, reg) types, and their application in modeling hardware signals and building verification testbenches."
          },
          {
            "title": "Arrays",
            "slug": "arrays",
            "description": ""
          },
          {
            "title": "User Defined",
            "slug": "user-defined",
            "description": ""
          }
        ]
      },
      {
        "title": "F2: SystemVerilog Language Basics",
        "slug": "F2_SystemVerilog_Basics",
        "topics": [
          {
            "title": "F2: SystemVerilog Language Basics",
            "slug": "index",
            "description": "A comprehensive introduction to the fundamental building blocks of the SystemVerilog language."
          }
        ]
      },
      {
        "title": "Module F-2: Digital Logic & HDL Primer",
        "slug": "F2_SystemVerilog_Primer",
        "topics": [
          {
            "title": "Module F-2: Digital Logic & HDL Primer",
            "slug": "index",
            "description": "A crash course in the essential digital logic and HDL concepts for verification."
          }
        ]
      },
      {
        "title": "F3: Behavioral & RTL Modeling",
        "slug": "F3_Behavioral_RTL_Modeling",
        "topics": [
          {
            "title": "F3: Behavioral & RTL Modeling",
            "slug": "index",
            "description": "A core module that teaches how to describe hardware behavior in SystemVerilog."
          }
        ]
      },
      {
        "title": "F3: Procedural Constructs",
        "slug": "F3_Procedural_Constructs",
        "topics": [
          {
            "title": "F3: Procedural Constructs",
            "slug": "index",
            "description": "Understanding the building blocks of SystemVerilog code."
          },
          {
            "title": "Flow Control",
            "slug": "flow-control",
            "description": ""
          },
          {
            "title": "Fork Join",
            "slug": "fork-join",
            "description": ""
          },
          {
            "title": "Tasks Functions",
            "slug": "tasks-functions",
            "description": ""
          }
        ]
      },
      {
        "title": "Module F-3: Introduction to the SystemVerilog Language",
        "slug": "F3_SystemVerilog_Intro",
        "topics": [
          {
            "title": "Module F-3: Introduction to the SystemVerilog Language",
            "slug": "index",
            "description": "An introduction to the basic building blocks of the SystemVerilog language for verification."
          }
        ]
      },
      {
        "title": "F4: RTL and Testbench Constructs",
        "slug": "F4_RTL_and_Testbench_Constructs",
        "topics": [
          {
            "title": "F4: RTL and Testbench Constructs",
            "slug": "index",
            "description": "Key constructs for design and verification."
          },
          {
            "title": "F4: Interfaces and Modports",
            "slug": "interfaces",
            "description": "Learn how to use SystemVerilog interfaces and modports to simplify connections and create reusable verification components."
          },
          {
            "title": "Packages",
            "slug": "packages",
            "description": ""
          },
          {
            "title": "F4: Program and Clocking Blocks",
            "slug": "program-clocking",
            "description": "Understand how program and clocking blocks help create race-free testbenches by separating the testbench from the DUT and defining clear timing for signal interaction."
          }
        ]
      },
      {
        "title": "F4: Verification Basics without UVM",
        "slug": "F4_Verification_Basics_without_UVM",
        "topics": [
          {
            "title": "F4: Verification Basics without UVM",
            "slug": "index",
            "description": "Bridging the gap between basic SystemVerilog and the complex UVM methodology."
          }
        ]
      },
      {
        "title": "Module F-4: Your First Testbench",
        "slug": "F4_Your_First_Testbench",
        "topics": [
          {
            "title": "Module F-4: Your First Testbench",
            "slug": "index",
            "description": "A guided, hands-on lab to build your first simple, self-checking SystemVerilog testbench."
          }
        ]
      },
      {
        "title": "F5: Intro to Object-Oriented Programming (OOP) in SV",
        "slug": "F5_Intro_to_OOP_in_SV",
        "topics": [
          {
            "title": "F5: Intro to Object-Oriented Programming (OOP) in SV",
            "slug": "index",
            "description": "The final prerequisite before diving into UVM."
          }
        ]
      }
    ]
  },
  {
    "title": "Intermediate",
    "slug": "T2_Intermediate",
    "tier": "T2",
    "sections": [
      {
        "title": "I-SV-1: Object-Oriented Programming for Verification",
        "slug": "I-SV-1_OOP",
        "topics": [
          {
            "title": "I-SV-1: Object-Oriented Programming for Verification",
            "slug": "index",
            "description": "Understanding OOP as the foundation for modern verification methodologies like UVM."
          },
          {
            "title": "Constructors",
            "slug": "constructors",
            "description": ""
          },
          {
            "title": "Parameterized Classes",
            "slug": "parameterized-classes",
            "description": ""
          }
        ]
      },
      {
        "title": "I-SV-2: Constrained Randomization",
        "slug": "I-SV-2_Constrained_Randomization",
        "topics": [
          {
            "title": "I-SV-2: Constrained Randomization",
            "slug": "index",
            "description": "Using constrained randomization to intelligently search for bugs."
          },
          {
            "title": "Advanced Constraints",
            "slug": "advanced-constraints",
            "description": ""
          },
          {
            "title": "Constraint Blocks",
            "slug": "constraint-blocks",
            "description": ""
          },
          {
            "title": "Controlling Randomization",
            "slug": "controlling-randomization",
            "description": ""
          }
        ]
      },
      {
        "title": "I-SV-3: Functional Coverage",
        "slug": "I-SV-3_Functional_Coverage",
        "topics": [
          {
            "title": "I-SV-3: Functional Coverage",
            "slug": "index",
            "description": "Answering the question 'Are we done yet?' by modeling and measuring functional coverage."
          },
          {
            "title": "Coverage Options",
            "slug": "coverage-options",
            "description": ""
          },
          {
            "title": "Events",
            "slug": "events",
            "description": ""
          },
          {
            "title": "Linking Coverage",
            "slug": "linking-coverage",
            "description": ""
          },
          {
            "title": "Mailboxes",
            "slug": "mailboxes",
            "description": ""
          },
          {
            "title": "Semaphores",
            "slug": "semaphores",
            "description": ""
          }
        ]
      },
      {
        "title": "I-SV-4: SystemVerilog Assertions (SVA)",
        "slug": "I-SV-4_Assertions_SVA",
        "topics": [
          {
            "title": "I-SV-4: SystemVerilog Assertions (SVA)",
            "slug": "index",
            "description": "Learn how to use SystemVerilog Assertions (SVA) to specify design behavior over time and create powerful functional checks."
          },
          {
            "title": "Immediate Vs Concurrent",
            "slug": "immediate-vs-concurrent",
            "description": ""
          },
          {
            "title": "Local Variables",
            "slug": "local-variables",
            "description": ""
          },
          {
            "title": "Multi Clocking",
            "slug": "multi-clocking",
            "description": ""
          }
        ]
      },
      {
        "title": "I-UVM-1: UVM Introduction: Objects, Components, and Factory",
        "slug": "I-UVM-1_UVM_Intro",
        "topics": [
          {
            "title": "I-UVM-1: UVM Introduction: Objects, Components, and Factory",
            "slug": "index",
            "description": "Understanding the most fundamental UVM concepts: uvm_object, uvm_component, and the UVM Factory."
          }
        ]
      },
      {
        "title": "I-UVM-2: Building a UVM Testbench: Components & Hierarchy",
        "slug": "I-UVM-2_Building_TB",
        "topics": [
          {
            "title": "I-UVM-2: Building a UVM Testbench: Components & Hierarchy",
            "slug": "index",
            "description": "Assembling a standard UVM testbench and understanding the role of each component."
          },
          {
            "title": "Uvm Report Server",
            "slug": "uvm-report-server",
            "description": ""
          },
          {
            "title": "Uvm Root",
            "slug": "uvm-root",
            "description": ""
          }
        ]
      },
      {
        "title": "I-UVM-3: Basic UVM Sequences and Stimulus Generation",
        "slug": "I-UVM-3_Sequences",
        "topics": [
          {
            "title": "I-UVM-3: Basic UVM Sequences and Stimulus Generation",
            "slug": "index",
            "description": "Mastering the core of UVM's powerful stimulus generation methodology by writing sequences."
          },
          {
            "title": "Uvm Config Db",
            "slug": "uvm-config-db",
            "description": ""
          },
          {
            "title": "Uvm Resource Db",
            "slug": "uvm-resource-db",
            "description": ""
          }
        ]
      },
      {
        "title": "I-UVM-5: UVM Phasing and Synchronization",
        "slug": "I-UVM-5_Phasing_and_Synchronization",
        "topics": [
          {
            "title": "I-UVM-5: UVM Phasing and Synchronization",
            "slug": "index",
            "description": "Understand the UVM phasing mechanism for synchronizing testbench execution and the core UVM class hierarchy."
          },
          {
            "title": "Domains Phase Jumping",
            "slug": "domains-phase-jumping",
            "description": ""
          },
          {
            "title": "Uvm Event Barrier",
            "slug": "uvm-event-barrier",
            "description": ""
          }
        ]
      }
    ]
  },
  {
    "title": "Advanced",
    "slug": "T3_Advanced",
    "tier": "T3",
    "sections": [
      {
        "title": "A-UVM-1: Advanced UVM Sequencing",
        "slug": "A-UVM-1_Advanced_Sequencing",
        "topics": [
          {
            "title": "A-UVM-1: Advanced UVM Sequencing",
            "slug": "index",
            "description": "Learn about advanced UVM sequencing techniques, including layered sequences, virtual sequences, and sequence libraries."
          },
          {
            "title": "Connecting",
            "slug": "connecting",
            "description": ""
          },
          {
            "title": "Environment Test Classes",
            "slug": "environment-test-classes",
            "description": ""
          },
          {
            "title": "Interrupt Handling",
            "slug": "interrupt-handling",
            "description": ""
          },
          {
            "title": "Layered Sequences",
            "slug": "layered-sequences",
            "description": ""
          },
          {
            "title": "Sequence Arbitration",
            "slug": "sequence-arbitration",
            "description": ""
          },
          {
            "title": "Sequence Libraries",
            "slug": "sequence-libraries",
            "description": ""
          },
          {
            "title": "Sequencer Driver Handshake",
            "slug": "sequencer-driver-handshake",
            "description": ""
          },
          {
            "title": "Uvm Monitor",
            "slug": "uvm-monitor",
            "description": ""
          },
          {
            "title": "Uvm Scoreboard",
            "slug": "uvm-scoreboard",
            "description": ""
          },
          {
            "title": "Uvm Sequence Item",
            "slug": "uvm-sequence-item",
            "description": ""
          },
          {
            "title": "Uvm Subscriber",
            "slug": "uvm-subscriber",
            "description": ""
          },
          {
            "title": "UVM Virtual Sequencer",
            "slug": "uvm-virtual-sequencer",
            "description": "Coordinating stimulus across multiple agents."
          },
          {
            "title": "Virtual Sequences and Sequencers",
            "slug": "virtual-sequences",
            "description": "Learn how to use virtual sequences and sequencers to coordinate and synchronize stimulus across multiple agents in a UVM testbench."
          }
        ]
      },
      {
        "title": "A-UVM-2: The UVM Factory In-Depth",
        "slug": "A-UVM-2_The_UVM_Factory_In-Depth",
        "topics": [
          {
            "title": "A-UVM-2: The UVM Factory In-Depth",
            "slug": "index",
            "description": "Explore advanced UVM factory features, including instance overrides, string-based overrides, and debugging techniques."
          },
          {
            "title": "Heartbeats",
            "slug": "heartbeats",
            "description": ""
          },
          {
            "title": "Uvm Callbacks",
            "slug": "uvm-callbacks",
            "description": ""
          }
        ]
      },
      {
        "title": "Index",
        "slug": "A-UVM-3_Advanced_UVM_Techniques",
        "topics": [
          {
            "title": "Index",
            "slug": "index",
            "description": ""
          }
        ]
      },
      {
        "title": "A-UVM-4: The UVM Register Abstraction Layer (RAL)",
        "slug": "A-UVM-4_The_UVM_Register_Abstraction_Layer_RAL",
        "topics": [
          {
            "title": "A-UVM-4: The UVM Register Abstraction Layer (RAL)",
            "slug": "index",
            "description": "Learn how to use the UVM Register Abstraction Layer (RAL) to model and access DUT registers in a standardized and reusable way."
          },
          {
            "title": "Built In Ral Sequences",
            "slug": "built-in-ral-sequences",
            "description": ""
          },
          {
            "title": "Explicit Vs Implicit",
            "slug": "explicit-vs-implicit",
            "description": ""
          },
          {
            "title": "Frontdoor Vs Backdoor",
            "slug": "frontdoor-vs-backdoor",
            "description": ""
          }
        ]
      }
    ]
  },
  {
    "title": "Expert",
    "slug": "T4_Expert",
    "tier": "T4",
    "sections": [
      {
        "title": "E-CUST-1: UVM Methodology Customization",
        "slug": "E-CUST-1_UVM_Methodology_Customization",
        "topics": [
          {
            "title": "E-CUST-1: UVM Methodology Customization",
            "slug": "index",
            "description": "Learn how to customize the UVM methodology to meet the specific needs of your project."
          }
        ]
      },
      {
        "title": "E-DBG-1: Advanced UVM Debug Methodologies",
        "slug": "E-DBG-1_Advanced_UVM_Debug_Methodologies",
        "topics": [
          {
            "title": "E-DBG-1: Advanced UVM Debug Methodologies",
            "slug": "index",
            "description": "Learn advanced techniques for debugging complex UVM environments."
          },
          {
            "title": "Effective Debug",
            "slug": "effective-debug",
            "description": ""
          },
          {
            "title": "Reusable Vip",
            "slug": "reusable-vip",
            "description": ""
          }
        ]
      },
      {
        "title": "E-INT-1: Integrating UVM with Formal Verification",
        "slug": "E-INT-1_Integrating_UVM_with_Formal_Verification",
        "topics": [
          {
            "title": "E-INT-1: Integrating UVM with Formal Verification",
            "slug": "index",
            "description": "Learn how to combine the power of UVM and formal verification to create a more robust verification environment."
          },
          {
            "title": "Dpi",
            "slug": "dpi",
            "description": ""
          },
          {
            "title": "Pss",
            "slug": "pss",
            "description": ""
          }
        ]
      },
      {
        "title": "E-PERF-1: UVM Performance",
        "slug": "E-PERF-1_UVM_Performance",
        "topics": [
          {
            "title": "E-PERF-1: UVM Performance",
            "slug": "index",
            "description": "Learn how to identify and address performance bottlenecks in your UVM testbench."
          }
        ]
      },
      {
        "title": "E-SOC-1: SoC-Level Verification Strategies",
        "slug": "E-SOC-1_SoC-Level_Verification_Strategies",
        "topics": [
          {
            "title": "E-SOC-1: SoC-Level Verification Strategies",
            "slug": "index",
            "description": "Learn about the unique challenges and strategies for verifying a complete System-on-Chip (SoC)."
          },
          {
            "title": "Coverage Closure",
            "slug": "coverage-closure",
            "description": ""
          },
          {
            "title": "Regression Triage",
            "slug": "regression-triage",
            "description": ""
          }
        ]
      }
    ]
  },
  {
    "title": "Interactive Tools",
    "slug": "interactive-tools",
    "tier": "interactive-tools",
    "sections": [
      {
        "title": "Uvm Visualizers",
        "slug": "uvm-visualizers",
        "topics": [
          {
            "title": "Interactive UVM Testbench",
            "slug": "interactive-testbench",
            "description": "A hands-on, interactive visualizer for exploring the UVM testbench architecture, phasing, and data flow in real-time."
          }
        ]
      }
    ]
  },
  {
    "title": "Uvm Building",
    "slug": "uvm-building",
    "tier": "uvm-building",
    "sections": [
      {
        "title": "Essentials",
        "slug": "essentials",
        "topics": [
          {
            "title": "Agents and Environment",
            "slug": "agents-and-environment",
            "description": "Learn how to use agents and environments to build modular and reusable UVM testbenches."
          },
          {
            "title": "Analysis Components",
            "slug": "analysis-components",
            "description": "Learn how to use monitors, scoreboards, and other analysis components to check the correctness of your DUT."
          },
          {
            "title": "Testbench Architecture Overview",
            "slug": "architecture-overview",
            "description": "An overview of the standard UVM testbench architecture."
          },
          {
            "title": "Stimulus Generation",
            "slug": "stimulus-generation",
            "description": "Learn how to generate stimulus in a UVM testbench using sequences and sequencers."
          }
        ]
      }
    ]
  },
  {
    "title": "Uvm Core",
    "slug": "uvm-core",
    "tier": "uvm-core",
    "sections": [
      {
        "title": "Fundamentals",
        "slug": "fundamentals",
        "topics": [
          {
            "title": "UVM Base Classes",
            "slug": "base-classes",
            "description": ""
          },
          {
            "title": "Component Communication",
            "slug": "component-communication",
            "description": "Learn how UVM components communicate using Transaction-Level Modeling (TLM), a high-level approach that enables interoperability and reuse."
          },
          {
            "title": "UVM Factory",
            "slug": "factory",
            "description": "Learn how the UVM factory enables test-specific customization and replacement of components and objects without modifying the original testbench code."
          },
          {
            "title": "Phasing",
            "slug": "phasing",
            "description": ""
          }
        ]
      }
    ]
  }
];

// Helper functions to navigate the new structure

export function findTopicBySlug(slug: string[]): Topic | undefined {
  if (slug.length !== 3) return undefined;
  const [tierSlug, sectionSlug, topicSlug] = slug;
  const courseModule = curriculumData.find(m => m.slug === tierSlug);
  if (!courseModule) return undefined;
  const section = courseModule.sections.find(s => s.slug === sectionSlug);
  if (!section) return undefined;
  return section.topics.find(t => t.slug === topicSlug);
}

export function getBreadcrumbs(slug: string[]): { title: string, path: string }[] {
  const breadcrumbs: { title: string, path: string }[] = [];
  if (slug.length > 0) {
    const courseModule = curriculumData.find(m => m.slug === slug[0]);
    if (courseModule) {
      breadcrumbs.push({ title: "Curriculum", path: `/curriculum` });
      breadcrumbs.push({ title: courseModule.title, path: `/curriculum/${courseModule.slug}` });
      if (slug.length > 1) {
        const section = courseModule.sections.find(s => s.slug === slug[1]);
        if (section) {
          breadcrumbs.push({ title: section.title, path: `/curriculum/${courseModule.slug}/${section.slug}` });
          if (slug.length > 2) {
            const topic = section.topics.find(t => t.slug === slug[2]);
            if (topic) {
              breadcrumbs.push({ title: topic.title, path: `/curriculum/${courseModule.slug}/${section.slug}/${topic.slug}` });
            }
          }
        }
      }
    }
  }
  return breadcrumbs;
}

export function findPrevNextTopics(slug: string[]): { prev: Topic | undefined, next: Topic | undefined } {
  if (slug.length !== 3) return { prev: undefined, next: undefined };

  const allTopics: Topic[] = [];
  curriculumData.forEach(m => {
    m.sections.forEach(s => {
      s.topics.forEach(t => {
        allTopics.push({ ...t, slug: `${m.slug}/${s.slug}/${t.slug}` });
      });
    });
  });

  const currentIndex = allTopics.findIndex(t => t.slug === slug.join('/'));
  if (currentIndex === -1) return { prev: undefined, next: undefined };

  const prev = currentIndex > 0 ? allTopics[currentIndex - 1] : undefined;
  const next = currentIndex < allTopics.length - 1 ? allTopics[currentIndex + 1] : undefined;

  return { prev, next };
}

// ---- Derived convenience types for the application UI ----

// The curriculumData array represents the high level tiers of the course. The
// UI components expect a `Tier` type with a list of `modules`.  Each module in
// turn contains a list of lessons.  The existing data maps cleanly onto this
// structure where a "Module" is a tier and each "Section" is a module.  The
// topics within a section represent the lessons.

export type Tier = Module;
export type Lesson = Topic;
export interface ModuleEntry {
  id: string;
  title: string;
  slug: string;
  lessons: Lesson[];
}

export const tiers: Tier[] = curriculumData;

export function getModules(tier: Tier): ModuleEntry[] {
  return tier.sections.map(section => ({
    id: section.slug,
    title: section.title,
    slug: section.slug,
    lessons: section.topics,
  }));
}

