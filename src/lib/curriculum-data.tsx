// This file is auto-generated by scripts/generate-curriculum-data.ts. Do not edit manually.

export interface Topic {
  title: string;
  slug: string;
  description: string;
}

export interface Section {
  title: string;
  slug: string;
  topics: Topic[];
}

export interface Module {
  title: string;
  slug: string;
  tier: string;
  sections: Section[];
}

export const curriculumData: Module[] = [
  {
    "title": "Foundational",
    "slug": "T1_Foundational",
    "tier": "T1",
    "sections": [
      {
        "title": "F1: Why Verification?",
        "slug": "F1_Why_Verification",
        "topics": [
          {
            "title": "F1: Why Verification?",
            "slug": "index",
            "description": "Experience the stakes of verification through interactive stories, graphs, and your first bug hunt."
          }
        ]
      },
      {
        "title": "F2A: Core Data Types",
        "slug": "F2A_Core_Data_Types",
        "topics": [
          {
            "title": "F2A: Core Data Types",
            "slug": "index",
            "description": "Dive deep into SystemVerilog nets, variables, and value systems with interactive explorers grounded in IEEE 1800-2023."
          }
        ]
      },
      {
        "title": "F2B: Dynamic Data Structures",
        "slug": "F2B_Dynamic_Structures",
        "topics": [
          {
            "title": "F2B: Dynamic Data Structures",
            "slug": "index",
            "description": "Manipulate dynamic arrays, queues, and associative arrays with an IEEE 1800-2023 guided workflow."
          }
        ]
      },
      {
        "title": "F2C: Procedural Code and Flow Control",
        "slug": "F2C_Procedural_Code",
        "topics": [
          {
            "title": "F2C: Procedural Code and Flow Control",
            "slug": "index",
            "description": "Author deterministic `initial`/`always` blocks, choose the right assignment style, and master control flow."
          }
        ]
      },
      {
        "title": "F2D: Reusable Code and Parallelism",
        "slug": "F2D_Reusable_and_Parallel",
        "topics": [
          {
            "title": "F2D: Reusable Code and Parallelism",
            "slug": "index",
            "description": "Factor stimulus into tasks/functions and coordinate parallel threads with fork-join semantics."
          }
        ]
      },
      {
        "title": "F2: SystemVerilog Language Basics",
        "slug": "F2_SystemVerilog_Basics",
        "topics": [
          {
            "title": "F2: SystemVerilog Language Basics",
            "slug": "index",
            "description": "Orient yourself across the F2A–F2D lessons and understand how each builds core SystemVerilog intuition before diving deeper."
          }
        ]
      },
      {
        "title": "F3: Procedural Constructs",
        "slug": "F3_Procedural_Constructs",
        "topics": [
          {
            "title": "F3: Procedural Constructs",
            "slug": "index",
            "description": "Master the procedural heart of SystemVerilog—initial/always/final blocks, flow control, and assignment semantics that drive every testbench."
          },
          {
            "title": "Procedural Flow Control | SystemVerilog Language Foundations",
            "slug": "flow-control",
            "description": "Guide decisions with if, case, and loop constructs to steer simulation flow."
          },
          {
            "title": "Fork-Join and Process Control | SystemVerilog Language Foundations",
            "slug": "fork-join",
            "description": "Launch parallel threads and synchronize them with join variants."
          },
          {
            "title": "Tasks and Functions: Scoping and Lifetimes | SystemVerilog Language Foundations",
            "slug": "tasks-functions",
            "description": "Compare callable blocks with and without timing to structure reusable code."
          }
        ]
      },
      {
        "title": "F4: RTL and Testbench Constructs",
        "slug": "F4_RTL_and_Testbench_Constructs",
        "topics": [
          {
            "title": "F4: RTL and Testbench Constructs",
            "slug": "index",
            "description": "Wire up designs and verification harnesses with modules, interfaces, packages, and clocking blocks that keep signal intent crystal clear."
          },
          {
            "title": "F4: Interfaces and Modports",
            "slug": "interfaces",
            "description": "Learn how to use SystemVerilog interfaces and modports to simplify connections and create reusable verification components."
          },
          {
            "title": "Packages and Compilation Scopes | SystemVerilog Language Foundations",
            "slug": "packages",
            "description": "Group shared declarations into reusable namespaces and manage visibility."
          },
          {
            "title": "F4: Program and Clocking Blocks",
            "slug": "program-clocking",
            "description": "Understand how program and clocking blocks help create race-free testbenches by separating the testbench from the DUT and defining clear timing for signal interaction."
          }
        ]
      }
    ]
  },
  {
    "title": "Intermediate",
    "slug": "T2_Intermediate",
    "tier": "T2",
    "sections": [
      {
        "title": "I-SV-1: Object-Oriented Programming for Verification",
        "slug": "I-SV-1_OOP",
        "topics": [
          {
            "title": "I-SV-1: Object-Oriented Programming for Verification",
            "slug": "index",
            "description": "Build reusable, polymorphic verification components with SystemVerilog classes, inheritance, and virtual methods."
          },
          {
            "title": "Constructors, 'this', and 'super' | Advanced SystemVerilog for Verification",
            "slug": "constructors",
            "description": "How to create objects with new and reference parent and current class members using this and super."
          },
          {
            "title": "Parameterized Classes and Abstract Classes | Advanced SystemVerilog for Verification",
            "slug": "parameterized-classes",
            "description": "Use generics and abstract classes to build reusable components while avoiding common pitfalls."
          }
        ]
      },
      {
        "title": "I-SV-2: Constrained Randomization",
        "slug": "I-SV-2_Constrained_Randomization",
        "topics": [
          {
            "title": "I-SV-2: Constrained Randomization",
            "slug": "index",
            "description": "Guide SystemVerilog's random stimulus with constraints, distributions, and inline tweaks to uncover corner-case bugs fast."
          },
          {
            "title": "Advanced Constraints: implication and iteration | Advanced SystemVerilog for Verification",
            "slug": "advanced-constraints",
            "description": "Express conditional and iterative rules with implication and foreach constructs."
          },
          {
            "title": "Constraint Blocks, soft, and solve...before | Advanced SystemVerilog for Verification",
            "slug": "constraint-blocks",
            "description": "Control dependencies and defaults using constraint blocks, soft values, and solve-before ordering."
          },
          {
            "title": "Controlling Randomization: pre_randomize and post_randomize | Advanced SystemVerilog for Verification",
            "slug": "controlling-randomization",
            "description": "Hook solver callbacks with pre_randomize and post_randomize to prepare and finalize objects."
          }
        ]
      },
      {
        "title": "I-SV-3: Functional Coverage",
        "slug": "I-SV-3_Functional_Coverage",
        "topics": [
          {
            "title": "I-SV-3: Functional Coverage",
            "slug": "index",
            "description": "Model verification intent with covergroups, coverpoints, and crosses to prove you've exercised every critical scenario."
          },
          {
            "title": "Coverage Options and Sampling | Advanced UVM Techniques & Strategy",
            "slug": "coverage-options",
            "description": "Learn how covergroup options influence when and how data is sampled."
          },
          {
            "title": "Events | Advanced SystemVerilog for Verification",
            "slug": "events",
            "description": "Synchronize parallel processes with SystemVerilog events."
          },
          {
            "title": "Linking Coverage to the V-Plan | Advanced UVM Techniques & Strategy",
            "slug": "linking-coverage",
            "description": "Tie functional coverage points back to verification plan items."
          },
          {
            "title": "Mailboxes | Advanced SystemVerilog for Verification",
            "slug": "mailboxes",
            "description": "Use mailboxes for thread-safe communication between processes."
          },
          {
            "title": "Semaphores | Advanced SystemVerilog for Verification",
            "slug": "semaphores",
            "description": "Control access to shared resources using semaphore keys."
          }
        ]
      },
      {
        "title": "I-SV-4: SystemVerilog Assertions (SVA)",
        "slug": "I-SV-4_Assertions_SVA",
        "topics": [
          {
            "title": "I-SV-4: SystemVerilog Assertions (SVA)",
            "slug": "index",
            "description": "Specify temporal intent with SystemVerilog Assertions so your verification environment automatically checks protocol rules."
          },
          {
            "title": "Immediate vs. Concurrent Assertions | Advanced SystemVerilog for Verification",
            "slug": "immediate-vs-concurrent",
            "description": "Compare procedural checks with temporal properties through hands-on examples."
          },
          {
            "title": "Local Variables in Sequences | Advanced SystemVerilog for Verification",
            "slug": "local-variables",
            "description": "Capture and reuse values within sequences to create robust properties."
          },
          {
            "title": "Multi-Clocking and disable-iff | Advanced SystemVerilog for Verification",
            "slug": "multi-clocking",
            "description": "Coordinate assertions across clock domains and mask reset behavior with disable iff."
          }
        ]
      },
      {
        "title": "I-UVM-1: UVM Introduction: Objects, Components, and Factory",
        "slug": "I-UVM-1_UVM_Intro",
        "topics": [
          {
            "title": "I-UVM-1: UVM Introduction: Objects, Components, and Factory",
            "slug": "index",
            "description": "Understand how UVM objects, components, and the factory stitch together so your testbench stays configurable."
          }
        ]
      },
      {
        "title": "I-UVM-2: Building a UVM Testbench: Components & Hierarchy",
        "slug": "I-UVM-2_Building_TB",
        "topics": [
          {
            "title": "I-UVM-2: Building a UVM Testbench: Components & Hierarchy",
            "slug": "index",
            "description": "Assemble a layered UVM environment—agents, drivers, sequencers, monitors, and scoreboards—and know how data flows between them."
          },
          {
            "title": "UVM Report Server and Verbosity | The UVM Universe - Core Concepts",
            "slug": "uvm-report-server",
            "description": "Centralized UVM message control and how to override it with a custom report handler."
          },
          {
            "title": "uvm_root and Test Execution | The UVM Universe - Core Concepts",
            "slug": "uvm-root",
            "description": "The singleton that orchestrates UVM phases and launches tests."
          }
        ]
      },
      {
        "title": "I-UVM-3: Basic UVM Sequences and Stimulus Generation",
        "slug": "I-UVM-3_Sequences",
        "topics": [
          {
            "title": "I-UVM-3: Basic UVM Sequences and Stimulus Generation",
            "slug": "index",
            "description": "Author reusable UVM sequences, understand the sequencer ↔ driver handshake, and stitch stimulus into layered scenarios."
          },
          {
            "title": "uvm_config_db: set and get | The UVM Universe - Core Concepts",
            "slug": "uvm-config-db",
            "description": "Use the UVM configuration database to pass settings down the hierarchy without tight coupling."
          },
          {
            "title": "uvm_resource_db and Precedence | The UVM Universe - Core Concepts",
            "slug": "uvm-resource-db",
            "description": "Resolve configuration conflicts using the underlying resource database and precedence rules."
          }
        ]
      },
      {
        "title": "I-UVM-4: UVM Factory and Overrides",
        "slug": "I-UVM-4_Factory_and_Overrides",
        "topics": [
          {
            "title": "I-UVM-4: UVM Factory and Overrides",
            "slug": "index",
            "description": "Swap component implementations on demand with UVM factory overrides and keep your testbench wiring untouched."
          }
        ]
      },
      {
        "title": "I-UVM-5: UVM Phasing and Synchronization",
        "slug": "I-UVM-5_Phasing_and_Synchronization",
        "topics": [
          {
            "title": "I-UVM-5: UVM Phasing and Synchronization",
            "slug": "index",
            "description": "Orchestrate build, run, and cleanup with UVM phases and objections so every component stays in lockstep."
          },
          {
            "title": "Domains and Phase Jumping | The UVM Universe - Core Concepts",
            "slug": "domains-phase-jumping",
            "description": "Separate components into custom phase domains and redirect execution with phase jumping."
          },
          {
            "title": "uvm_event and uvm_barrier | The UVM Universe - Core Concepts",
            "slug": "uvm-event-barrier",
            "description": "Coordinate activity using lightweight events and blocking barriers for synchronization."
          }
        ]
      }
    ]
  },
  {
    "title": "Advanced",
    "slug": "T3_Advanced",
    "tier": "T3",
    "sections": [
      {
        "title": "A-UVM-1: Advanced UVM Sequencing",
        "slug": "A-UVM-1_Advanced_Sequencing",
        "topics": [
          {
            "title": "A-UVM-1: Advanced UVM Sequencing",
            "slug": "index",
            "description": "Coordinate layered stimulus with virtual sequences, arbitration hooks, and reusable sequence libraries across complex UVM testbenches."
          },
          {
            "title": "Connecting the Agent Components | Advanced UVM Sequencing",
            "slug": "connecting",
            "description": "Wire sequencers, drivers, monitors, and scoreboards with robust connect_phase patterns and analysis backbones."
          },
          {
            "title": "Environment & Test Classes | Advanced UVM Sequencing",
            "slug": "environment-test-classes",
            "description": "Structure environments and tests to configure agents, publish sequencer handles, and launch layered stimulus cleanly."
          },
          {
            "title": "Interrupt Handling and Layered Stimulus | Advanced UVM Sequencing",
            "slug": "interrupt-handling",
            "description": "Turn asynchronous interrupts into deterministic stimulus by combining monitor events, routing policy, and virtual sequences."
          },
          {
            "title": "Layered Sequences and p_sequencer | Advanced UVM Sequencing",
            "slug": "layered-sequences",
            "description": "Design atomic, scenario, and virtual layers of sequences while using p_sequencer to orchestrate cross-agent stimulus."
          },
          {
            "title": "Sequence Arbitration and Priority | Advanced UVM Sequencing",
            "slug": "sequence-arbitration",
            "description": "Understand how UVM sequencers choose the next sequence, how to apply lock/grab, and how to customize arbitration for complex stimulus coordination."
          },
          {
            "title": "Sequence Libraries & Arbitration Control | Advanced UVM Sequencing",
            "slug": "sequence-libraries",
            "description": "Package reusable stimulus into sequence libraries, weight them, and know when to grab/ungrab for critical sections."
          },
          {
            "title": "The Sequencer-Driver Handshake | Advanced UVM Sequencing",
            "slug": "sequencer-driver-handshake",
            "description": "Dissect the blocking protocol between UVM sequencers and drivers, from arbitration to item_done(), and learn how to instrument and debug the flow."
          },
          {
            "title": "uvm_monitor & Analysis Fabric | Advanced UVM Sequencing",
            "slug": "uvm-monitor",
            "description": "Instrument monitors to reconstruct transactions, publish them reliably, and feed subscribers and scoreboards."
          },
          {
            "title": "UVM Scoreboard Patterns | Advanced UVM Sequencing",
            "slug": "uvm-scoreboard",
            "description": "Design scoreboards that compare expected vs. observed traffic, manage response queues, and surface mismatches clearly."
          },
          {
            "title": "uvm_sequence_item Mastery | Advanced UVM Sequencing",
            "slug": "uvm-sequence-item",
            "description": "Engineer rich transaction objects with constraints, deep copy behaviour, and response tracking so every layer of the testbench stays in sync."
          },
          {
            "title": "uvm_subscriber in Practice | Advanced UVM Sequencing",
            "slug": "uvm-subscriber",
            "description": "Leverage uvm_subscriber to capture analysis traffic for coverage, scoreboards, and telemetry without bloating monitors."
          },
          {
            "title": "UVM Virtual Sequencer",
            "slug": "uvm-virtual-sequencer",
            "description": "Coordinating stimulus across multiple agents."
          },
          {
            "title": "Virtual Sequences and Sequencers",
            "slug": "virtual-sequences",
            "description": "Learn how to use virtual sequences and sequencers to coordinate and synchronize stimulus across multiple agents in a UVM testbench."
          }
        ]
      },
      {
        "title": "A-UVM-2: The UVM Factory In-Depth",
        "slug": "A-UVM-2_The_UVM_Factory_In-Depth",
        "topics": [
          {
            "title": "A-UVM-2: The UVM Factory In-Depth",
            "slug": "index",
            "description": "Target overrides precisely, debug factory configuration, and architect reusable agents with advanced UVM factory techniques."
          },
          {
            "title": "Heartbeats & Hang Detection | Advanced UVM Factory",
            "slug": "heartbeats",
            "description": "Instrument your testbench with automated heartbeat monitors so overrides or callbacks can recover from stimulus hangs fast."
          },
          {
            "title": "UVM Callbacks & Factory Overrides | Advanced UVM Sequencing",
            "slug": "uvm-callbacks",
            "description": "Combine callbacks with factory overrides so you can instrument VIP, inject errors, and audit behaviour without touching source modules."
          }
        ]
      },
      {
        "title": "A-UVM-3: Advanced UVM Techniques & Strategy",
        "slug": "A-UVM-3_Advanced_UVM_Techniques",
        "topics": [
          {
            "title": "A-UVM-3: Advanced UVM Techniques & Strategy",
            "slug": "index",
            "description": "Orchestrate register models, virtual sequences, callbacks, and functional coverage to harden complex UVM environments."
          }
        ]
      },
      {
        "title": "A-UVM-4: The UVM Register Abstraction Layer (RAL)",
        "slug": "A-UVM-4_The_UVM_Register_Abstraction_Layer_RAL",
        "topics": [
          {
            "title": "A-UVM-4: The UVM Register Abstraction Layer (RAL)",
            "slug": "index",
            "description": "Model DUT registers once, drive them through any bus, and balance frontdoor/backdoor access for realistic yet fast verification."
          },
          {
            "title": "Built-in RAL Sequences & Utilities | Advanced UVM RAL",
            "slug": "built-in-ral-sequences",
            "description": "Leverage UVM’s prebuilt register sequences—reset, bit-bash, mem tests—and learn how to extend or constrain them safely."
          },
          {
            "title": "Explicit vs. Implicit Prediction | Advanced UVM RAL",
            "slug": "explicit-vs-implicit",
            "description": "Choose the right prediction strategy so your RAL mirror tracks DUT state without redundant bus traffic."
          },
          {
            "title": "Frontdoor vs. Backdoor Access | Advanced UVM RAL",
            "slug": "frontdoor-vs-backdoor",
            "description": "Blend frontdoor realism with backdoor speed—learn when to poke directly and when to march through the bus for accurate checking."
          }
        ]
      }
    ]
  },
  {
    "title": "Expert",
    "slug": "T4_Expert",
    "tier": "T4",
    "sections": [
      {
        "title": "E-CUST-1: UVM Methodology Customization",
        "slug": "E-CUST-1_UVM_Methodology_Customization",
        "topics": [
          {
            "title": "E-CUST-1: UVM Methodology Customization",
            "slug": "index",
            "description": "Design project-wide extensions to UVM—custom bases, phases, and governance—to keep large teams aligned without forking the methodology."
          }
        ]
      },
      {
        "title": "E-DBG-1: Advanced UVM Debug Methodologies",
        "slug": "E-DBG-1_Advanced_UVM_Debug_Methodologies",
        "topics": [
          {
            "title": "E-DBG-1: Advanced UVM Debug Methodologies",
            "slug": "index",
            "description": "Instrument your UVM environment with traceability, telemetry, and heuristics so complex failures become explainable fast."
          },
          {
            "title": "Effective Debug Techniques in UVM | The Professional Verification Craft",
            "slug": "effective-debug",
            "description": "Tried-and-true methods for diagnosing tricky failures."
          },
          {
            "title": "Hang Lab: Practising UVM Deadlock Recovery",
            "slug": "hang-lab",
            "description": "Use the debugging simulator to rehearse objection tracing, heartbeat analysis, and item_done triage on realistic UVM hangs."
          },
          {
            "title": "Reusable Verification IP (VIP) Architecture | The Professional Verification Craft",
            "slug": "reusable-vip",
            "description": "Patterns for building maintainable verification components."
          }
        ]
      },
      {
        "title": "E-INT-1: Integrating UVM with Formal Verification",
        "slug": "E-INT-1_Integrating_UVM_with_Formal_Verification",
        "topics": [
          {
            "title": "E-INT-1: Integrating UVM with Formal Verification",
            "slug": "index",
            "description": "Bridge simulation and proof: share assertions, align coverage, and orchestrate flows where UVM and formal reinforce each other."
          },
          {
            "title": "Direct Programming Interface (DPI) | The Professional Verification Craft",
            "slug": "dpi",
            "description": "C interoperability for performance and modeling flexibility."
          },
          {
            "title": "Introduction to Portable Stimulus (PSS) | The Professional Verification Craft",
            "slug": "pss",
            "description": "Conceptual overview of portable stimulus methodology."
          }
        ]
      },
      {
        "title": "E-PERF-1: UVM Performance",
        "slug": "E-PERF-1_UVM_Performance",
        "topics": [
          {
            "title": "E-PERF-1: UVM Performance",
            "slug": "index",
            "description": "Profile, architect, and operationalize UVM environments so regressions stay fast without sacrificing fidelity."
          }
        ]
      },
      {
        "title": "E-SOC-1: SoC-Level Verification Strategies",
        "slug": "E-SOC-1_SoC-Level_Verification_Strategies",
        "topics": [
          {
            "title": "E-SOC-1: SoC-Level Verification Strategies",
            "slug": "index",
            "description": "Scale block-level infrastructure to SoC: plan reuse, configure virtual platforms, and coordinate cross-team stimulus."
          },
          {
            "title": "Coverage Closure and Metrics | The Professional Verification Craft",
            "slug": "coverage-closure",
            "description": "Using coverage results to measure verification completeness."
          },
          {
            "title": "Regression and Triage Strategies | The Professional Verification Craft",
            "slug": "regression-triage",
            "description": "Building stable regressions and quickly diagnosing failures."
          }
        ]
      }
    ]
  }
];

// Helper functions to navigate the new structure

export function normalizeSlug(slug: string[]): string[] {
  if (slug.length >= 3) {
    return slug.slice(0, 3);
  }
  if (slug.length === 0) return [];

  const [tierSlug, sectionSlug] = slug;
  const courseModule = curriculumData.find(m => m.slug === tierSlug);
  if (!courseModule) return [];

  if (slug.length === 1) {
    const firstSection = courseModule.sections[0];
    if (!firstSection) return [];
    const firstTopic = firstSection.topics.find(t => t.slug === 'index') ?? firstSection.topics[0];
    if (!firstTopic) return [];
    return [tierSlug, firstSection.slug, firstTopic.slug];
  }

  const section = courseModule.sections.find(s => s.slug === sectionSlug);
  if (!section) return [];
  const topic = section.topics.find(t => t.slug === 'index') ?? section.topics[0];
  if (!topic) return [];
  return [tierSlug, section.slug, topic.slug];
}

export function findTopicBySlug(slug: string[]): Topic | undefined {
  const normalized = normalizeSlug(slug);
  if (normalized.length !== 3) return undefined;
  const [tierSlug, sectionSlug, topicSlug] = normalized;
  const courseModule = curriculumData.find(m => m.slug === tierSlug);
  if (!courseModule) return undefined;
  const section = courseModule.sections.find(s => s.slug === sectionSlug);
  if (!section) return undefined;
  return section.topics.find(t => t.slug === topicSlug);
}

export function getBreadcrumbs(slug: string[]): { title: string, path: string }[] {
  const normalized = normalizeSlug(slug);
  if (normalized.length !== 3) return [];
  const [tierSlug, sectionSlug, topicSlug] = normalized;
  const breadcrumbs: { title: string, path: string }[] = [];
  const courseModule = curriculumData.find(m => m.slug === tierSlug);
  if (!courseModule) return breadcrumbs;

  breadcrumbs.push({ title: "Curriculum", path: `/curriculum` });
  breadcrumbs.push({ title: courseModule.title, path: `/curriculum/${courseModule.slug}` });

  const section = courseModule.sections.find(s => s.slug === sectionSlug);
  if (!section) return breadcrumbs;
  breadcrumbs.push({ title: section.title, path: `/curriculum/${courseModule.slug}/${section.slug}` });

  const topic = section.topics.find(t => t.slug === topicSlug);
  if (topic) {
    breadcrumbs.push({ title: topic.title, path: `/curriculum/${courseModule.slug}/${section.slug}/${topic.slug}` });
  }

  return breadcrumbs;
}

export function findPrevNextTopics(slug: string[]): { prev: Topic | undefined, next: Topic | undefined } {
  const normalized = normalizeSlug(slug);
  if (normalized.length !== 3) return { prev: undefined, next: undefined };

  const allTopics: Topic[] = [];
  curriculumData.forEach(m => {
    m.sections.forEach(s => {
      s.topics.forEach(t => {
        allTopics.push({ ...t, slug: `${m.slug}/${s.slug}/${t.slug}` });
      });
    });
  });

  const currentIndex = allTopics.findIndex(t => t.slug === normalized.join('/'));
  if (currentIndex === -1) return { prev: undefined, next: undefined };

  const prev = currentIndex > 0 ? allTopics[currentIndex - 1] : undefined;
  const next = currentIndex < allTopics.length - 1 ? allTopics[currentIndex + 1] : undefined;

  return { prev, next };
}

// ---- Derived convenience types for the application UI ----

// The curriculumData array represents the high level tiers of the course. The
// UI components expect a `Tier` type with a list of `modules`.  Each module in
// turn contains a list of lessons.  The existing data maps cleanly onto this
// structure where a "Module" is a tier and each "Section" is a module.  The
// topics within a section represent the lessons.

export type Tier = Module;
export type Lesson = Topic;
export interface ModuleEntry {
  id: string;
  title: string;
  slug: string;
  lessons: Lesson[];
}

export const tiers: Tier[] = curriculumData;

export function getModules(tier: Tier): ModuleEntry[] {
  return tier.sections.map(section => ({
    id: section.slug,
    title: section.title,
    slug: section.slug,
    lessons: section.topics,
  }));
}

