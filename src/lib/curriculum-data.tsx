// This file is auto-generated by scripts/generate-curriculum-data.ts. Do not edit manually.

export interface Topic {
  title: string;
  slug: string;
  description: string;
}

export interface Section {
  title: string;
  slug: string;
  topics: Topic[];
}

export interface Module {
  title: string;
  slug: string;
  tier: string;
  sections: Section[];
}

export const curriculumData: Module[] = [
  {
    "title": "Foundational",
    "slug": "T1_Foundational",
    "tier": "T1",
    "sections": [
      {
        "title": "F1A: The Cost of Bugs",
        "slug": "F1A_The_Cost_of_Bugs",
        "topics": [
          {
            "title": "F1A: The Cost of Bugs",
            "slug": "index",
            "description": "Understand the economic and reputational stakes of verification in the semiconductor industry."
          }
        ]
      },
      {
        "title": "F1B: The Verification Mindset",
        "slug": "F1B_The_Verification_Mindset",
        "topics": [
          {
            "title": "F1B: The Verification Mindset",
            "slug": "index",
            "description": "Adopt the destructive testing philosophy and explore the methodologies used to break designs."
          }
        ]
      },
      {
        "title": "F1C: Why SystemVerilog?",
        "slug": "F1C_Why_SystemVerilog",
        "topics": [
          {
            "title": "F1C: Why SystemVerilog?",
            "slug": "index",
            "description": "Discover why SystemVerilog replaced Verilog as the industry standard for verification."
          }
        ]
      },
      {
        "title": "F2A: Core Data Types",
        "slug": "F2A_Core_Data_Types",
        "topics": [
          {
            "title": "F2A: Core Data Types",
            "slug": "index",
            "description": "Dive deep into SystemVerilog nets, variables, and value systems with interactive explorers grounded in IEEE 1800-2023."
          }
        ]
      },
      {
        "title": "F2B: Dynamic Data Structures",
        "slug": "F2B_Dynamic_Structures",
        "topics": [
          {
            "title": "F2B: Dynamic Data Structures",
            "slug": "index",
            "description": "Manipulate dynamic arrays, queues, and associative arrays with an IEEE 1800-2023 guided workflow."
          }
        ]
      },
      {
        "title": "F3A: Procedural Blocks and Flow Control",
        "slug": "F2C_Procedural_Code_and_Flow_Control",
        "topics": [
          {
            "title": "F3A: Procedural Blocks and Flow Control",
            "slug": "index",
            "description": "Master the procedural heart of SystemVerilog—initial/always/final blocks, flow control, and assignment semantics that drive every testbench."
          },
          {
            "title": "Procedural Flow Control",
            "slug": "flow-control",
            "description": "Guide decisions with if, case, and loop constructs to steer simulation flow."
          }
        ]
      },
      {
        "title": "F3D: System Tasks and File I/O",
        "slug": "F2D_Reusable_Code_and_Parallelism",
        "topics": [
          {
            "title": "F3D: System Tasks and File I/O",
            "slug": "index",
            "description": "Interact with the simulator kernel: print messages, cast types, generate random numbers, and read/write files."
          },
          {
            "title": "F3D: Interprocess Communication",
            "slug": "ipc",
            "description": "Coordinate parallel threads safely using Semaphores and Mailboxes."
          }
        ]
      },
      {
        "title": "F4A: Structuring Designs with Modules and Packages",
        "slug": "F4A_Modules_and_Packages",
        "topics": [
          {
            "title": "F4A: Structuring Designs with Modules and Packages",
            "slug": "index",
            "description": "Wire up designs and verification harnesses with modules and packages that keep signal intent crystal clear."
          }
        ]
      },
      {
        "title": "F4B: Bundling Signals with Interfaces and Modports",
        "slug": "F4B_Interfaces_and_Modports",
        "topics": [
          {
            "title": "F4B: Bundling Signals with Interfaces and Modports",
            "slug": "index",
            "description": "Learn how to use SystemVerilog interfaces and modports to simplify connections and create reusable verification components."
          }
        ]
      },
      {
        "title": "F4C: Synchronizing with Clocking and Program Blocks",
        "slug": "F4C_Clocking_Blocks",
        "topics": [
          {
            "title": "F4C: Synchronizing with Clocking and Program Blocks",
            "slug": "index",
            "description": "Understand how clocking blocks help create race-free testbenches by defining clear timing for signal interaction."
          }
        ]
      }
    ]
  },
  {
    "title": "Intermediate",
    "slug": "T2_Intermediate",
    "tier": "T2",
    "sections": [
      {
        "title": "I-SV-1: Object-Oriented Programming for Verification",
        "slug": "I-SV-1_OOP",
        "topics": [
          {
            "title": "I-SV-1: Object-Oriented Programming for Verification",
            "slug": "index",
            "description": "Build reusable, polymorphic verification components with SystemVerilog classes, inheritance, and virtual methods."
          },
          {
            "title": "Constructors, 'this', and 'super' | Advanced SystemVerilog for Verification",
            "slug": "constructors",
            "description": "How to create objects with new and reference parent and current class members using this and super."
          },
          {
            "title": "Copying and Cloning Objects | SystemVerilog OOP",
            "slug": "copying-and-cloning",
            "description": "Understand shallow vs. deep copy in SystemVerilog, and how to implement robust copy() and clone() methods."
          },
          {
            "title": "Parameterized Classes and Abstract Classes | Advanced SystemVerilog for Verification",
            "slug": "parameterized-classes",
            "description": "Use generics and abstract classes to build reusable components while avoiding common pitfalls."
          },
          {
            "title": "Polymorphism Pitfalls and Type Casting | SystemVerilog OOP",
            "slug": "polymorphism-pitfalls",
            "description": "Learn how virtual method resolution works, upcasting vs. downcasting, and how to safely use $cast."
          }
        ]
      },
      {
        "title": "I-SV-2A: Constrained Randomization Fundamentals",
        "slug": "I-SV-2A_Constrained_Randomization_Fundamentals",
        "topics": [
          {
            "title": "I-SV-2A: Constrained Randomization Fundamentals",
            "slug": "index",
            "description": "Guide SystemVerilog's random stimulus with constraints, distributions, and inline tweaks to uncover corner-case bugs fast."
          },
          {
            "title": "Constraint Blocks, soft, and solve...before | Advanced SystemVerilog for Verification",
            "slug": "constraint-blocks",
            "description": "Control dependencies and defaults using constraint blocks, soft values, and solve-before ordering."
          }
        ]
      },
      {
        "title": "I-SV-2B: Advanced Constrained Randomization",
        "slug": "I-SV-2B_Advanced_Constrained_Randomization",
        "topics": [
          {
            "title": "I-SV-2B: Advanced Constrained Randomization",
            "slug": "index",
            "description": "Master advanced solver techniques, multi-level constraints, implication, and solver debug triage."
          },
          {
            "title": "Advanced Constraints: implication and iteration | Advanced SystemVerilog for Verification",
            "slug": "advanced-constraints",
            "description": "Express conditional and iterative rules with implication and foreach constructs."
          },
          {
            "title": "Controlling Randomization: pre_randomize and post_randomize | Advanced SystemVerilog for Verification",
            "slug": "controlling-randomization",
            "description": "Hook solver callbacks with pre_randomize and post_randomize to prepare and finalize objects."
          },
          {
            "title": "Solver Debug and Failure Triage | Advanced SystemVerilog for Verification",
            "slug": "solver-debug",
            "description": "Learn how to approach constraint solver failures, debug conflicting constraints, and use built-in simulator tools."
          }
        ]
      },
      {
        "title": "I-SV-3A: Functional Coverage Fundamentals",
        "slug": "I-SV-3A_Functional_Coverage_Fundamentals",
        "topics": [
          {
            "title": "I-SV-3A: Functional Coverage Fundamentals",
            "slug": "index",
            "description": "Model verification intent with covergroups, coverpoints, and crosses to prove you've exercised every critical scenario."
          },
          {
            "title": "Coverage Options and Sampling | Advanced UVM Techniques & Strategy",
            "slug": "coverage-options",
            "description": "Learn how covergroup options influence when and how data is sampled."
          }
        ]
      },
      {
        "title": "I-SV-3B: Advanced Functional Coverage",
        "slug": "I-SV-3B_Advanced_Functional_Coverage",
        "topics": [
          {
            "title": "I-SV-3B: Advanced Functional Coverage",
            "slug": "index",
            "description": "Master coverage to V-Plan linkage, API querying, and coverage-driven constrained random loops."
          },
          {
            "title": "Linking Coverage to the V-Plan | Advanced UVM Techniques & Strategy",
            "slug": "linking-coverage",
            "description": "Tie functional coverage points back to verification plan items."
          }
        ]
      },
      {
        "title": "I-SV-4A: Assertions (SVA) Fundamentals",
        "slug": "I-SV-4A_Assertions_SVA_Fundamentals",
        "topics": [
          {
            "title": "I-SV-4A: Assertions (SVA) Fundamentals",
            "slug": "index",
            "description": "Specify temporal intent with SystemVerilog Assertions so your verification environment automatically checks protocol rules."
          },
          {
            "title": "Immediate vs. Concurrent Assertions | Advanced SystemVerilog for Verification",
            "slug": "immediate-vs-concurrent",
            "description": "Compare procedural checks with temporal properties through hands-on examples."
          }
        ]
      },
      {
        "title": "I-SV-4B: Advanced SVA",
        "slug": "I-SV-4B_Advanced_SVA",
        "topics": [
          {
            "title": "I-SV-4B: Advanced SVA",
            "slug": "index",
            "description": "Master multi-clock assertions, local variables, and binding checkers into your design."
          },
          {
            "title": "Local Variables in Sequences | Advanced SystemVerilog for Verification",
            "slug": "local-variables",
            "description": "Capture and reuse values within sequences to create robust properties."
          },
          {
            "title": "Multi-Clocking and disable-iff | Advanced SystemVerilog for Verification",
            "slug": "multi-clocking",
            "description": "Coordinate assertions across clock domains and mask reset behavior with disable iff."
          }
        ]
      },
      {
        "title": "I-SV-5: Synchronization and IPC",
        "slug": "I-SV-5_Synchronization_and_IPC",
        "topics": [
          {
            "title": "I-SV-5: Synchronization and IPC",
            "slug": "index",
            "description": "Master SystemVerilog's built-in inter-process communication primitives: events, mailboxes, and semaphores."
          },
          {
            "title": "Events | Advanced SystemVerilog for Verification",
            "slug": "events",
            "description": "Synchronize parallel processes with SystemVerilog events."
          },
          {
            "title": "Mailboxes | Advanced SystemVerilog for Verification",
            "slug": "mailboxes",
            "description": "Use mailboxes for thread-safe communication between processes."
          },
          {
            "title": "Semaphores | Advanced SystemVerilog for Verification",
            "slug": "semaphores",
            "description": "Control access to shared resources using semaphore keys."
          }
        ]
      },
      {
        "title": "I-UVM-1A: UVM Objects and Components",
        "slug": "I-UVM-1A_Components",
        "topics": [
          {
            "title": "I-UVM-1A: UVM Objects and Components",
            "slug": "index",
            "description": "Understand the fundamental split between data containers and structural elements in UVM testbenches."
          }
        ]
      },
      {
        "title": "I-UVM-1B: The UVM Factory",
        "slug": "I-UVM-1B_The_UVM_Factory",
        "topics": [
          {
            "title": "I-UVM-1B: The UVM Factory",
            "slug": "index",
            "description": "Swap component and object implementations dynamically using UVM's factory registry without touching your testbench wiring."
          }
        ]
      },
      {
        "title": "I-UVM-1C: UVM Phasing and Synchronization",
        "slug": "I-UVM-1C_UVM_Phasing",
        "topics": [
          {
            "title": "I-UVM-1C: UVM Phasing and Synchronization",
            "slug": "index",
            "description": "Orchestrate build, run, and cleanup with UVM phases, domains, objections, and synchronization primitives so every component stays in lockstep."
          }
        ]
      },
      {
        "title": "I-UVM-2A: Component Roles and the Testbench Hierarchy",
        "slug": "I-UVM-2A_Component_Roles",
        "topics": [
          {
            "title": "I-UVM-2A: Component Roles and the Testbench Hierarchy",
            "slug": "index",
            "description": "Understand the blueprint of a UVM environment—tests orchestrate, environments aggregate, agents wrap interface logic, monitors observe, and scoreboards verify."
          }
        ]
      },
      {
        "title": "I-UVM-2B: TLM Connections and Analysis Fabric",
        "slug": "I-UVM-2B_TLM_Connections",
        "topics": [
          {
            "title": "I-UVM-2B: TLM Connections and Analysis Fabric",
            "slug": "index",
            "description": "Wire sequencers, drivers, monitors, and scoreboards using UVM's Transaction-Level Modeling (TLM) components."
          }
        ]
      },
      {
        "title": "I-UVM-2C: Configuration and Resources",
        "slug": "I-UVM-2C_Configuration_and_Resources",
        "topics": [
          {
            "title": "I-UVM-2C: Configuration and Resources",
            "slug": "index",
            "description": "Use uvm_config_db and uvm_resource_db to pass settings and virtual interface handles down the hierarchy without tight coupling."
          }
        ]
      },
      {
        "title": "I-UVM-3A: Basic UVM Sequences and Items",
        "slug": "I-UVM-3A_Fundamentals",
        "topics": [
          {
            "title": "I-UVM-3A: Basic UVM Sequences and Items",
            "slug": "index",
            "description": "Model robust transaction items and author reusable UVM sequences that drive the sequencer ↔ driver handshake."
          }
        ]
      },
      {
        "title": "I-UVM-3B: Advanced Sequencing and Layering",
        "slug": "I-UVM-3B_Advanced_Sequencing_and_Layering",
        "topics": [
          {
            "title": "I-UVM-3B: Advanced Sequencing and Layering",
            "slug": "index",
            "description": "Master virtual sequences, arbitration, layering, and driver-sequencer synchronization patterns."
          },
          {
            "title": "Interrupt Handling and Layered Stimulus | Advanced UVM Sequencing",
            "slug": "interrupt-handling",
            "description": "Turn asynchronous interrupts into deterministic stimulus by combining monitor events, routing policy, and virtual sequences."
          },
          {
            "title": "Layered Sequences and p_sequencer | Advanced UVM Sequencing",
            "slug": "layered-sequences",
            "description": "Design atomic, scenario, and virtual layers of sequences while using p_sequencer to orchestrate cross-agent stimulus."
          },
          {
            "title": "Sequence Arbitration and Priority | Advanced UVM Sequencing",
            "slug": "sequence-arbitration",
            "description": "Understand how UVM sequencers choose the next sequence, how to apply lock/grab, and how to customize arbitration for complex stimulus coordination."
          },
          {
            "title": "Sequence Libraries & Arbitration Control | Advanced UVM Sequencing",
            "slug": "sequence-libraries",
            "description": "Package reusable stimulus into sequence libraries, weight them, and know when to grab/ungrab for critical sections."
          },
          {
            "title": "The Sequencer-Driver Handshake | Advanced UVM Sequencing",
            "slug": "sequencer-driver-handshake",
            "description": "Dissect the blocking protocol between UVM sequencers and drivers, from arbitration to item_done(), and learn how to instrument and debug the flow."
          },
          {
            "title": "UVM Virtual Sequencer",
            "slug": "uvm-virtual-sequencer",
            "description": "Coordinating stimulus across multiple agents."
          },
          {
            "title": "Virtual Sequences and Sequencers",
            "slug": "virtual-sequences",
            "description": "Learn how to use virtual sequences and sequencers to coordinate and synchronize stimulus across multiple agents in a UVM testbench."
          }
        ]
      }
    ]
  },
  {
    "title": "Advanced",
    "slug": "T3_Advanced",
    "tier": "T3",
    "sections": [
      {
        "title": "A-UVM-4A: RAL Fundamentals",
        "slug": "A-UVM-4A_RAL_Fundamentals",
        "topics": [
          {
            "title": "A-UVM-4A: RAL Fundamentals",
            "slug": "index",
            "description": "Model DUT registers once and decouple stimulus from physical bus protocols."
          }
        ]
      },
      {
        "title": "A-UVM-4B: Advanced RAL Techniques",
        "slug": "A-UVM-4B_Advanced_RAL_Techniques",
        "topics": [
          {
            "title": "A-UVM-4B: Advanced RAL Techniques",
            "slug": "index",
            "description": "Master adapters, predictors, and sophisticated debug workflows for robust UVM register environments."
          },
          {
            "title": "Built-in RAL Sequences & Utilities | Advanced UVM RAL",
            "slug": "built-in-ral-sequences",
            "description": "Leverage UVM’s prebuilt register sequences—reset, bit-bash, mem tests—and learn how to extend or constrain them safely."
          },
          {
            "title": "Explicit vs. Implicit Prediction | Advanced UVM RAL",
            "slug": "explicit-vs-implicit",
            "description": "Choose the right prediction strategy so your RAL mirror tracks DUT state without redundant bus traffic."
          },
          {
            "title": "Frontdoor vs. Backdoor Access | Advanced UVM RAL",
            "slug": "frontdoor-vs-backdoor",
            "description": "Blend frontdoor realism with backdoor speed—learn when to poke directly and when to march through the bus for accurate checking."
          }
        ]
      },
      {
        "title": "A-UVM-5: UVM Callbacks",
        "slug": "A-UVM-5_UVM_Callbacks",
        "topics": [
          {
            "title": "A-UVM-5: UVM Callbacks",
            "slug": "index",
            "description": "Inject optional behavior into components without exploding your class hierarchy or hacking the base code."
          }
        ]
      }
    ]
  },
  {
    "title": "Expert",
    "slug": "T4_Expert",
    "tier": "T4",
    "sections": [
      {
        "title": "E-CUST-1: UVM Methodology Customization",
        "slug": "E-CUST-1_UVM_Methodology_Customization",
        "topics": [
          {
            "title": "E-CUST-1: UVM Methodology Customization",
            "slug": "index",
            "description": "Design project-wide extensions to UVM—custom bases, phases, and governance—to keep large teams aligned without forking the methodology."
          }
        ]
      },
      {
        "title": "E-DBG-1: Advanced UVM Debug Methodologies",
        "slug": "E-DBG-1_Advanced_UVM_Debug_Methodologies",
        "topics": [
          {
            "title": "E-DBG-1: Advanced UVM Debug Methodologies",
            "slug": "index",
            "description": "Instrument your UVM environment with traceability, telemetry, and heuristics so complex failures become explainable fast."
          },
          {
            "title": "Effective Debug Techniques in UVM | The Professional Verification Craft",
            "slug": "effective-debug",
            "description": "Tried-and-true methods for diagnosing tricky failures."
          },
          {
            "title": "Hang Lab: Practising UVM Deadlock Recovery",
            "slug": "hang-lab",
            "description": "Use the debugging simulator to rehearse objection tracing, heartbeat analysis, and item_done triage on realistic UVM hangs."
          },
          {
            "title": "Reusable Verification IP (VIP) Architecture | The Professional Verification Craft",
            "slug": "reusable-vip",
            "description": "Patterns for building maintainable verification components."
          }
        ]
      },
      {
        "title": "E-INT-1: Integrating UVM with Formal Verification",
        "slug": "E-INT-1_Integrating_UVM_with_Formal_Verification",
        "topics": [
          {
            "title": "E-INT-1: Integrating UVM with Formal Verification",
            "slug": "index",
            "description": "Bridge simulation and proof: share assertions, align coverage, and orchestrate flows where UVM and formal reinforce each other."
          },
          {
            "title": "Direct Programming Interface (DPI) | The Professional Verification Craft",
            "slug": "dpi",
            "description": "C interoperability for performance and modeling flexibility."
          },
          {
            "title": "Introduction to Portable Stimulus (PSS) | The Professional Verification Craft",
            "slug": "pss",
            "description": "Conceptual overview of portable stimulus methodology."
          }
        ]
      },
      {
        "title": "E-PERF-1: UVM Performance",
        "slug": "E-PERF-1_UVM_Performance",
        "topics": [
          {
            "title": "E-PERF-1: UVM Performance",
            "slug": "index",
            "description": "Profile, architect, and operationalize UVM environments so regressions stay fast without sacrificing fidelity."
          }
        ]
      },
      {
        "title": "E-SOC-1: SoC-Level Verification Strategies",
        "slug": "E-SOC-1_SoC-Level_Verification_Strategies",
        "topics": [
          {
            "title": "E-SOC-1: SoC-Level Verification Strategies",
            "slug": "index",
            "description": "Scale block-level infrastructure to SoC: plan reuse, configure virtual platforms, and coordinate cross-team stimulus."
          },
          {
            "title": "Coverage Closure and Metrics | The Professional Verification Craft",
            "slug": "coverage-closure",
            "description": "Using coverage results to measure verification completeness."
          },
          {
            "title": "Regression and Triage Strategies | The Professional Verification Craft",
            "slug": "regression-triage",
            "description": "Building stable regressions and quickly diagnosing failures."
          }
        ]
      }
    ]
  }
];

// Helper functions to navigate the new structure

export function normalizeSlug(slug: string[]): string[] {
  if (slug.length >= 3) {
    return slug.slice(0, 3);
  }
  if (slug.length === 0) return [];

  const [tierSlug, sectionSlug] = slug;
  const courseModule = curriculumData.find(m => m.slug === tierSlug);
  if (!courseModule) return [];

  if (slug.length === 1) {
    const firstSection = courseModule.sections[0];
    if (!firstSection) return [];
    const firstTopic = firstSection.topics.find(t => t.slug === 'index') ?? firstSection.topics[0];
    if (!firstTopic) return [];
    return [tierSlug, firstSection.slug, firstTopic.slug];
  }

  const section = courseModule.sections.find(s => s.slug === sectionSlug);
  if (!section) return [];
  const topic = section.topics.find(t => t.slug === 'index') ?? section.topics[0];
  if (!topic) return [];
  return [tierSlug, section.slug, topic.slug];
}

export function findTopicBySlug(slug: string[]): Topic | undefined {
  const normalized = normalizeSlug(slug);
  if (normalized.length !== 3) return undefined;
  const [tierSlug, sectionSlug, topicSlug] = normalized;
  const courseModule = curriculumData.find(m => m.slug === tierSlug);
  if (!courseModule) return undefined;
  const section = courseModule.sections.find(s => s.slug === sectionSlug);
  if (!section) return undefined;
  return section.topics.find(t => t.slug === topicSlug);
}

export function getBreadcrumbs(slug: string[]): { title: string, path: string }[] {
  const normalized = normalizeSlug(slug);
  if (normalized.length !== 3) return [];
  const [tierSlug, sectionSlug, topicSlug] = normalized;
  const breadcrumbs: { title: string, path: string }[] = [];
  const courseModule = curriculumData.find(m => m.slug === tierSlug);
  if (!courseModule) return breadcrumbs;

  breadcrumbs.push({ title: "Curriculum", path: `/curriculum` });
  breadcrumbs.push({ title: courseModule.title, path: `/curriculum/${courseModule.slug}` });

  const section = courseModule.sections.find(s => s.slug === sectionSlug);
  if (!section) return breadcrumbs;
  breadcrumbs.push({ title: section.title, path: `/curriculum/${courseModule.slug}/${section.slug}` });

  const topic = section.topics.find(t => t.slug === topicSlug);
  if (topic) {
    breadcrumbs.push({ title: topic.title, path: `/curriculum/${courseModule.slug}/${section.slug}/${topic.slug}` });
  }

  return breadcrumbs;
}

export function findPrevNextTopics(slug: string[]): { prev: Topic | undefined, next: Topic | undefined } {
  const normalized = normalizeSlug(slug);
  if (normalized.length !== 3) return { prev: undefined, next: undefined };

  const allTopics: Topic[] = [];
  curriculumData.forEach(m => {
    m.sections.forEach(s => {
      s.topics.forEach(t => {
        allTopics.push({ ...t, slug: `${m.slug}/${s.slug}/${t.slug}` });
      });
    });
  });

  const currentIndex = allTopics.findIndex(t => t.slug === normalized.join('/'));
  if (currentIndex === -1) return { prev: undefined, next: undefined };

  const prev = currentIndex > 0 ? allTopics[currentIndex - 1] : undefined;
  const next = currentIndex < allTopics.length - 1 ? allTopics[currentIndex + 1] : undefined;

  return { prev, next };
}

// ---- Derived convenience types for the application UI ----

// The curriculumData array represents the high level tiers of the course. The
// UI components expect a `Tier` type with a list of `modules`.  Each module in
// turn contains a list of lessons.  The existing data maps cleanly onto this
// structure where a "Module" is a tier and each "Section" is a module.  The
// topics within a section represent the lessons.

export type Tier = Module;
export type Lesson = Topic;
export interface ModuleEntry {
  id: string;
  title: string;
  slug: string;
  lessons: Lesson[];
}

export const tiers: Tier[] = curriculumData;

export function getModules(tier: Tier): ModuleEntry[] {
  return tier.sections.map(section => ({
    id: section.slug,
    title: section.title,
    slug: section.slug,
    lessons: section.topics,
  }));
}

