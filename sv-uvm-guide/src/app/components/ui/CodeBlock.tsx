import React from 'react';
import { rehype } from 'rehype';
import rehypePrettyCode from 'rehype-pretty-code';
import { CopyButton } from './CopyButton'; // Client component for the button

import type { Root as HastRoot, Element as HastElement } from 'hast'; // For node types

interface CodeBlockProps {
  code: string;
  language: string; // language is useful for semantics, CopyButton, and potentially future features
  className?: string;
  theme?: string;
}

const CodeBlock: React.FC<CodeBlockProps> = async ({
  code,
  language, // language prop is explicitly passed for clarity and potential future use
  className = '',
  theme = 'github-dark'
}) => {
  const options: any = { // Use any for options if rehype-pretty-code types are not available
    theme: theme,
    keepBackground: true,
    // The `language` prop can be passed to `rehype-pretty-code` if it supports an explicit lang option,
    // or used to construct a language class if processing markdown/html directly.
    // For direct string processing, shiki (used by r-p-c) usually needs language in `highlight` call,
    // or infers. r-p-c might take a defaultLanguage option.
    // For now, we include `language` in options to mark it as "used" for linting,
    // actual effect depends on rehype-pretty-code's specific API for this.
    defaultLanguage: language, // Example of how it might be used if supported

    onVisitLine(node: HastElement) { // Changed 'any' to 'HastElement'
      if (node.children.length === 0) {
        node.children = [{ type: 'text', value: ' ' }];
      }
    },
    onVisitHighlightedLine(node: HastElement) { // Changed 'any' to 'HastElement'
      if (node.properties && Array.isArray(node.properties.className)) {
        node.properties.className.push('highlighted');
      } else if (node.properties) {
        node.properties.className = ['highlighted'];
      }
    },
    onVisitHighlightedChars(node: HastElement) { // Changed 'any' to 'HastElement'
      if (node.properties) {
        node.properties.className = ['word--highlighted'];
      } else {
        // Ensure properties exist if they don't (though they should for highlighted chars)
        node.properties = { className: ['word--highlighted'] };
      }
    },
  };

  const highlightedCode = await rehype()
    .data('settings', { fragment: true })
    // @ts-expect-error - rehype-pretty-code types might not perfectly align with rehype, using expect-error
    .use(rehypePrettyCode, options)
    .process(code);

  return (
    <div className={`relative group ${className}`}>
      <CopyButton textToCopy={code} />
      <div
        className="prose prose-sm dark:prose-invert max-w-none
                   [&>pre]:bg-background/80 [&>pre]:backdrop-blur-sm [&>pre]:border [&>pre]:border-[rgba(100,255,218,0.2)]
                   [&>pre]:rounded-md [&>pre]:p-4 [&>pre]:shadow-md
                   [&_code]:font-mono [&_code]:text-sm" // Ensure mono font and consistent sizing
        dangerouslySetInnerHTML={{ __html: highlightedCode.toString() }}
      />
      {/*
        Styling note:
        - The [&>pre] targets the <pre> tag generated by rehype-pretty-code.
        - We apply background, border, rounded corners, and padding here.
        - `prose` and `prose-sm dark:prose-invert` provide some base styling for code elements.
        - `max-w-none` is important if this is inside a container with max-width.
        - `[&_code]:font-mono` ensures the code itself uses the mono font family.
      */}
    </div>
  );
};

export { CodeBlock };
