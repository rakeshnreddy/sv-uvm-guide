import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Button, buttonVariants } from './Button'; // Assuming Button.tsx is in the same directory or path is adjusted
import React from 'react';

// Mock framer-motion specifically for these tests if not done globally
// This allows us to check props passed to motion.button without complex animation testing
vi.mock('framer-motion', async () => {
  const actual = await vi.importActual('framer-motion');
  return {
    ...actual,
    motion: {
      ...actual.motion,
      button: React.forwardRef(({ whileHover, whileTap, ...props }: any, ref: any) => (
        <button
          ref={ref}
          {...props}
          data-whilehover={JSON.stringify(whileHover)} // Pass animation props for inspection
          data-whiletap={JSON.stringify(whileTap)}
        />
      )),
    },
  };
});

describe('Button Component', () => {
  it('renders correctly with children', () => {
    render(<Button>Click Me</Button>);
    const buttonElement = screen.getByRole('button', { name: /click me/i });
    expect(buttonElement).toBeInTheDocument();
  });

  it('applies primary variant styles by default', () => {
    render(<Button>Primary Button</Button>);
    const buttonElement = screen.getByRole('button', { name: /primary button/i });
    // Check for a class specific to the primary variant (actual class depends on cva output)
    // Example: "bg-secondary-accent"
    expect(buttonElement).toHaveClass(/bg-secondary-accent/);
    // A more robust way is to check against the classes generated by cva for that variant
    const expectedClasses = buttonVariants({ variant: 'primary' });
    expectedClasses.split(' ').forEach(cls => {
      if (cls.trim()) expect(buttonElement).toHaveClass(cls.trim());
    });
  });

  it('applies secondary variant styles when specified', () => {
    render(<Button variant="secondary">Secondary Button</Button>);
    const buttonElement = screen.getByRole('button', { name: /secondary button/i });
    // Example: "border-accent text-accent"
    expect(buttonElement).toHaveClass(/border-accent/);
    expect(buttonElement).toHaveClass(/text-accent/);
    const expectedClasses = buttonVariants({ variant: 'secondary' });
    expectedClasses.split(' ').forEach(cls => {
      if (cls.trim()) expect(buttonElement).toHaveClass(cls.trim());
    });
  });

  it('calls onClick handler when clicked', async () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Clickable</Button>);
    const buttonElement = screen.getByRole('button', { name: /clickable/i });
    await userEvent.click(buttonElement);
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('passes whileHover and whileTap props to motion.button', () => {
    render(<Button>Animated Button</Button>);
    const buttonElement = screen.getByRole('button', { name: /animated button/i });

    const expectedHoverAnimation = {
      scale: 1.05,
      boxShadow: "0px 0px 15px rgba(255, 202, 134, 0.6)", // primary variant default
      transition: { type: "spring", stiffness: 300, damping: 15 }
    };
    const expectedTapAnimation = {
      scale: 0.97,
      transition: { type: "spring", stiffness: 400, damping: 10 }
    };

    expect(buttonElement.dataset.whilehover).toBe(JSON.stringify(expectedHoverAnimation));
    expect(buttonElement.dataset.whiletap).toBe(JSON.stringify(expectedTapAnimation));
  });

  it('passes correct whileHover for secondary variant to motion.button', () => {
    render(<Button variant="secondary">Secondary Animated</Button>);
    const buttonElement = screen.getByRole('button', { name: /secondary animated/i });

    const expectedHoverAnimation = {
      scale: 1.05,
      boxShadow: "0px 0px 15px rgba(100, 255, 218, 0.6)", // secondary variant
      transition: { type: "spring", stiffness: 300, damping: 15 }
    };
    expect(buttonElement.dataset.whilehover).toBe(JSON.stringify(expectedHoverAnimation));
  });

  it('is disabled when disabled prop is true', async () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick} disabled>Disabled Button</Button>);
    const buttonElement = screen.getByRole('button', { name: /disabled button/i });
    expect(buttonElement).toBeDisabled();

    // Try clicking - it shouldn't call the handler
    // fireEvent.click(buttonElement); // userEvent might be better but can be slower
    await userEvent.click(buttonElement, { skipPointerEventsCheck: true }); // Need to skip check for disabled
    expect(handleClick).not.toHaveBeenCalled();
  });

  it('renders as a child element when asChild is true', () => {
    render(
      <Button asChild>
        <a href="/test">Link Button</a>
      </Button>
    );
    // The role is no longer 'button' but 'link' (or whatever the child is)
    const linkElement = screen.getByRole('link', { name: /link button/i });
    expect(linkElement).toBeInTheDocument();
    expect(linkElement.tagName).toBe('A');
    // Check for some base styling from buttonVariants still applied
    expect(linkElement).toHaveClass(/rounded-md/);
  });

  it('defaults to type="button" if no type is specified', () => {
    render(<Button>Default Type</Button>);
    const buttonElement = screen.getByRole('button', { name: /default type/i });
    expect(buttonElement).toHaveAttribute('type', 'button');
  });

  it('honors the type prop when specified (e.g., type="submit")', () => {
    render(<Button type="submit">Submit Button</Button>);
    const buttonElement = screen.getByRole('button', { name: /submit button/i });
    expect(buttonElement).toHaveAttribute('type', 'submit');
  });

});
