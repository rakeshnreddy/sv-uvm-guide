import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Button, buttonVariants } from './Button';

import React, { HTMLAttributes } from 'react'; // Added HTMLAttributes for more specific prop typing
import '@testing-library/jest-dom';

// Mock framer-motion specifically for these tests if not done globally
vi.mock('framer-motion', () => ({
  motion: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any

    button: ({ whileHover, whileTap, ...props }: any) => (
      <button
        {...props}
        data-whilehover={whileHover ? JSON.stringify(whileHover) : undefined}
        data-whiletap={whileTap ? JSON.stringify(whileTap) : undefined}
      />
    ),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any

    div: ({ whileHover, whileTap, ...props }: any) => (
      <div
        {...props}
        data-whilehover={whileHover ? JSON.stringify(whileHover) : undefined}
        data-whiletap={whileTap ? JSON.stringify(whileTap) : undefined}
      />
    ),
  },
  AnimatePresence: ({ children }: { children: React.ReactNode }) => <>{children}</>,
}));

describe('Button Component', () => {
  it('renders correctly with children', () => {
    render(<Button>Click Me</Button>);
    const buttonElement = screen.getByRole('button', { name: /click me/i });
    expect(buttonElement).toBeInTheDocument();
  });

  it('applies primary variant styles by default', () => {
    render(<Button>Primary Button</Button>);
    const buttonElement = screen.getByRole('button', { name: /primary button/i });
    // Check for a class specific to the primary variant (actual class depends on cva output)
    // Example: "bg-secondary-accent"
    expect(buttonElement).toHaveClass(/bg-secondary-accent/);
    // A more robust way is to check against the classes generated by cva for that variant
    const expectedClasses = buttonVariants({ variant: 'primary' });
    expectedClasses.split(' ').forEach(cls => {
      if (cls.trim()) expect(buttonElement).toHaveClass(cls.trim());
    });
  });

  it('applies secondary variant styles when specified', () => {
    render(<Button variant="secondary">Secondary Button</Button>);
    const buttonElement = screen.getByRole('button', { name: /secondary button/i });
    // Example: "border-accent text-accent"
    expect(buttonElement).toHaveClass(/border-accent/);
    expect(buttonElement).toHaveClass(/text-accent/);
    const expectedClasses = buttonVariants({ variant: 'secondary' });
    expectedClasses.split(' ').forEach(cls => {
      if (cls.trim()) expect(buttonElement).toHaveClass(cls.trim());
    });
  });

  it('calls onClick handler when clicked', async () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Clickable</Button>);
    const buttonElement = screen.getByRole('button', { name: /clickable/i });
    await userEvent.click(buttonElement);
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('passes whileHover and whileTap props to motion.button', () => {
    render(<Button>Animated Button</Button>);
    const buttonElement = screen.getByRole('button', { name: /animated button/i });

    const expectedHoverAnimation = {
      scale: 1.05,
      boxShadow: "0px 0px 15px rgba(255, 202, 134, 0.6)", // primary variant default
      transition: { type: "spring", stiffness: 300, damping: 15 }
    };
    const expectedTapAnimation = {
      scale: 0.97,
      transition: { type: "spring", stiffness: 400, damping: 10 }
    };

    expect(buttonElement.dataset.whilehover).toBe(JSON.stringify(expectedHoverAnimation));
    expect(buttonElement.dataset.whiletap).toBe(JSON.stringify(expectedTapAnimation));
  });

  it('passes correct whileHover for secondary variant to motion.button', () => {
    render(<Button variant="secondary">Secondary Animated</Button>);
    const buttonElement = screen.getByRole('button', { name: /secondary animated/i });

    const expectedHoverAnimation = {
      scale: 1.05,
      boxShadow: "0px 0px 15px rgba(100, 255, 218, 0.6)", // secondary variant
      transition: { type: "spring", stiffness: 300, damping: 15 }
    };
    expect(buttonElement.dataset.whilehover).toBe(JSON.stringify(expectedHoverAnimation));
  });

  it('is disabled when disabled prop is true', async () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick} disabled>Disabled Button</Button>);
    const buttonElement = screen.getByRole('button', { name: /disabled button/i });
    expect(buttonElement).toBeDisabled();

    // Try clicking - it shouldn't call the handler
    // fireEvent.click(buttonElement); // userEvent might be better but can be slower
    await userEvent.click(buttonElement);
    expect(handleClick).not.toHaveBeenCalled();
  });

  it('renders as a child element when asChild is true', () => {
    render(
      <Button asChild>
        <a href="/test">Link Button</a>
      </Button>
    );
    // The role is no longer 'button' but 'link' (or whatever the child is)
    const linkElement = screen.getByRole('link', { name: /link button/i });
    expect(linkElement).toBeInTheDocument();
    expect(linkElement.tagName).toBe('A');
  });

  it('defaults to type="button" if no type is specified', () => {
    render(<Button>Default Type</Button>);
    const buttonElement = screen.getByRole('button', { name: /default type/i });
    expect(buttonElement).toHaveAttribute('type', 'button');
  });

  it('honors the type prop when specified (e.g., type="submit")', () => {
    render(<Button type="submit">Submit Button</Button>);
    const buttonElement = screen.getByRole('button', { name: /submit button/i });
    expect(buttonElement).toHaveAttribute('type', 'submit');
  });

});
