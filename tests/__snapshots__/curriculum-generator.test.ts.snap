// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`curriculum generator > generated file matches snapshot 1`] = `
[
  {
    "sections": [
      {
        "slug": "F1_Why_Verification",
        "title": "F1: Why Verification?",
        "topics": [
          {
            "description": "Experience the stakes of verification through interactive stories, graphs, and your first bug hunt.",
            "slug": "index",
            "title": "F1: Why Verification?",
          },
        ],
      },
      {
        "slug": "F2A_Core_Data_Types",
        "title": "F2A: Core Data Types",
        "topics": [
          {
            "description": "Understand the SystemVerilog value system, vectors, and user-defined types with IEEE 1800-2023 grounding.",
            "slug": "index",
            "title": "F2A: Core Data Types",
          },
        ],
      },
      {
        "slug": "F2B_Dynamic_Structures",
        "title": "F2B: Dynamic Data Structures",
        "topics": [
          {
            "description": "Manipulate dynamic arrays, queues, and associative arrays with an IEEE 1800-2023 guided workflow.",
            "slug": "index",
            "title": "F2B: Dynamic Data Structures",
          },
        ],
      },
      {
        "slug": "F2C_Procedural_Code",
        "title": "F2C: Procedural Code and Flow Control",
        "topics": [
          {
            "description": "Author deterministic \`initial\`/\`always\` blocks, choose the right assignment style, and master control flow.",
            "slug": "index",
            "title": "F2C: Procedural Code and Flow Control",
          },
        ],
      },
      {
        "slug": "F2D_Reusable_and_Parallel",
        "title": "F2D: Reusable Code and Parallelism",
        "topics": [
          {
            "description": "Factor stimulus into tasks/functions and coordinate parallel threads with fork-join semantics.",
            "slug": "index",
            "title": "F2D: Reusable Code and Parallelism",
          },
        ],
      },
      {
        "slug": "F3_Procedural_Constructs",
        "title": "F3: Procedural Constructs",
        "topics": [
          {
            "description": "Master the procedural heart of SystemVerilog—initial/always/final blocks, flow control, and assignment semantics that drive every testbench.",
            "slug": "index",
            "title": "F3: Procedural Constructs",
          },
          {
            "description": "Guide decisions with if, case, and loop constructs to steer simulation flow.",
            "slug": "flow-control",
            "title": "Procedural Flow Control | SystemVerilog Language Foundations",
          },
          {
            "description": "Launch parallel threads and synchronize them with join variants.",
            "slug": "fork-join",
            "title": "Fork-Join and Process Control | SystemVerilog Language Foundations",
          },
          {
            "description": "Compare callable blocks with and without timing to structure reusable code.",
            "slug": "tasks-functions",
            "title": "Tasks and Functions: Scoping and Lifetimes | SystemVerilog Language Foundations",
          },
        ],
      },
      {
        "slug": "F4_RTL_and_Testbench_Constructs",
        "title": "F4: RTL and Testbench Constructs",
        "topics": [
          {
            "description": "Wire up designs and verification harnesses with modules, interfaces, packages, and clocking blocks that keep signal intent crystal clear.",
            "slug": "index",
            "title": "F4: RTL and Testbench Constructs",
          },
          {
            "description": "Learn how to use SystemVerilog interfaces and modports to simplify connections and create reusable verification components.",
            "slug": "interfaces",
            "title": "F4: Interfaces and Modports",
          },
          {
            "description": "Group shared declarations into reusable namespaces and manage visibility.",
            "slug": "packages",
            "title": "Packages and Compilation Scopes | SystemVerilog Language Foundations",
          },
          {
            "description": "Understand how program and clocking blocks help create race-free testbenches by separating the testbench from the DUT and defining clear timing for signal interaction.",
            "slug": "program-clocking",
            "title": "F4: Program and Clocking Blocks",
          },
        ],
      },
    ],
    "slug": "T1_Foundational",
    "tier": "T1",
    "title": "Foundational",
  },
  {
    "sections": [
      {
        "slug": "I-SV-1_OOP",
        "title": "I-SV-1: Object-Oriented Programming for Verification",
        "topics": [
          {
            "description": "Build reusable, polymorphic verification components with SystemVerilog classes, inheritance, and virtual methods.",
            "slug": "index",
            "title": "I-SV-1: Object-Oriented Programming for Verification",
          },
          {
            "description": "How to create objects with new and reference parent and current class members using this and super.",
            "slug": "constructors",
            "title": "Constructors, 'this', and 'super' | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Use generics and abstract classes to build reusable components while avoiding common pitfalls.",
            "slug": "parameterized-classes",
            "title": "Parameterized Classes and Abstract Classes | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-2_Constrained_Randomization",
        "title": "I-SV-2: Constrained Randomization",
        "topics": [
          {
            "description": "Guide SystemVerilog's random stimulus with constraints, distributions, and inline tweaks to uncover corner-case bugs fast.",
            "slug": "index",
            "title": "I-SV-2: Constrained Randomization",
          },
          {
            "description": "Express conditional and iterative rules with implication and foreach constructs.",
            "slug": "advanced-constraints",
            "title": "Advanced Constraints: implication and iteration | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Control dependencies and defaults using constraint blocks, soft values, and solve-before ordering.",
            "slug": "constraint-blocks",
            "title": "Constraint Blocks, soft, and solve...before | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Hook solver callbacks with pre_randomize and post_randomize to prepare and finalize objects.",
            "slug": "controlling-randomization",
            "title": "Controlling Randomization: pre_randomize and post_randomize | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-3_Functional_Coverage",
        "title": "I-SV-3: Functional Coverage",
        "topics": [
          {
            "description": "Model verification intent with covergroups, coverpoints, and crosses to prove you've exercised every critical scenario.",
            "slug": "index",
            "title": "I-SV-3: Functional Coverage",
          },
          {
            "description": "Learn how covergroup options influence when and how data is sampled.",
            "slug": "coverage-options",
            "title": "Coverage Options and Sampling | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "Synchronize parallel processes with SystemVerilog events.",
            "slug": "events",
            "title": "Events | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Tie functional coverage points back to verification plan items.",
            "slug": "linking-coverage",
            "title": "Linking Coverage to the V-Plan | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "Use mailboxes for thread-safe communication between processes.",
            "slug": "mailboxes",
            "title": "Mailboxes | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Control access to shared resources using semaphore keys.",
            "slug": "semaphores",
            "title": "Semaphores | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-4_Assertions_SVA",
        "title": "I-SV-4: SystemVerilog Assertions (SVA)",
        "topics": [
          {
            "description": "Specify temporal intent with SystemVerilog Assertions so your verification environment automatically checks protocol rules.",
            "slug": "index",
            "title": "I-SV-4: SystemVerilog Assertions (SVA)",
          },
          {
            "description": "Compare procedural checks with temporal properties through hands-on examples.",
            "slug": "immediate-vs-concurrent",
            "title": "Immediate vs. Concurrent Assertions | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Capture and reuse values within sequences to create robust properties.",
            "slug": "local-variables",
            "title": "Local Variables in Sequences | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Coordinate assertions across clock domains and mask reset behavior with disable iff.",
            "slug": "multi-clocking",
            "title": "Multi-Clocking and disable-iff | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-UVM-1_UVM_Intro",
        "title": "I-UVM-1: UVM Introduction: Objects, Components, and Factory",
        "topics": [
          {
            "description": "Understand how UVM objects, components, and the factory stitch together so your testbench stays configurable.",
            "slug": "index",
            "title": "I-UVM-1: UVM Introduction: Objects, Components, and Factory",
          },
        ],
      },
      {
        "slug": "I-UVM-2_Building_TB",
        "title": "I-UVM-2: Building a UVM Testbench: Components & Hierarchy",
        "topics": [
          {
            "description": "Assemble a layered UVM environment—agents, drivers, sequencers, monitors, and scoreboards—and know how data flows between them.",
            "slug": "index",
            "title": "I-UVM-2: Building a UVM Testbench: Components & Hierarchy",
          },
          {
            "description": "Centralized UVM message control and how to override it with a custom report handler.",
            "slug": "uvm-report-server",
            "title": "UVM Report Server and Verbosity | The UVM Universe - Core Concepts",
          },
          {
            "description": "The singleton that orchestrates UVM phases and launches tests.",
            "slug": "uvm-root",
            "title": "uvm_root and Test Execution | The UVM Universe - Core Concepts",
          },
        ],
      },
      {
        "slug": "I-UVM-3_Sequences",
        "title": "I-UVM-3: Basic UVM Sequences and Stimulus Generation",
        "topics": [
          {
            "description": "Author reusable UVM sequences, understand the sequencer ↔ driver handshake, and stitch stimulus into layered scenarios.",
            "slug": "index",
            "title": "I-UVM-3: Basic UVM Sequences and Stimulus Generation",
          },
          {
            "description": "Use the UVM configuration database to pass settings down the hierarchy without tight coupling.",
            "slug": "uvm-config-db",
            "title": "uvm_config_db: set and get | The UVM Universe - Core Concepts",
          },
          {
            "description": "Resolve configuration conflicts using the underlying resource database and precedence rules.",
            "slug": "uvm-resource-db",
            "title": "uvm_resource_db and Precedence | The UVM Universe - Core Concepts",
          },
        ],
      },
      {
        "slug": "I-UVM-4_Factory_and_Overrides",
        "title": "I-UVM-4: UVM Factory and Overrides",
        "topics": [
          {
            "description": "Swap component implementations on demand with UVM factory overrides and keep your testbench wiring untouched.",
            "slug": "index",
            "title": "I-UVM-4: UVM Factory and Overrides",
          },
        ],
      },
      {
        "slug": "I-UVM-5_Phasing_and_Synchronization",
        "title": "I-UVM-5: UVM Phasing and Synchronization",
        "topics": [
          {
            "description": "Orchestrate build, run, and cleanup with UVM phases and objections so every component stays in lockstep.",
            "slug": "index",
            "title": "I-UVM-5: UVM Phasing and Synchronization",
          },
          {
            "description": "Separate components into custom phase domains and redirect execution with phase jumping.",
            "slug": "domains-phase-jumping",
            "title": "Domains and Phase Jumping | The UVM Universe - Core Concepts",
          },
          {
            "description": "Coordinate activity using lightweight events and blocking barriers for synchronization.",
            "slug": "uvm-event-barrier",
            "title": "uvm_event and uvm_barrier | The UVM Universe - Core Concepts",
          },
        ],
      },
    ],
    "slug": "T2_Intermediate",
    "tier": "T2",
    "title": "Intermediate",
  },
  {
    "sections": [
      {
        "slug": "A-UVM-1_Advanced_Sequencing",
        "title": "A-UVM-1: Advanced UVM Sequencing",
        "topics": [
          {
            "description": "Coordinate layered stimulus with virtual sequences, arbitration hooks, and reusable sequence libraries across complex UVM testbenches.",
            "slug": "index",
            "title": "A-UVM-1: Advanced UVM Sequencing",
          },
          {
            "description": "Wire sequencers, drivers, monitors, and scoreboards with robust connect_phase patterns and analysis backbones.",
            "slug": "connecting",
            "title": "Connecting the Agent Components | Advanced UVM Sequencing",
          },
          {
            "description": "Structure environments and tests to configure agents, publish sequencer handles, and launch layered stimulus cleanly.",
            "slug": "environment-test-classes",
            "title": "Environment & Test Classes | Advanced UVM Sequencing",
          },
          {
            "description": "Turn asynchronous interrupts into deterministic stimulus by combining monitor events, routing policy, and virtual sequences.",
            "slug": "interrupt-handling",
            "title": "Interrupt Handling and Layered Stimulus | Advanced UVM Sequencing",
          },
          {
            "description": "Design atomic, scenario, and virtual layers of sequences while using p_sequencer to orchestrate cross-agent stimulus.",
            "slug": "layered-sequences",
            "title": "Layered Sequences and p_sequencer | Advanced UVM Sequencing",
          },
          {
            "description": "Understand how UVM sequencers choose the next sequence, how to apply lock/grab, and how to customize arbitration for complex stimulus coordination.",
            "slug": "sequence-arbitration",
            "title": "Sequence Arbitration and Priority | Advanced UVM Sequencing",
          },
          {
            "description": "Package reusable stimulus into sequence libraries, weight them, and know when to grab/ungrab for critical sections.",
            "slug": "sequence-libraries",
            "title": "Sequence Libraries & Arbitration Control | Advanced UVM Sequencing",
          },
          {
            "description": "Dissect the blocking protocol between UVM sequencers and drivers, from arbitration to item_done(), and learn how to instrument and debug the flow.",
            "slug": "sequencer-driver-handshake",
            "title": "The Sequencer-Driver Handshake | Advanced UVM Sequencing",
          },
          {
            "description": "Instrument monitors to reconstruct transactions, publish them reliably, and feed subscribers and scoreboards.",
            "slug": "uvm-monitor",
            "title": "uvm_monitor & Analysis Fabric | Advanced UVM Sequencing",
          },
          {
            "description": "Design scoreboards that compare expected vs. observed traffic, manage response queues, and surface mismatches clearly.",
            "slug": "uvm-scoreboard",
            "title": "UVM Scoreboard Patterns | Advanced UVM Sequencing",
          },
          {
            "description": "Engineer rich transaction objects with constraints, deep copy behaviour, and response tracking so every layer of the testbench stays in sync.",
            "slug": "uvm-sequence-item",
            "title": "uvm_sequence_item Mastery | Advanced UVM Sequencing",
          },
          {
            "description": "Leverage uvm_subscriber to capture analysis traffic for coverage, scoreboards, and telemetry without bloating monitors.",
            "slug": "uvm-subscriber",
            "title": "uvm_subscriber in Practice | Advanced UVM Sequencing",
          },
          {
            "description": "Coordinating stimulus across multiple agents.",
            "slug": "uvm-virtual-sequencer",
            "title": "UVM Virtual Sequencer",
          },
          {
            "description": "Learn how to use virtual sequences and sequencers to coordinate and synchronize stimulus across multiple agents in a UVM testbench.",
            "slug": "virtual-sequences",
            "title": "Virtual Sequences and Sequencers",
          },
        ],
      },
      {
        "slug": "A-UVM-2_The_UVM_Factory_In-Depth",
        "title": "A-UVM-2: The UVM Factory In-Depth",
        "topics": [
          {
            "description": "Target overrides precisely, debug factory configuration, and architect reusable agents with advanced UVM factory techniques.",
            "slug": "index",
            "title": "A-UVM-2: The UVM Factory In-Depth",
          },
          {
            "description": "Instrument your testbench with automated heartbeat monitors so overrides or callbacks can recover from stimulus hangs fast.",
            "slug": "heartbeats",
            "title": "Heartbeats & Hang Detection | Advanced UVM Factory",
          },
          {
            "description": "Combine callbacks with factory overrides so you can instrument VIP, inject errors, and audit behaviour without touching source modules.",
            "slug": "uvm-callbacks",
            "title": "UVM Callbacks & Factory Overrides | Advanced UVM Sequencing",
          },
        ],
      },
      {
        "slug": "A-UVM-3_Advanced_UVM_Techniques",
        "title": "A-UVM-3: Advanced UVM Techniques & Strategy",
        "topics": [
          {
            "description": "Orchestrate register models, virtual sequences, callbacks, and functional coverage to harden complex UVM environments.",
            "slug": "index",
            "title": "A-UVM-3: Advanced UVM Techniques & Strategy",
          },
        ],
      },
      {
        "slug": "A-UVM-4_The_UVM_Register_Abstraction_Layer_RAL",
        "title": "A-UVM-4: The UVM Register Abstraction Layer (RAL)",
        "topics": [
          {
            "description": "Model DUT registers once, drive them through any bus, and balance frontdoor/backdoor access for realistic yet fast verification.",
            "slug": "index",
            "title": "A-UVM-4: The UVM Register Abstraction Layer (RAL)",
          },
          {
            "description": "Leverage UVM’s prebuilt register sequences—reset, bit-bash, mem tests—and learn how to extend or constrain them safely.",
            "slug": "built-in-ral-sequences",
            "title": "Built-in RAL Sequences & Utilities | Advanced UVM RAL",
          },
          {
            "description": "Choose the right prediction strategy so your RAL mirror tracks DUT state without redundant bus traffic.",
            "slug": "explicit-vs-implicit",
            "title": "Explicit vs. Implicit Prediction | Advanced UVM RAL",
          },
          {
            "description": "Blend frontdoor realism with backdoor speed—learn when to poke directly and when to march through the bus for accurate checking.",
            "slug": "frontdoor-vs-backdoor",
            "title": "Frontdoor vs. Backdoor Access | Advanced UVM RAL",
          },
        ],
      },
    ],
    "slug": "T3_Advanced",
    "tier": "T3",
    "title": "Advanced",
  },
  {
    "sections": [
      {
        "slug": "E-CUST-1_UVM_Methodology_Customization",
        "title": "E-CUST-1: UVM Methodology Customization",
        "topics": [
          {
            "description": "Design project-wide extensions to UVM—custom bases, phases, and governance—to keep large teams aligned without forking the methodology.",
            "slug": "index",
            "title": "E-CUST-1: UVM Methodology Customization",
          },
        ],
      },
      {
        "slug": "E-DBG-1_Advanced_UVM_Debug_Methodologies",
        "title": "E-DBG-1: Advanced UVM Debug Methodologies",
        "topics": [
          {
            "description": "Instrument your UVM environment with traceability, telemetry, and heuristics so complex failures become explainable fast.",
            "slug": "index",
            "title": "E-DBG-1: Advanced UVM Debug Methodologies",
          },
          {
            "description": "Tried-and-true methods for diagnosing tricky failures.",
            "slug": "effective-debug",
            "title": "Effective Debug Techniques in UVM | The Professional Verification Craft",
          },
          {
            "description": "Use the debugging simulator to rehearse objection tracing, heartbeat analysis, and item_done triage on realistic UVM hangs.",
            "slug": "hang-lab",
            "title": "Hang Lab: Practising UVM Deadlock Recovery",
          },
          {
            "description": "Patterns for building maintainable verification components.",
            "slug": "reusable-vip",
            "title": "Reusable Verification IP (VIP) Architecture | The Professional Verification Craft",
          },
        ],
      },
      {
        "slug": "E-INT-1_Integrating_UVM_with_Formal_Verification",
        "title": "E-INT-1: Integrating UVM with Formal Verification",
        "topics": [
          {
            "description": "Bridge simulation and proof: share assertions, align coverage, and orchestrate flows where UVM and formal reinforce each other.",
            "slug": "index",
            "title": "E-INT-1: Integrating UVM with Formal Verification",
          },
          {
            "description": "C interoperability for performance and modeling flexibility.",
            "slug": "dpi",
            "title": "Direct Programming Interface (DPI) | The Professional Verification Craft",
          },
          {
            "description": "Conceptual overview of portable stimulus methodology.",
            "slug": "pss",
            "title": "Introduction to Portable Stimulus (PSS) | The Professional Verification Craft",
          },
        ],
      },
      {
        "slug": "E-PERF-1_UVM_Performance",
        "title": "E-PERF-1: UVM Performance",
        "topics": [
          {
            "description": "Profile, architect, and operationalize UVM environments so regressions stay fast without sacrificing fidelity.",
            "slug": "index",
            "title": "E-PERF-1: UVM Performance",
          },
        ],
      },
      {
        "slug": "E-SOC-1_SoC-Level_Verification_Strategies",
        "title": "E-SOC-1: SoC-Level Verification Strategies",
        "topics": [
          {
            "description": "Scale block-level infrastructure to SoC: plan reuse, configure virtual platforms, and coordinate cross-team stimulus.",
            "slug": "index",
            "title": "E-SOC-1: SoC-Level Verification Strategies",
          },
          {
            "description": "Using coverage results to measure verification completeness.",
            "slug": "coverage-closure",
            "title": "Coverage Closure and Metrics | The Professional Verification Craft",
          },
          {
            "description": "Building stable regressions and quickly diagnosing failures.",
            "slug": "regression-triage",
            "title": "Regression and Triage Strategies | The Professional Verification Craft",
          },
        ],
      },
    ],
    "slug": "T4_Expert",
    "tier": "T4",
    "title": "Expert",
  },
]
`;

exports[`curriculum generator > generates expected curriculum data 1`] = `
[
  {
    "sections": [
      {
        "slug": "F1_Why_Verification",
        "title": "F1: Why Verification?",
        "topics": [
          {
            "description": "Experience the stakes of verification through interactive stories, graphs, and your first bug hunt.",
            "slug": "index",
            "title": "F1: Why Verification?",
          },
        ],
      },
      {
        "slug": "F2A_Core_Data_Types",
        "title": "F2A: Core Data Types",
        "topics": [
          {
            "description": "Understand the SystemVerilog value system, vectors, and user-defined types with IEEE 1800-2023 grounding.",
            "slug": "index",
            "title": "F2A: Core Data Types",
          },
        ],
      },
      {
        "slug": "F2B_Dynamic_Structures",
        "title": "F2B: Dynamic Data Structures",
        "topics": [
          {
            "description": "Manipulate dynamic arrays, queues, and associative arrays with an IEEE 1800-2023 guided workflow.",
            "slug": "index",
            "title": "F2B: Dynamic Data Structures",
          },
        ],
      },
      {
        "slug": "F2C_Procedural_Code",
        "title": "F2C: Procedural Code and Flow Control",
        "topics": [
          {
            "description": "Author deterministic \`initial\`/\`always\` blocks, choose the right assignment style, and master control flow.",
            "slug": "index",
            "title": "F2C: Procedural Code and Flow Control",
          },
        ],
      },
      {
        "slug": "F2D_Reusable_and_Parallel",
        "title": "F2D: Reusable Code and Parallelism",
        "topics": [
          {
            "description": "Factor stimulus into tasks/functions and coordinate parallel threads with fork-join semantics.",
            "slug": "index",
            "title": "F2D: Reusable Code and Parallelism",
          },
        ],
      },
      {
        "slug": "F3_Procedural_Constructs",
        "title": "F3: Procedural Constructs",
        "topics": [
          {
            "description": "Master the procedural heart of SystemVerilog—initial/always/final blocks, flow control, and assignment semantics that drive every testbench.",
            "slug": "index",
            "title": "F3: Procedural Constructs",
          },
          {
            "description": "Guide decisions with if, case, and loop constructs to steer simulation flow.",
            "slug": "flow-control",
            "title": "Procedural Flow Control | SystemVerilog Language Foundations",
          },
          {
            "description": "Launch parallel threads and synchronize them with join variants.",
            "slug": "fork-join",
            "title": "Fork-Join and Process Control | SystemVerilog Language Foundations",
          },
          {
            "description": "Compare callable blocks with and without timing to structure reusable code.",
            "slug": "tasks-functions",
            "title": "Tasks and Functions: Scoping and Lifetimes | SystemVerilog Language Foundations",
          },
        ],
      },
      {
        "slug": "F4_RTL_and_Testbench_Constructs",
        "title": "F4: RTL and Testbench Constructs",
        "topics": [
          {
            "description": "Wire up designs and verification harnesses with modules, interfaces, packages, and clocking blocks that keep signal intent crystal clear.",
            "slug": "index",
            "title": "F4: RTL and Testbench Constructs",
          },
          {
            "description": "Learn how to use SystemVerilog interfaces and modports to simplify connections and create reusable verification components.",
            "slug": "interfaces",
            "title": "F4: Interfaces and Modports",
          },
          {
            "description": "Group shared declarations into reusable namespaces and manage visibility.",
            "slug": "packages",
            "title": "Packages and Compilation Scopes | SystemVerilog Language Foundations",
          },
          {
            "description": "Understand how program and clocking blocks help create race-free testbenches by separating the testbench from the DUT and defining clear timing for signal interaction.",
            "slug": "program-clocking",
            "title": "F4: Program and Clocking Blocks",
          },
        ],
      },
    ],
    "slug": "T1_Foundational",
    "tier": "T1",
    "title": "Foundational",
  },
  {
    "sections": [
      {
        "slug": "I-SV-1_OOP",
        "title": "I-SV-1: Object-Oriented Programming for Verification",
        "topics": [
          {
            "description": "Build reusable, polymorphic verification components with SystemVerilog classes, inheritance, and virtual methods.",
            "slug": "index",
            "title": "I-SV-1: Object-Oriented Programming for Verification",
          },
          {
            "description": "How to create objects with new and reference parent and current class members using this and super.",
            "slug": "constructors",
            "title": "Constructors, 'this', and 'super' | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Use generics and abstract classes to build reusable components while avoiding common pitfalls.",
            "slug": "parameterized-classes",
            "title": "Parameterized Classes and Abstract Classes | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-2_Constrained_Randomization",
        "title": "I-SV-2: Constrained Randomization",
        "topics": [
          {
            "description": "Guide SystemVerilog's random stimulus with constraints, distributions, and inline tweaks to uncover corner-case bugs fast.",
            "slug": "index",
            "title": "I-SV-2: Constrained Randomization",
          },
          {
            "description": "Express conditional and iterative rules with implication and foreach constructs.",
            "slug": "advanced-constraints",
            "title": "Advanced Constraints: implication and iteration | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Control dependencies and defaults using constraint blocks, soft values, and solve-before ordering.",
            "slug": "constraint-blocks",
            "title": "Constraint Blocks, soft, and solve...before | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Hook solver callbacks with pre_randomize and post_randomize to prepare and finalize objects.",
            "slug": "controlling-randomization",
            "title": "Controlling Randomization: pre_randomize and post_randomize | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-3_Functional_Coverage",
        "title": "I-SV-3: Functional Coverage",
        "topics": [
          {
            "description": "Model verification intent with covergroups, coverpoints, and crosses to prove you've exercised every critical scenario.",
            "slug": "index",
            "title": "I-SV-3: Functional Coverage",
          },
          {
            "description": "Learn how covergroup options influence when and how data is sampled.",
            "slug": "coverage-options",
            "title": "Coverage Options and Sampling | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "Synchronize parallel processes with SystemVerilog events.",
            "slug": "events",
            "title": "Events | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Tie functional coverage points back to verification plan items.",
            "slug": "linking-coverage",
            "title": "Linking Coverage to the V-Plan | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "Use mailboxes for thread-safe communication between processes.",
            "slug": "mailboxes",
            "title": "Mailboxes | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Control access to shared resources using semaphore keys.",
            "slug": "semaphores",
            "title": "Semaphores | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-4_Assertions_SVA",
        "title": "I-SV-4: SystemVerilog Assertions (SVA)",
        "topics": [
          {
            "description": "Specify temporal intent with SystemVerilog Assertions so your verification environment automatically checks protocol rules.",
            "slug": "index",
            "title": "I-SV-4: SystemVerilog Assertions (SVA)",
          },
          {
            "description": "Compare procedural checks with temporal properties through hands-on examples.",
            "slug": "immediate-vs-concurrent",
            "title": "Immediate vs. Concurrent Assertions | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Capture and reuse values within sequences to create robust properties.",
            "slug": "local-variables",
            "title": "Local Variables in Sequences | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Coordinate assertions across clock domains and mask reset behavior with disable iff.",
            "slug": "multi-clocking",
            "title": "Multi-Clocking and disable-iff | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-UVM-1_UVM_Intro",
        "title": "I-UVM-1: UVM Introduction: Objects, Components, and Factory",
        "topics": [
          {
            "description": "Understand how UVM objects, components, and the factory stitch together so your testbench stays configurable.",
            "slug": "index",
            "title": "I-UVM-1: UVM Introduction: Objects, Components, and Factory",
          },
        ],
      },
      {
        "slug": "I-UVM-2_Building_TB",
        "title": "I-UVM-2: Building a UVM Testbench: Components & Hierarchy",
        "topics": [
          {
            "description": "Assemble a layered UVM environment—agents, drivers, sequencers, monitors, and scoreboards—and know how data flows between them.",
            "slug": "index",
            "title": "I-UVM-2: Building a UVM Testbench: Components & Hierarchy",
          },
          {
            "description": "Centralized UVM message control and how to override it with a custom report handler.",
            "slug": "uvm-report-server",
            "title": "UVM Report Server and Verbosity | The UVM Universe - Core Concepts",
          },
          {
            "description": "The singleton that orchestrates UVM phases and launches tests.",
            "slug": "uvm-root",
            "title": "uvm_root and Test Execution | The UVM Universe - Core Concepts",
          },
        ],
      },
      {
        "slug": "I-UVM-3_Sequences",
        "title": "I-UVM-3: Basic UVM Sequences and Stimulus Generation",
        "topics": [
          {
            "description": "Author reusable UVM sequences, understand the sequencer ↔ driver handshake, and stitch stimulus into layered scenarios.",
            "slug": "index",
            "title": "I-UVM-3: Basic UVM Sequences and Stimulus Generation",
          },
          {
            "description": "Use the UVM configuration database to pass settings down the hierarchy without tight coupling.",
            "slug": "uvm-config-db",
            "title": "uvm_config_db: set and get | The UVM Universe - Core Concepts",
          },
          {
            "description": "Resolve configuration conflicts using the underlying resource database and precedence rules.",
            "slug": "uvm-resource-db",
            "title": "uvm_resource_db and Precedence | The UVM Universe - Core Concepts",
          },
        ],
      },
      {
        "slug": "I-UVM-4_Factory_and_Overrides",
        "title": "I-UVM-4: UVM Factory and Overrides",
        "topics": [
          {
            "description": "Swap component implementations on demand with UVM factory overrides and keep your testbench wiring untouched.",
            "slug": "index",
            "title": "I-UVM-4: UVM Factory and Overrides",
          },
        ],
      },
      {
        "slug": "I-UVM-5_Phasing_and_Synchronization",
        "title": "I-UVM-5: UVM Phasing and Synchronization",
        "topics": [
          {
            "description": "Orchestrate build, run, and cleanup with UVM phases and objections so every component stays in lockstep.",
            "slug": "index",
            "title": "I-UVM-5: UVM Phasing and Synchronization",
          },
          {
            "description": "Separate components into custom phase domains and redirect execution with phase jumping.",
            "slug": "domains-phase-jumping",
            "title": "Domains and Phase Jumping | The UVM Universe - Core Concepts",
          },
          {
            "description": "Coordinate activity using lightweight events and blocking barriers for synchronization.",
            "slug": "uvm-event-barrier",
            "title": "uvm_event and uvm_barrier | The UVM Universe - Core Concepts",
          },
        ],
      },
    ],
    "slug": "T2_Intermediate",
    "tier": "T2",
    "title": "Intermediate",
  },
  {
    "sections": [
      {
        "slug": "A-UVM-1_Advanced_Sequencing",
        "title": "A-UVM-1: Advanced UVM Sequencing",
        "topics": [
          {
            "description": "Coordinate layered stimulus with virtual sequences, arbitration hooks, and reusable sequence libraries across complex UVM testbenches.",
            "slug": "index",
            "title": "A-UVM-1: Advanced UVM Sequencing",
          },
          {
            "description": "Wire sequencers, drivers, monitors, and scoreboards with robust connect_phase patterns and analysis backbones.",
            "slug": "connecting",
            "title": "Connecting the Agent Components | Advanced UVM Sequencing",
          },
          {
            "description": "Structure environments and tests to configure agents, publish sequencer handles, and launch layered stimulus cleanly.",
            "slug": "environment-test-classes",
            "title": "Environment & Test Classes | Advanced UVM Sequencing",
          },
          {
            "description": "Turn asynchronous interrupts into deterministic stimulus by combining monitor events, routing policy, and virtual sequences.",
            "slug": "interrupt-handling",
            "title": "Interrupt Handling and Layered Stimulus | Advanced UVM Sequencing",
          },
          {
            "description": "Design atomic, scenario, and virtual layers of sequences while using p_sequencer to orchestrate cross-agent stimulus.",
            "slug": "layered-sequences",
            "title": "Layered Sequences and p_sequencer | Advanced UVM Sequencing",
          },
          {
            "description": "Understand how UVM sequencers choose the next sequence, how to apply lock/grab, and how to customize arbitration for complex stimulus coordination.",
            "slug": "sequence-arbitration",
            "title": "Sequence Arbitration and Priority | Advanced UVM Sequencing",
          },
          {
            "description": "Package reusable stimulus into sequence libraries, weight them, and know when to grab/ungrab for critical sections.",
            "slug": "sequence-libraries",
            "title": "Sequence Libraries & Arbitration Control | Advanced UVM Sequencing",
          },
          {
            "description": "Dissect the blocking protocol between UVM sequencers and drivers, from arbitration to item_done(), and learn how to instrument and debug the flow.",
            "slug": "sequencer-driver-handshake",
            "title": "The Sequencer-Driver Handshake | Advanced UVM Sequencing",
          },
          {
            "description": "Instrument monitors to reconstruct transactions, publish them reliably, and feed subscribers and scoreboards.",
            "slug": "uvm-monitor",
            "title": "uvm_monitor & Analysis Fabric | Advanced UVM Sequencing",
          },
          {
            "description": "Design scoreboards that compare expected vs. observed traffic, manage response queues, and surface mismatches clearly.",
            "slug": "uvm-scoreboard",
            "title": "UVM Scoreboard Patterns | Advanced UVM Sequencing",
          },
          {
            "description": "Engineer rich transaction objects with constraints, deep copy behaviour, and response tracking so every layer of the testbench stays in sync.",
            "slug": "uvm-sequence-item",
            "title": "uvm_sequence_item Mastery | Advanced UVM Sequencing",
          },
          {
            "description": "Leverage uvm_subscriber to capture analysis traffic for coverage, scoreboards, and telemetry without bloating monitors.",
            "slug": "uvm-subscriber",
            "title": "uvm_subscriber in Practice | Advanced UVM Sequencing",
          },
          {
            "description": "Coordinating stimulus across multiple agents.",
            "slug": "uvm-virtual-sequencer",
            "title": "UVM Virtual Sequencer",
          },
          {
            "description": "Learn how to use virtual sequences and sequencers to coordinate and synchronize stimulus across multiple agents in a UVM testbench.",
            "slug": "virtual-sequences",
            "title": "Virtual Sequences and Sequencers",
          },
        ],
      },
      {
        "slug": "A-UVM-2_The_UVM_Factory_In-Depth",
        "title": "A-UVM-2: The UVM Factory In-Depth",
        "topics": [
          {
            "description": "Target overrides precisely, debug factory configuration, and architect reusable agents with advanced UVM factory techniques.",
            "slug": "index",
            "title": "A-UVM-2: The UVM Factory In-Depth",
          },
          {
            "description": "Instrument your testbench with automated heartbeat monitors so overrides or callbacks can recover from stimulus hangs fast.",
            "slug": "heartbeats",
            "title": "Heartbeats & Hang Detection | Advanced UVM Factory",
          },
          {
            "description": "Combine callbacks with factory overrides so you can instrument VIP, inject errors, and audit behaviour without touching source modules.",
            "slug": "uvm-callbacks",
            "title": "UVM Callbacks & Factory Overrides | Advanced UVM Sequencing",
          },
        ],
      },
      {
        "slug": "A-UVM-3_Advanced_UVM_Techniques",
        "title": "A-UVM-3: Advanced UVM Techniques & Strategy",
        "topics": [
          {
            "description": "Orchestrate register models, virtual sequences, callbacks, and functional coverage to harden complex UVM environments.",
            "slug": "index",
            "title": "A-UVM-3: Advanced UVM Techniques & Strategy",
          },
        ],
      },
      {
        "slug": "A-UVM-4_The_UVM_Register_Abstraction_Layer_RAL",
        "title": "A-UVM-4: The UVM Register Abstraction Layer (RAL)",
        "topics": [
          {
            "description": "Model DUT registers once, drive them through any bus, and balance frontdoor/backdoor access for realistic yet fast verification.",
            "slug": "index",
            "title": "A-UVM-4: The UVM Register Abstraction Layer (RAL)",
          },
          {
            "description": "Leverage UVM’s prebuilt register sequences—reset, bit-bash, mem tests—and learn how to extend or constrain them safely.",
            "slug": "built-in-ral-sequences",
            "title": "Built-in RAL Sequences & Utilities | Advanced UVM RAL",
          },
          {
            "description": "Choose the right prediction strategy so your RAL mirror tracks DUT state without redundant bus traffic.",
            "slug": "explicit-vs-implicit",
            "title": "Explicit vs. Implicit Prediction | Advanced UVM RAL",
          },
          {
            "description": "Blend frontdoor realism with backdoor speed—learn when to poke directly and when to march through the bus for accurate checking.",
            "slug": "frontdoor-vs-backdoor",
            "title": "Frontdoor vs. Backdoor Access | Advanced UVM RAL",
          },
        ],
      },
    ],
    "slug": "T3_Advanced",
    "tier": "T3",
    "title": "Advanced",
  },
  {
    "sections": [
      {
        "slug": "E-CUST-1_UVM_Methodology_Customization",
        "title": "E-CUST-1: UVM Methodology Customization",
        "topics": [
          {
            "description": "Design project-wide extensions to UVM—custom bases, phases, and governance—to keep large teams aligned without forking the methodology.",
            "slug": "index",
            "title": "E-CUST-1: UVM Methodology Customization",
          },
        ],
      },
      {
        "slug": "E-DBG-1_Advanced_UVM_Debug_Methodologies",
        "title": "E-DBG-1: Advanced UVM Debug Methodologies",
        "topics": [
          {
            "description": "Instrument your UVM environment with traceability, telemetry, and heuristics so complex failures become explainable fast.",
            "slug": "index",
            "title": "E-DBG-1: Advanced UVM Debug Methodologies",
          },
          {
            "description": "Tried-and-true methods for diagnosing tricky failures.",
            "slug": "effective-debug",
            "title": "Effective Debug Techniques in UVM | The Professional Verification Craft",
          },
          {
            "description": "Use the debugging simulator to rehearse objection tracing, heartbeat analysis, and item_done triage on realistic UVM hangs.",
            "slug": "hang-lab",
            "title": "Hang Lab: Practising UVM Deadlock Recovery",
          },
          {
            "description": "Patterns for building maintainable verification components.",
            "slug": "reusable-vip",
            "title": "Reusable Verification IP (VIP) Architecture | The Professional Verification Craft",
          },
        ],
      },
      {
        "slug": "E-INT-1_Integrating_UVM_with_Formal_Verification",
        "title": "E-INT-1: Integrating UVM with Formal Verification",
        "topics": [
          {
            "description": "Bridge simulation and proof: share assertions, align coverage, and orchestrate flows where UVM and formal reinforce each other.",
            "slug": "index",
            "title": "E-INT-1: Integrating UVM with Formal Verification",
          },
          {
            "description": "C interoperability for performance and modeling flexibility.",
            "slug": "dpi",
            "title": "Direct Programming Interface (DPI) | The Professional Verification Craft",
          },
          {
            "description": "Conceptual overview of portable stimulus methodology.",
            "slug": "pss",
            "title": "Introduction to Portable Stimulus (PSS) | The Professional Verification Craft",
          },
        ],
      },
      {
        "slug": "E-PERF-1_UVM_Performance",
        "title": "E-PERF-1: UVM Performance",
        "topics": [
          {
            "description": "Profile, architect, and operationalize UVM environments so regressions stay fast without sacrificing fidelity.",
            "slug": "index",
            "title": "E-PERF-1: UVM Performance",
          },
        ],
      },
      {
        "slug": "E-SOC-1_SoC-Level_Verification_Strategies",
        "title": "E-SOC-1: SoC-Level Verification Strategies",
        "topics": [
          {
            "description": "Scale block-level infrastructure to SoC: plan reuse, configure virtual platforms, and coordinate cross-team stimulus.",
            "slug": "index",
            "title": "E-SOC-1: SoC-Level Verification Strategies",
          },
          {
            "description": "Using coverage results to measure verification completeness.",
            "slug": "coverage-closure",
            "title": "Coverage Closure and Metrics | The Professional Verification Craft",
          },
          {
            "description": "Building stable regressions and quickly diagnosing failures.",
            "slug": "regression-triage",
            "title": "Regression and Triage Strategies | The Professional Verification Craft",
          },
        ],
      },
    ],
    "slug": "T4_Expert",
    "tier": "T4",
    "title": "Expert",
  },
]
`;
