// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`curriculum generator > generated file matches snapshot 1`] = `
[
  {
    "sections": [
      {
        "slug": "F1A_The_Cost_of_Bugs",
        "title": "F1A: The Cost of Bugs",
        "topics": [
          {
            "description": "Understand the economic and reputational stakes of verification in the semiconductor industry.",
            "slug": "index",
            "title": "F1A: The Cost of Bugs",
          },
        ],
      },
      {
        "slug": "F1B_The_Verification_Mindset",
        "title": "F1B: The Verification Mindset",
        "topics": [
          {
            "description": "Adopt the destructive testing philosophy and explore the methodologies used to break designs.",
            "slug": "index",
            "title": "F1B: The Verification Mindset",
          },
        ],
      },
      {
        "slug": "F1C_Why_SystemVerilog",
        "title": "F1C: Why SystemVerilog?",
        "topics": [
          {
            "description": "Discover why SystemVerilog replaced Verilog as the industry standard for verification.",
            "slug": "index",
            "title": "F1C: Why SystemVerilog?",
          },
        ],
      },
      {
        "slug": "F2A_Core_Data_Types",
        "title": "F2A: Core Data Types",
        "topics": [
          {
            "description": "Dive deep into SystemVerilog nets, variables, and value systems with interactive explorers grounded in IEEE 1800-2023.",
            "slug": "index",
            "title": "F2A: Core Data Types",
          },
        ],
      },
      {
        "slug": "F2B_Dynamic_Structures",
        "title": "F2B: Dynamic Data Structures",
        "topics": [
          {
            "description": "Manipulate dynamic arrays, queues, and associative arrays with an IEEE 1800-2023 guided workflow.",
            "slug": "index",
            "title": "F2B: Dynamic Data Structures",
          },
        ],
      },
      {
        "slug": "F2C_Procedural_Code_and_Flow_Control",
        "title": "F3A: Procedural Blocks and Flow Control",
        "topics": [
          {
            "description": "Master the procedural heart of SystemVerilog—initial/always/final blocks, flow control, and assignment semantics that drive every testbench.",
            "slug": "index",
            "title": "F3A: Procedural Blocks and Flow Control",
          },
          {
            "description": "Guide decisions with if, case, and loop constructs to steer simulation flow.",
            "slug": "flow-control",
            "title": "Procedural Flow Control",
          },
        ],
      },
      {
        "slug": "F2D_Reusable_Code_and_Parallelism",
        "title": "F3D: System Tasks and File I/O",
        "topics": [
          {
            "description": "Interact with the simulator kernel: print messages, cast types, generate random numbers, and read/write files.",
            "slug": "index",
            "title": "F3D: System Tasks and File I/O",
          },
          {
            "description": "Coordinate parallel threads safely using Semaphores and Mailboxes.",
            "slug": "ipc",
            "title": "F3D: Interprocess Communication",
          },
        ],
      },
      {
        "slug": "F4A_Modules_and_Packages",
        "title": "F4A: Structuring Designs with Modules and Packages",
        "topics": [
          {
            "description": "Wire up designs and verification harnesses with modules and packages that keep signal intent crystal clear.",
            "slug": "index",
            "title": "F4A: Structuring Designs with Modules and Packages",
          },
        ],
      },
      {
        "slug": "F4B_Interfaces_and_Modports",
        "title": "F4B: Bundling Signals with Interfaces and Modports",
        "topics": [
          {
            "description": "Learn how to use SystemVerilog interfaces and modports to simplify connections and create reusable verification components.",
            "slug": "index",
            "title": "F4B: Bundling Signals with Interfaces and Modports",
          },
        ],
      },
      {
        "slug": "F4C_Clocking_Blocks",
        "title": "F4C: Synchronizing with Clocking and Program Blocks",
        "topics": [
          {
            "description": "Understand how clocking blocks help create race-free testbenches by defining clear timing for signal interaction.",
            "slug": "index",
            "title": "F4C: Synchronizing with Clocking and Program Blocks",
          },
        ],
      },
    ],
    "slug": "T1_Foundational",
    "tier": "T1",
    "title": "Foundational",
  },
  {
    "sections": [
      {
        "slug": "I-SV-1_OOP",
        "title": "I-SV-1: Object-Oriented Programming for Verification",
        "topics": [
          {
            "description": "Build reusable, polymorphic verification components with SystemVerilog classes, inheritance, and virtual methods.",
            "slug": "index",
            "title": "I-SV-1: Object-Oriented Programming for Verification",
          },
          {
            "description": "How to create objects with new and reference parent and current class members using this and super.",
            "slug": "constructors",
            "title": "Constructors, 'this', and 'super' | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Understand shallow vs. deep copy in SystemVerilog, and how to implement robust copy() and clone() methods.",
            "slug": "copying-and-cloning",
            "title": "Copying and Cloning Objects | SystemVerilog OOP",
          },
          {
            "description": "Use generics and abstract classes to build reusable components while avoiding common pitfalls.",
            "slug": "parameterized-classes",
            "title": "Parameterized Classes and Abstract Classes | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Learn how virtual method resolution works, upcasting vs. downcasting, and how to safely use $cast.",
            "slug": "polymorphism-pitfalls",
            "title": "Polymorphism Pitfalls and Type Casting | SystemVerilog OOP",
          },
        ],
      },
      {
        "slug": "I-SV-2A_Constrained_Randomization_Fundamentals",
        "title": "I-SV-2A: Constrained Randomization Fundamentals",
        "topics": [
          {
            "description": "Guide SystemVerilog's random stimulus with constraints, distributions, and inline tweaks to uncover corner-case bugs fast.",
            "slug": "index",
            "title": "I-SV-2A: Constrained Randomization Fundamentals",
          },
          {
            "description": "Control dependencies and defaults using constraint blocks, soft values, and solve-before ordering.",
            "slug": "constraint-blocks",
            "title": "Constraint Blocks, soft, and solve...before | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-2B_Advanced_Constrained_Randomization",
        "title": "I-SV-2B: Advanced Constrained Randomization",
        "topics": [
          {
            "description": "Master advanced solver techniques, multi-level constraints, implication, and solver debug triage.",
            "slug": "index",
            "title": "I-SV-2B: Advanced Constrained Randomization",
          },
          {
            "description": "Express conditional and iterative rules with implication and foreach constructs.",
            "slug": "advanced-constraints",
            "title": "Advanced Constraints: implication and iteration | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Hook solver callbacks with pre_randomize and post_randomize to prepare and finalize objects.",
            "slug": "controlling-randomization",
            "title": "Controlling Randomization: pre_randomize and post_randomize | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Learn how to approach constraint solver failures, debug conflicting constraints, and use built-in simulator tools.",
            "slug": "solver-debug",
            "title": "Solver Debug and Failure Triage | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-3A_Functional_Coverage_Fundamentals",
        "title": "I-SV-3A: Functional Coverage Fundamentals",
        "topics": [
          {
            "description": "Model verification intent with covergroups, coverpoints, and crosses to prove you've exercised every critical scenario.",
            "slug": "index",
            "title": "I-SV-3A: Functional Coverage Fundamentals",
          },
          {
            "description": "Learn how covergroup options influence when and how data is sampled.",
            "slug": "coverage-options",
            "title": "Coverage Options and Sampling | Advanced UVM Techniques & Strategy",
          },
        ],
      },
      {
        "slug": "I-SV-3B_Advanced_Functional_Coverage",
        "title": "I-SV-3B: Advanced Functional Coverage",
        "topics": [
          {
            "description": "Master coverage to V-Plan linkage, API querying, and coverage-driven constrained random loops.",
            "slug": "index",
            "title": "I-SV-3B: Advanced Functional Coverage",
          },
          {
            "description": "Tie functional coverage points back to verification plan items.",
            "slug": "linking-coverage",
            "title": "Linking Coverage to the V-Plan | Advanced UVM Techniques & Strategy",
          },
        ],
      },
      {
        "slug": "I-SV-4A_Assertions_SVA_Fundamentals",
        "title": "I-SV-4A: Assertions (SVA) Fundamentals",
        "topics": [
          {
            "description": "Specify temporal intent with SystemVerilog Assertions so your verification environment automatically checks protocol rules.",
            "slug": "index",
            "title": "I-SV-4A: Assertions (SVA) Fundamentals",
          },
          {
            "description": "Compare procedural checks with temporal properties through hands-on examples.",
            "slug": "immediate-vs-concurrent",
            "title": "Immediate vs. Concurrent Assertions | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-4B_Advanced_SVA",
        "title": "I-SV-4B: Advanced SVA",
        "topics": [
          {
            "description": "Master multi-clock assertions, local variables, and binding checkers into your design.",
            "slug": "index",
            "title": "I-SV-4B: Advanced SVA",
          },
          {
            "description": "Capture and reuse values within sequences to create robust properties.",
            "slug": "local-variables",
            "title": "Local Variables in Sequences | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Coordinate assertions across clock domains and mask reset behavior with disable iff.",
            "slug": "multi-clocking",
            "title": "Multi-Clocking and disable-iff | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-5_Synchronization_and_IPC",
        "title": "I-SV-5: Synchronization and IPC",
        "topics": [
          {
            "description": "Master SystemVerilog's built-in inter-process communication primitives: events, mailboxes, and semaphores.",
            "slug": "index",
            "title": "I-SV-5: Synchronization and IPC",
          },
          {
            "description": "Synchronize parallel processes with SystemVerilog events.",
            "slug": "events",
            "title": "Events | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Use mailboxes for thread-safe communication between processes.",
            "slug": "mailboxes",
            "title": "Mailboxes | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Control access to shared resources using semaphore keys.",
            "slug": "semaphores",
            "title": "Semaphores | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-UVM-1A_Components",
        "title": "I-UVM-1A: UVM Objects and Components",
        "topics": [
          {
            "description": "Understand the fundamental split between data containers and structural elements in UVM testbenches.",
            "slug": "index",
            "title": "I-UVM-1A: UVM Objects and Components",
          },
        ],
      },
      {
        "slug": "I-UVM-1B_The_UVM_Factory",
        "title": "I-UVM-1B: The UVM Factory",
        "topics": [
          {
            "description": "Swap component and object implementations dynamically using UVM's factory registry without touching your testbench wiring.",
            "slug": "index",
            "title": "I-UVM-1B: The UVM Factory",
          },
        ],
      },
      {
        "slug": "I-UVM-1C_UVM_Phasing",
        "title": "I-UVM-1C: UVM Phasing and Synchronization",
        "topics": [
          {
            "description": "Orchestrate build, run, and cleanup with UVM phases, domains, objections, and synchronization primitives so every component stays in lockstep.",
            "slug": "index",
            "title": "I-UVM-1C: UVM Phasing and Synchronization",
          },
        ],
      },
      {
        "slug": "I-UVM-2A_Component_Roles",
        "title": "I-UVM-2A: Component Roles and the Testbench Hierarchy",
        "topics": [
          {
            "description": "Understand the blueprint of a UVM environment—tests orchestrate, environments aggregate, agents wrap interface logic, monitors observe, and scoreboards verify.",
            "slug": "index",
            "title": "I-UVM-2A: Component Roles and the Testbench Hierarchy",
          },
        ],
      },
      {
        "slug": "I-UVM-2B_TLM_Connections",
        "title": "I-UVM-2B: TLM Connections and Analysis Fabric",
        "topics": [
          {
            "description": "Wire sequencers, drivers, monitors, and scoreboards using UVM's Transaction-Level Modeling (TLM) components.",
            "slug": "index",
            "title": "I-UVM-2B: TLM Connections and Analysis Fabric",
          },
        ],
      },
      {
        "slug": "I-UVM-2C_Configuration_and_Resources",
        "title": "I-UVM-2C: Configuration and Resources",
        "topics": [
          {
            "description": "Use uvm_config_db and uvm_resource_db to pass settings and virtual interface handles down the hierarchy without tight coupling.",
            "slug": "index",
            "title": "I-UVM-2C: Configuration and Resources",
          },
        ],
      },
      {
        "slug": "I-UVM-3A_Fundamentals",
        "title": "I-UVM-3A: Basic UVM Sequences and Items",
        "topics": [
          {
            "description": "Model robust transaction items and author reusable UVM sequences that drive the sequencer ↔ driver handshake.",
            "slug": "index",
            "title": "I-UVM-3A: Basic UVM Sequences and Items",
          },
        ],
      },
      {
        "slug": "I-UVM-3B_Advanced_Sequencing_and_Layering",
        "title": "I-UVM-3B: Advanced Sequencing and Layering",
        "topics": [
          {
            "description": "Master virtual sequences, arbitration, layering, and driver-sequencer synchronization patterns.",
            "slug": "index",
            "title": "I-UVM-3B: Advanced Sequencing and Layering",
          },
          {
            "description": "Turn asynchronous interrupts into deterministic stimulus by combining monitor events, routing policy, and virtual sequences.",
            "slug": "interrupt-handling",
            "title": "Interrupt Handling and Layered Stimulus | Advanced UVM Sequencing",
          },
          {
            "description": "Design atomic, scenario, and virtual layers of sequences while using p_sequencer to orchestrate cross-agent stimulus.",
            "slug": "layered-sequences",
            "title": "Layered Sequences and p_sequencer | Advanced UVM Sequencing",
          },
          {
            "description": "Understand how UVM sequencers choose the next sequence, how to apply lock/grab, and how to customize arbitration for complex stimulus coordination.",
            "slug": "sequence-arbitration",
            "title": "Sequence Arbitration and Priority | Advanced UVM Sequencing",
          },
          {
            "description": "Package reusable stimulus into sequence libraries, weight them, and know when to grab/ungrab for critical sections.",
            "slug": "sequence-libraries",
            "title": "Sequence Libraries & Arbitration Control | Advanced UVM Sequencing",
          },
          {
            "description": "Dissect the blocking protocol between UVM sequencers and drivers, from arbitration to item_done(), and learn how to instrument and debug the flow.",
            "slug": "sequencer-driver-handshake",
            "title": "The Sequencer-Driver Handshake | Advanced UVM Sequencing",
          },
          {
            "description": "Coordinating stimulus across multiple agents.",
            "slug": "uvm-virtual-sequencer",
            "title": "UVM Virtual Sequencer",
          },
          {
            "description": "Learn how to use virtual sequences and sequencers to coordinate and synchronize stimulus across multiple agents in a UVM testbench.",
            "slug": "virtual-sequences",
            "title": "Virtual Sequences and Sequencers",
          },
        ],
      },
    ],
    "slug": "T2_Intermediate",
    "tier": "T2",
    "title": "Intermediate",
  },
  {
    "sections": [
      {
        "slug": "A-UVM-4A_RAL_Fundamentals",
        "title": "A-UVM-4A: RAL Fundamentals",
        "topics": [
          {
            "description": "Model DUT registers once and decouple stimulus from physical bus protocols.",
            "slug": "index",
            "title": "A-UVM-4A: RAL Fundamentals",
          },
        ],
      },
      {
        "slug": "A-UVM-4B_Advanced_RAL_Techniques",
        "title": "A-UVM-4B: Advanced RAL Techniques",
        "topics": [
          {
            "description": "Master adapters, predictors, and sophisticated debug workflows for robust UVM register environments.",
            "slug": "index",
            "title": "A-UVM-4B: Advanced RAL Techniques",
          },
          {
            "description": "Leverage UVM’s prebuilt register sequences—reset, bit-bash, mem tests—and learn how to extend or constrain them safely.",
            "slug": "built-in-ral-sequences",
            "title": "Built-in RAL Sequences & Utilities | Advanced UVM RAL",
          },
          {
            "description": "Choose the right prediction strategy so your RAL mirror tracks DUT state without redundant bus traffic.",
            "slug": "explicit-vs-implicit",
            "title": "Explicit vs. Implicit Prediction | Advanced UVM RAL",
          },
          {
            "description": "Blend frontdoor realism with backdoor speed—learn when to poke directly and when to march through the bus for accurate checking.",
            "slug": "frontdoor-vs-backdoor",
            "title": "Frontdoor vs. Backdoor Access | Advanced UVM RAL",
          },
        ],
      },
      {
        "slug": "A-UVM-5_UVM_Callbacks",
        "title": "A-UVM-5: UVM Callbacks",
        "topics": [
          {
            "description": "Inject optional behavior into components without exploding your class hierarchy or hacking the base code.",
            "slug": "index",
            "title": "A-UVM-5: UVM Callbacks",
          },
        ],
      },
    ],
    "slug": "T3_Advanced",
    "tier": "T3",
    "title": "Advanced",
  },
  {
    "sections": [
      {
        "slug": "E-CUST-1_UVM_Methodology_Customization",
        "title": "E-CUST-1: UVM Methodology Customization",
        "topics": [
          {
            "description": "Design project-wide extensions to UVM—custom bases, phases, and governance—to keep large teams aligned without forking the methodology.",
            "slug": "index",
            "title": "E-CUST-1: UVM Methodology Customization",
          },
        ],
      },
      {
        "slug": "E-DBG-1_Advanced_UVM_Debug_Methodologies",
        "title": "E-DBG-1: Advanced UVM Debug Methodologies",
        "topics": [
          {
            "description": "Instrument your UVM environment with traceability, telemetry, and heuristics so complex failures become explainable fast.",
            "slug": "index",
            "title": "E-DBG-1: Advanced UVM Debug Methodologies",
          },
          {
            "description": "Tried-and-true methods for diagnosing tricky failures.",
            "slug": "effective-debug",
            "title": "Effective Debug Techniques in UVM | The Professional Verification Craft",
          },
          {
            "description": "Use the debugging simulator to rehearse objection tracing, heartbeat analysis, and item_done triage on realistic UVM hangs.",
            "slug": "hang-lab",
            "title": "Hang Lab: Practising UVM Deadlock Recovery",
          },
          {
            "description": "Patterns for building maintainable verification components.",
            "slug": "reusable-vip",
            "title": "Reusable Verification IP (VIP) Architecture | The Professional Verification Craft",
          },
        ],
      },
      {
        "slug": "E-INT-1_Integrating_UVM_with_Formal_Verification",
        "title": "E-INT-1: Integrating UVM with Formal Verification",
        "topics": [
          {
            "description": "Bridge simulation and proof: share assertions, align coverage, and orchestrate flows where UVM and formal reinforce each other.",
            "slug": "index",
            "title": "E-INT-1: Integrating UVM with Formal Verification",
          },
          {
            "description": "C interoperability for performance and modeling flexibility.",
            "slug": "dpi",
            "title": "Direct Programming Interface (DPI) | The Professional Verification Craft",
          },
          {
            "description": "Conceptual overview of portable stimulus methodology.",
            "slug": "pss",
            "title": "Introduction to Portable Stimulus (PSS) | The Professional Verification Craft",
          },
        ],
      },
      {
        "slug": "E-PERF-1_UVM_Performance",
        "title": "E-PERF-1: UVM Performance",
        "topics": [
          {
            "description": "Profile, architect, and operationalize UVM environments so regressions stay fast without sacrificing fidelity.",
            "slug": "index",
            "title": "E-PERF-1: UVM Performance",
          },
        ],
      },
      {
        "slug": "E-SOC-1_SoC-Level_Verification_Strategies",
        "title": "E-SOC-1: SoC-Level Verification Strategies",
        "topics": [
          {
            "description": "Scale block-level infrastructure to SoC: plan reuse, configure virtual platforms, and coordinate cross-team stimulus.",
            "slug": "index",
            "title": "E-SOC-1: SoC-Level Verification Strategies",
          },
          {
            "description": "Using coverage results to measure verification completeness.",
            "slug": "coverage-closure",
            "title": "Coverage Closure and Metrics | The Professional Verification Craft",
          },
          {
            "description": "Building stable regressions and quickly diagnosing failures.",
            "slug": "regression-triage",
            "title": "Regression and Triage Strategies | The Professional Verification Craft",
          },
        ],
      },
    ],
    "slug": "T4_Expert",
    "tier": "T4",
    "title": "Expert",
  },
]
`;

exports[`curriculum generator > generates expected curriculum data 1`] = `
[
  {
    "sections": [
      {
        "slug": "F1A_The_Cost_of_Bugs",
        "title": "F1A: The Cost of Bugs",
        "topics": [
          {
            "description": "Understand the economic and reputational stakes of verification in the semiconductor industry.",
            "slug": "index",
            "title": "F1A: The Cost of Bugs",
          },
        ],
      },
      {
        "slug": "F1B_The_Verification_Mindset",
        "title": "F1B: The Verification Mindset",
        "topics": [
          {
            "description": "Adopt the destructive testing philosophy and explore the methodologies used to break designs.",
            "slug": "index",
            "title": "F1B: The Verification Mindset",
          },
        ],
      },
      {
        "slug": "F1C_Why_SystemVerilog",
        "title": "F1C: Why SystemVerilog?",
        "topics": [
          {
            "description": "Discover why SystemVerilog replaced Verilog as the industry standard for verification.",
            "slug": "index",
            "title": "F1C: Why SystemVerilog?",
          },
        ],
      },
      {
        "slug": "F2A_Core_Data_Types",
        "title": "F2A: Core Data Types",
        "topics": [
          {
            "description": "Dive deep into SystemVerilog nets, variables, and value systems with interactive explorers grounded in IEEE 1800-2023.",
            "slug": "index",
            "title": "F2A: Core Data Types",
          },
        ],
      },
      {
        "slug": "F2B_Dynamic_Structures",
        "title": "F2B: Dynamic Data Structures",
        "topics": [
          {
            "description": "Manipulate dynamic arrays, queues, and associative arrays with an IEEE 1800-2023 guided workflow.",
            "slug": "index",
            "title": "F2B: Dynamic Data Structures",
          },
        ],
      },
      {
        "slug": "F2C_Procedural_Code_and_Flow_Control",
        "title": "F3A: Procedural Blocks and Flow Control",
        "topics": [
          {
            "description": "Master the procedural heart of SystemVerilog—initial/always/final blocks, flow control, and assignment semantics that drive every testbench.",
            "slug": "index",
            "title": "F3A: Procedural Blocks and Flow Control",
          },
          {
            "description": "Guide decisions with if, case, and loop constructs to steer simulation flow.",
            "slug": "flow-control",
            "title": "Procedural Flow Control",
          },
        ],
      },
      {
        "slug": "F2D_Reusable_Code_and_Parallelism",
        "title": "F3D: System Tasks and File I/O",
        "topics": [
          {
            "description": "Interact with the simulator kernel: print messages, cast types, generate random numbers, and read/write files.",
            "slug": "index",
            "title": "F3D: System Tasks and File I/O",
          },
          {
            "description": "Coordinate parallel threads safely using Semaphores and Mailboxes.",
            "slug": "ipc",
            "title": "F3D: Interprocess Communication",
          },
        ],
      },
      {
        "slug": "F4A_Modules_and_Packages",
        "title": "F4A: Structuring Designs with Modules and Packages",
        "topics": [
          {
            "description": "Wire up designs and verification harnesses with modules and packages that keep signal intent crystal clear.",
            "slug": "index",
            "title": "F4A: Structuring Designs with Modules and Packages",
          },
        ],
      },
      {
        "slug": "F4B_Interfaces_and_Modports",
        "title": "F4B: Bundling Signals with Interfaces and Modports",
        "topics": [
          {
            "description": "Learn how to use SystemVerilog interfaces and modports to simplify connections and create reusable verification components.",
            "slug": "index",
            "title": "F4B: Bundling Signals with Interfaces and Modports",
          },
        ],
      },
      {
        "slug": "F4C_Clocking_Blocks",
        "title": "F4C: Synchronizing with Clocking and Program Blocks",
        "topics": [
          {
            "description": "Understand how clocking blocks help create race-free testbenches by defining clear timing for signal interaction.",
            "slug": "index",
            "title": "F4C: Synchronizing with Clocking and Program Blocks",
          },
        ],
      },
    ],
    "slug": "T1_Foundational",
    "tier": "T1",
    "title": "Foundational",
  },
  {
    "sections": [
      {
        "slug": "I-SV-1_OOP",
        "title": "I-SV-1: Object-Oriented Programming for Verification",
        "topics": [
          {
            "description": "Build reusable, polymorphic verification components with SystemVerilog classes, inheritance, and virtual methods.",
            "slug": "index",
            "title": "I-SV-1: Object-Oriented Programming for Verification",
          },
          {
            "description": "How to create objects with new and reference parent and current class members using this and super.",
            "slug": "constructors",
            "title": "Constructors, 'this', and 'super' | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Understand shallow vs. deep copy in SystemVerilog, and how to implement robust copy() and clone() methods.",
            "slug": "copying-and-cloning",
            "title": "Copying and Cloning Objects | SystemVerilog OOP",
          },
          {
            "description": "Use generics and abstract classes to build reusable components while avoiding common pitfalls.",
            "slug": "parameterized-classes",
            "title": "Parameterized Classes and Abstract Classes | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Learn how virtual method resolution works, upcasting vs. downcasting, and how to safely use $cast.",
            "slug": "polymorphism-pitfalls",
            "title": "Polymorphism Pitfalls and Type Casting | SystemVerilog OOP",
          },
        ],
      },
      {
        "slug": "I-SV-2A_Constrained_Randomization_Fundamentals",
        "title": "I-SV-2A: Constrained Randomization Fundamentals",
        "topics": [
          {
            "description": "Guide SystemVerilog's random stimulus with constraints, distributions, and inline tweaks to uncover corner-case bugs fast.",
            "slug": "index",
            "title": "I-SV-2A: Constrained Randomization Fundamentals",
          },
          {
            "description": "Control dependencies and defaults using constraint blocks, soft values, and solve-before ordering.",
            "slug": "constraint-blocks",
            "title": "Constraint Blocks, soft, and solve...before | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-2B_Advanced_Constrained_Randomization",
        "title": "I-SV-2B: Advanced Constrained Randomization",
        "topics": [
          {
            "description": "Master advanced solver techniques, multi-level constraints, implication, and solver debug triage.",
            "slug": "index",
            "title": "I-SV-2B: Advanced Constrained Randomization",
          },
          {
            "description": "Express conditional and iterative rules with implication and foreach constructs.",
            "slug": "advanced-constraints",
            "title": "Advanced Constraints: implication and iteration | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Hook solver callbacks with pre_randomize and post_randomize to prepare and finalize objects.",
            "slug": "controlling-randomization",
            "title": "Controlling Randomization: pre_randomize and post_randomize | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Learn how to approach constraint solver failures, debug conflicting constraints, and use built-in simulator tools.",
            "slug": "solver-debug",
            "title": "Solver Debug and Failure Triage | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-3A_Functional_Coverage_Fundamentals",
        "title": "I-SV-3A: Functional Coverage Fundamentals",
        "topics": [
          {
            "description": "Model verification intent with covergroups, coverpoints, and crosses to prove you've exercised every critical scenario.",
            "slug": "index",
            "title": "I-SV-3A: Functional Coverage Fundamentals",
          },
          {
            "description": "Learn how covergroup options influence when and how data is sampled.",
            "slug": "coverage-options",
            "title": "Coverage Options and Sampling | Advanced UVM Techniques & Strategy",
          },
        ],
      },
      {
        "slug": "I-SV-3B_Advanced_Functional_Coverage",
        "title": "I-SV-3B: Advanced Functional Coverage",
        "topics": [
          {
            "description": "Master coverage to V-Plan linkage, API querying, and coverage-driven constrained random loops.",
            "slug": "index",
            "title": "I-SV-3B: Advanced Functional Coverage",
          },
          {
            "description": "Tie functional coverage points back to verification plan items.",
            "slug": "linking-coverage",
            "title": "Linking Coverage to the V-Plan | Advanced UVM Techniques & Strategy",
          },
        ],
      },
      {
        "slug": "I-SV-4A_Assertions_SVA_Fundamentals",
        "title": "I-SV-4A: Assertions (SVA) Fundamentals",
        "topics": [
          {
            "description": "Specify temporal intent with SystemVerilog Assertions so your verification environment automatically checks protocol rules.",
            "slug": "index",
            "title": "I-SV-4A: Assertions (SVA) Fundamentals",
          },
          {
            "description": "Compare procedural checks with temporal properties through hands-on examples.",
            "slug": "immediate-vs-concurrent",
            "title": "Immediate vs. Concurrent Assertions | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-4B_Advanced_SVA",
        "title": "I-SV-4B: Advanced SVA",
        "topics": [
          {
            "description": "Master multi-clock assertions, local variables, and binding checkers into your design.",
            "slug": "index",
            "title": "I-SV-4B: Advanced SVA",
          },
          {
            "description": "Capture and reuse values within sequences to create robust properties.",
            "slug": "local-variables",
            "title": "Local Variables in Sequences | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Coordinate assertions across clock domains and mask reset behavior with disable iff.",
            "slug": "multi-clocking",
            "title": "Multi-Clocking and disable-iff | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-5_Synchronization_and_IPC",
        "title": "I-SV-5: Synchronization and IPC",
        "topics": [
          {
            "description": "Master SystemVerilog's built-in inter-process communication primitives: events, mailboxes, and semaphores.",
            "slug": "index",
            "title": "I-SV-5: Synchronization and IPC",
          },
          {
            "description": "Synchronize parallel processes with SystemVerilog events.",
            "slug": "events",
            "title": "Events | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Use mailboxes for thread-safe communication between processes.",
            "slug": "mailboxes",
            "title": "Mailboxes | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Control access to shared resources using semaphore keys.",
            "slug": "semaphores",
            "title": "Semaphores | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-UVM-1A_Components",
        "title": "I-UVM-1A: UVM Objects and Components",
        "topics": [
          {
            "description": "Understand the fundamental split between data containers and structural elements in UVM testbenches.",
            "slug": "index",
            "title": "I-UVM-1A: UVM Objects and Components",
          },
        ],
      },
      {
        "slug": "I-UVM-1B_The_UVM_Factory",
        "title": "I-UVM-1B: The UVM Factory",
        "topics": [
          {
            "description": "Swap component and object implementations dynamically using UVM's factory registry without touching your testbench wiring.",
            "slug": "index",
            "title": "I-UVM-1B: The UVM Factory",
          },
        ],
      },
      {
        "slug": "I-UVM-1C_UVM_Phasing",
        "title": "I-UVM-1C: UVM Phasing and Synchronization",
        "topics": [
          {
            "description": "Orchestrate build, run, and cleanup with UVM phases, domains, objections, and synchronization primitives so every component stays in lockstep.",
            "slug": "index",
            "title": "I-UVM-1C: UVM Phasing and Synchronization",
          },
        ],
      },
      {
        "slug": "I-UVM-2A_Component_Roles",
        "title": "I-UVM-2A: Component Roles and the Testbench Hierarchy",
        "topics": [
          {
            "description": "Understand the blueprint of a UVM environment—tests orchestrate, environments aggregate, agents wrap interface logic, monitors observe, and scoreboards verify.",
            "slug": "index",
            "title": "I-UVM-2A: Component Roles and the Testbench Hierarchy",
          },
        ],
      },
      {
        "slug": "I-UVM-2B_TLM_Connections",
        "title": "I-UVM-2B: TLM Connections and Analysis Fabric",
        "topics": [
          {
            "description": "Wire sequencers, drivers, monitors, and scoreboards using UVM's Transaction-Level Modeling (TLM) components.",
            "slug": "index",
            "title": "I-UVM-2B: TLM Connections and Analysis Fabric",
          },
        ],
      },
      {
        "slug": "I-UVM-2C_Configuration_and_Resources",
        "title": "I-UVM-2C: Configuration and Resources",
        "topics": [
          {
            "description": "Use uvm_config_db and uvm_resource_db to pass settings and virtual interface handles down the hierarchy without tight coupling.",
            "slug": "index",
            "title": "I-UVM-2C: Configuration and Resources",
          },
        ],
      },
      {
        "slug": "I-UVM-3A_Fundamentals",
        "title": "I-UVM-3A: Basic UVM Sequences and Items",
        "topics": [
          {
            "description": "Model robust transaction items and author reusable UVM sequences that drive the sequencer ↔ driver handshake.",
            "slug": "index",
            "title": "I-UVM-3A: Basic UVM Sequences and Items",
          },
        ],
      },
      {
        "slug": "I-UVM-3B_Advanced_Sequencing_and_Layering",
        "title": "I-UVM-3B: Advanced Sequencing and Layering",
        "topics": [
          {
            "description": "Master virtual sequences, arbitration, layering, and driver-sequencer synchronization patterns.",
            "slug": "index",
            "title": "I-UVM-3B: Advanced Sequencing and Layering",
          },
          {
            "description": "Turn asynchronous interrupts into deterministic stimulus by combining monitor events, routing policy, and virtual sequences.",
            "slug": "interrupt-handling",
            "title": "Interrupt Handling and Layered Stimulus | Advanced UVM Sequencing",
          },
          {
            "description": "Design atomic, scenario, and virtual layers of sequences while using p_sequencer to orchestrate cross-agent stimulus.",
            "slug": "layered-sequences",
            "title": "Layered Sequences and p_sequencer | Advanced UVM Sequencing",
          },
          {
            "description": "Understand how UVM sequencers choose the next sequence, how to apply lock/grab, and how to customize arbitration for complex stimulus coordination.",
            "slug": "sequence-arbitration",
            "title": "Sequence Arbitration and Priority | Advanced UVM Sequencing",
          },
          {
            "description": "Package reusable stimulus into sequence libraries, weight them, and know when to grab/ungrab for critical sections.",
            "slug": "sequence-libraries",
            "title": "Sequence Libraries & Arbitration Control | Advanced UVM Sequencing",
          },
          {
            "description": "Dissect the blocking protocol between UVM sequencers and drivers, from arbitration to item_done(), and learn how to instrument and debug the flow.",
            "slug": "sequencer-driver-handshake",
            "title": "The Sequencer-Driver Handshake | Advanced UVM Sequencing",
          },
          {
            "description": "Coordinating stimulus across multiple agents.",
            "slug": "uvm-virtual-sequencer",
            "title": "UVM Virtual Sequencer",
          },
          {
            "description": "Learn how to use virtual sequences and sequencers to coordinate and synchronize stimulus across multiple agents in a UVM testbench.",
            "slug": "virtual-sequences",
            "title": "Virtual Sequences and Sequencers",
          },
        ],
      },
    ],
    "slug": "T2_Intermediate",
    "tier": "T2",
    "title": "Intermediate",
  },
  {
    "sections": [
      {
        "slug": "A-UVM-4A_RAL_Fundamentals",
        "title": "A-UVM-4A: RAL Fundamentals",
        "topics": [
          {
            "description": "Model DUT registers once and decouple stimulus from physical bus protocols.",
            "slug": "index",
            "title": "A-UVM-4A: RAL Fundamentals",
          },
        ],
      },
      {
        "slug": "A-UVM-4B_Advanced_RAL_Techniques",
        "title": "A-UVM-4B: Advanced RAL Techniques",
        "topics": [
          {
            "description": "Master adapters, predictors, and sophisticated debug workflows for robust UVM register environments.",
            "slug": "index",
            "title": "A-UVM-4B: Advanced RAL Techniques",
          },
          {
            "description": "Leverage UVM’s prebuilt register sequences—reset, bit-bash, mem tests—and learn how to extend or constrain them safely.",
            "slug": "built-in-ral-sequences",
            "title": "Built-in RAL Sequences & Utilities | Advanced UVM RAL",
          },
          {
            "description": "Choose the right prediction strategy so your RAL mirror tracks DUT state without redundant bus traffic.",
            "slug": "explicit-vs-implicit",
            "title": "Explicit vs. Implicit Prediction | Advanced UVM RAL",
          },
          {
            "description": "Blend frontdoor realism with backdoor speed—learn when to poke directly and when to march through the bus for accurate checking.",
            "slug": "frontdoor-vs-backdoor",
            "title": "Frontdoor vs. Backdoor Access | Advanced UVM RAL",
          },
        ],
      },
      {
        "slug": "A-UVM-5_UVM_Callbacks",
        "title": "A-UVM-5: UVM Callbacks",
        "topics": [
          {
            "description": "Inject optional behavior into components without exploding your class hierarchy or hacking the base code.",
            "slug": "index",
            "title": "A-UVM-5: UVM Callbacks",
          },
        ],
      },
    ],
    "slug": "T3_Advanced",
    "tier": "T3",
    "title": "Advanced",
  },
  {
    "sections": [
      {
        "slug": "E-CUST-1_UVM_Methodology_Customization",
        "title": "E-CUST-1: UVM Methodology Customization",
        "topics": [
          {
            "description": "Design project-wide extensions to UVM—custom bases, phases, and governance—to keep large teams aligned without forking the methodology.",
            "slug": "index",
            "title": "E-CUST-1: UVM Methodology Customization",
          },
        ],
      },
      {
        "slug": "E-DBG-1_Advanced_UVM_Debug_Methodologies",
        "title": "E-DBG-1: Advanced UVM Debug Methodologies",
        "topics": [
          {
            "description": "Instrument your UVM environment with traceability, telemetry, and heuristics so complex failures become explainable fast.",
            "slug": "index",
            "title": "E-DBG-1: Advanced UVM Debug Methodologies",
          },
          {
            "description": "Tried-and-true methods for diagnosing tricky failures.",
            "slug": "effective-debug",
            "title": "Effective Debug Techniques in UVM | The Professional Verification Craft",
          },
          {
            "description": "Use the debugging simulator to rehearse objection tracing, heartbeat analysis, and item_done triage on realistic UVM hangs.",
            "slug": "hang-lab",
            "title": "Hang Lab: Practising UVM Deadlock Recovery",
          },
          {
            "description": "Patterns for building maintainable verification components.",
            "slug": "reusable-vip",
            "title": "Reusable Verification IP (VIP) Architecture | The Professional Verification Craft",
          },
        ],
      },
      {
        "slug": "E-INT-1_Integrating_UVM_with_Formal_Verification",
        "title": "E-INT-1: Integrating UVM with Formal Verification",
        "topics": [
          {
            "description": "Bridge simulation and proof: share assertions, align coverage, and orchestrate flows where UVM and formal reinforce each other.",
            "slug": "index",
            "title": "E-INT-1: Integrating UVM with Formal Verification",
          },
          {
            "description": "C interoperability for performance and modeling flexibility.",
            "slug": "dpi",
            "title": "Direct Programming Interface (DPI) | The Professional Verification Craft",
          },
          {
            "description": "Conceptual overview of portable stimulus methodology.",
            "slug": "pss",
            "title": "Introduction to Portable Stimulus (PSS) | The Professional Verification Craft",
          },
        ],
      },
      {
        "slug": "E-PERF-1_UVM_Performance",
        "title": "E-PERF-1: UVM Performance",
        "topics": [
          {
            "description": "Profile, architect, and operationalize UVM environments so regressions stay fast without sacrificing fidelity.",
            "slug": "index",
            "title": "E-PERF-1: UVM Performance",
          },
        ],
      },
      {
        "slug": "E-SOC-1_SoC-Level_Verification_Strategies",
        "title": "E-SOC-1: SoC-Level Verification Strategies",
        "topics": [
          {
            "description": "Scale block-level infrastructure to SoC: plan reuse, configure virtual platforms, and coordinate cross-team stimulus.",
            "slug": "index",
            "title": "E-SOC-1: SoC-Level Verification Strategies",
          },
          {
            "description": "Using coverage results to measure verification completeness.",
            "slug": "coverage-closure",
            "title": "Coverage Closure and Metrics | The Professional Verification Craft",
          },
          {
            "description": "Building stable regressions and quickly diagnosing failures.",
            "slug": "regression-triage",
            "title": "Regression and Triage Strategies | The Professional Verification Craft",
          },
        ],
      },
    ],
    "slug": "T4_Expert",
    "tier": "T4",
    "title": "Expert",
  },
]
`;
