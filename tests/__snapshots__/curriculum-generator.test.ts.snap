// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`curriculum generator > generated file matches snapshot 1`] = `
[
  {
    "sections": [
      {
        "slug": "F1_Why_Verification",
        "title": "F1: Why Verification?",
        "topics": [
          {
            "description": "An introduction to the world of hardware verification.",
            "slug": "index",
            "title": "F1: Why Verification?",
          },
        ],
      },
      {
        "slug": "F2_Data_Types",
        "title": "F2: SystemVerilog Data Types",
        "topics": [
          {
            "description": "Understand SystemVerilog data types: the crucial difference between 2-state (bit, int) and 4-state (logic, wire, reg) types, and their application in modeling hardware signals and building verification testbenches.",
            "slug": "index",
            "title": "F2: SystemVerilog Data Types",
          },
          {
            "description": "An overview of arrays in SystemVerilog.",
            "slug": "arrays",
            "title": "Arrays: Packed, Unpacked, Dynamic, Queues, Associative | SystemVerilog Language Foundations",
          },
          {
            "description": "How to create user-defined types.",
            "slug": "user-defined",
            "title": "User-Defined Types: structs, unions, enums, typedef | SystemVerilog Language Foundations",
          },
        ],
      },
      {
        "slug": "F2_SystemVerilog_Basics",
        "title": "F2: SystemVerilog Language Basics",
        "topics": [
          {
            "description": "A comprehensive introduction to the fundamental building blocks of the SystemVerilog language.",
            "slug": "index",
            "title": "F2: SystemVerilog Language Basics",
          },
        ],
      },
      {
        "slug": "F2_SystemVerilog_Primer",
        "title": "Module F-2: Digital Logic & HDL Primer",
        "topics": [
          {
            "description": "A crash course in the essential digital logic and HDL concepts for verification.",
            "slug": "index",
            "title": "Module F-2: Digital Logic & HDL Primer",
          },
        ],
      },
      {
        "slug": "F3_Behavioral_RTL_Modeling",
        "title": "F3: Behavioral & RTL Modeling",
        "topics": [
          {
            "description": "A core module that teaches how to describe hardware behavior in SystemVerilog.",
            "slug": "index",
            "title": "F3: Behavioral & RTL Modeling",
          },
        ],
      },
      {
        "slug": "F3_Procedural_Constructs",
        "title": "F3: Procedural Constructs",
        "topics": [
          {
            "description": "Understanding the building blocks of SystemVerilog code.",
            "slug": "index",
            "title": "F3: Procedural Constructs",
          },
          {
            "description": "Guide decisions with if, case, and loop constructs to steer simulation flow.",
            "slug": "flow-control",
            "title": "Procedural Flow Control | SystemVerilog Language Foundations",
          },
          {
            "description": "Launch parallel threads and synchronize them with join variants.",
            "slug": "fork-join",
            "title": "Fork-Join and Process Control | SystemVerilog Language Foundations",
          },
          {
            "description": "Compare callable blocks with and without timing to structure reusable code.",
            "slug": "tasks-functions",
            "title": "Tasks and Functions: Scoping and Lifetimes | SystemVerilog Language Foundations",
          },
        ],
      },
      {
        "slug": "F3_SystemVerilog_Intro",
        "title": "Module F-3: Introduction to the SystemVerilog Language",
        "topics": [
          {
            "description": "An introduction to the basic building blocks of the SystemVerilog language for verification.",
            "slug": "index",
            "title": "Module F-3: Introduction to the SystemVerilog Language",
          },
        ],
      },
      {
        "slug": "F4_RTL_and_Testbench_Constructs",
        "title": "F4: RTL and Testbench Constructs",
        "topics": [
          {
            "description": "Key constructs for design and verification.",
            "slug": "index",
            "title": "F4: RTL and Testbench Constructs",
          },
          {
            "description": "Learn how to use SystemVerilog interfaces and modports to simplify connections and create reusable verification components.",
            "slug": "interfaces",
            "title": "F4: Interfaces and Modports",
          },
          {
            "description": "Group shared declarations into reusable namespaces and manage visibility.",
            "slug": "packages",
            "title": "Packages and Compilation Scopes | SystemVerilog Language Foundations",
          },
          {
            "description": "Understand how program and clocking blocks help create race-free testbenches by separating the testbench from the DUT and defining clear timing for signal interaction.",
            "slug": "program-clocking",
            "title": "F4: Program and Clocking Blocks",
          },
        ],
      },
      {
        "slug": "F4_Verification_Basics_without_UVM",
        "title": "F4: Verification Basics without UVM",
        "topics": [
          {
            "description": "Bridging the gap between basic SystemVerilog and the complex UVM methodology.",
            "slug": "index",
            "title": "F4: Verification Basics without UVM",
          },
        ],
      },
      {
        "slug": "F4_Your_First_Testbench",
        "title": "Module F-4: Your First Testbench",
        "topics": [
          {
            "description": "A guided, hands-on lab to build your first simple, self-checking SystemVerilog testbench.",
            "slug": "index",
            "title": "Module F-4: Your First Testbench",
          },
        ],
      },
      {
        "slug": "F5_Intro_to_OOP_in_SV",
        "title": "F5: Intro to Object-Oriented Programming (OOP) in SV",
        "topics": [
          {
            "description": "The final prerequisite before diving into UVM.",
            "slug": "index",
            "title": "F5: Intro to Object-Oriented Programming (OOP) in SV",
          },
        ],
      },
    ],
    "slug": "T1_Foundational",
    "tier": "T1",
    "title": "Foundational",
  },
  {
    "sections": [
      {
        "slug": "I-SV-1_OOP",
        "title": "I-SV-1: Object-Oriented Programming for Verification",
        "topics": [
          {
            "description": "Understanding OOP as the foundation for modern verification methodologies like UVM.",
            "slug": "index",
            "title": "I-SV-1: Object-Oriented Programming for Verification",
          },
          {
            "description": "How to create objects with new and reference parent and current class members using this and super.",
            "slug": "constructors",
            "title": "Constructors, 'this', and 'super' | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Use generics and abstract classes to build reusable components while avoiding common pitfalls.",
            "slug": "parameterized-classes",
            "title": "Parameterized Classes and Abstract Classes | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-2_Constrained_Randomization",
        "title": "I-SV-2: Constrained Randomization",
        "topics": [
          {
            "description": "Using constrained randomization to intelligently search for bugs.",
            "slug": "index",
            "title": "I-SV-2: Constrained Randomization",
          },
          {
            "description": "Express conditional and iterative rules with implication and foreach constructs.",
            "slug": "advanced-constraints",
            "title": "Advanced Constraints: implication and iteration | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Control dependencies and defaults using constraint blocks, soft values, and solve-before ordering.",
            "slug": "constraint-blocks",
            "title": "Constraint Blocks, soft, and solve...before | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Hook solver callbacks with pre_randomize and post_randomize to prepare and finalize objects.",
            "slug": "controlling-randomization",
            "title": "Controlling Randomization: pre_randomize and post_randomize | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-3_Functional_Coverage",
        "title": "I-SV-3: Functional Coverage",
        "topics": [
          {
            "description": "Answering the question 'Are we done yet?' by modeling and measuring functional coverage.",
            "slug": "index",
            "title": "I-SV-3: Functional Coverage",
          },
          {
            "description": "Learn how covergroup options influence when and how data is sampled.",
            "slug": "coverage-options",
            "title": "Coverage Options and Sampling | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "Synchronize parallel processes with SystemVerilog events.",
            "slug": "events",
            "title": "Events | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Tie functional coverage points back to verification plan items.",
            "slug": "linking-coverage",
            "title": "Linking Coverage to the V-Plan | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "Use mailboxes for thread-safe communication between processes.",
            "slug": "mailboxes",
            "title": "Mailboxes | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Control access to shared resources using semaphore keys.",
            "slug": "semaphores",
            "title": "Semaphores | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-4_Assertions_SVA",
        "title": "I-SV-4: SystemVerilog Assertions (SVA)",
        "topics": [
          {
            "description": "Learn how to use SystemVerilog Assertions (SVA) to specify design behavior over time and create powerful functional checks.",
            "slug": "index",
            "title": "I-SV-4: SystemVerilog Assertions (SVA)",
          },
          {
            "description": "Compare procedural checks with temporal properties through hands-on examples.",
            "slug": "immediate-vs-concurrent",
            "title": "Immediate vs. Concurrent Assertions | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Capture and reuse values within sequences to create robust properties.",
            "slug": "local-variables",
            "title": "Local Variables in Sequences | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Coordinate assertions across clock domains and mask reset behavior with disable iff.",
            "slug": "multi-clocking",
            "title": "Multi-Clocking and disable-iff | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-UVM-1_UVM_Intro",
        "title": "I-UVM-1: UVM Introduction: Objects, Components, and Factory",
        "topics": [
          {
            "description": "Understanding the most fundamental UVM concepts: uvm_object, uvm_component, and the UVM Factory.",
            "slug": "index",
            "title": "I-UVM-1: UVM Introduction: Objects, Components, and Factory",
          },
        ],
      },
      {
        "slug": "I-UVM-2_Building_TB",
        "title": "I-UVM-2: Building a UVM Testbench: Components & Hierarchy",
        "topics": [
          {
            "description": "Assembling a standard UVM testbench and understanding the role of each component.",
            "slug": "index",
            "title": "I-UVM-2: Building a UVM Testbench: Components & Hierarchy",
          },
          {
            "description": "Centralized UVM message control and how to override it with a custom report handler.",
            "slug": "uvm-report-server",
            "title": "UVM Report Server and Verbosity | The UVM Universe - Core Concepts",
          },
          {
            "description": "The singleton that orchestrates UVM phases and launches tests.",
            "slug": "uvm-root",
            "title": "uvm_root and Test Execution | The UVM Universe - Core Concepts",
          },
        ],
      },
      {
        "slug": "I-UVM-3_Sequences",
        "title": "I-UVM-3: Basic UVM Sequences and Stimulus Generation",
        "topics": [
          {
            "description": "Mastering the core of UVM's powerful stimulus generation methodology by writing sequences.",
            "slug": "index",
            "title": "I-UVM-3: Basic UVM Sequences and Stimulus Generation",
          },
          {
            "description": "Use the UVM configuration database to pass settings down the hierarchy without tight coupling.",
            "slug": "uvm-config-db",
            "title": "uvm_config_db: set and get | The UVM Universe - Core Concepts",
          },
          {
            "description": "Resolve configuration conflicts using the underlying resource database and precedence rules.",
            "slug": "uvm-resource-db",
            "title": "uvm_resource_db and Precedence | The UVM Universe - Core Concepts",
          },
        ],
      },
      {
        "slug": "I-UVM-4_Factory_and_Overrides",
        "title": "I-UVM-4: UVM Factory and Overrides",
        "topics": [
          {
            "description": "Swap component implementations on the fly using the UVM factory's type and instance overrides.",
            "slug": "index",
            "title": "I-UVM-4: UVM Factory and Overrides",
          },
        ],
      },
      {
        "slug": "I-UVM-5_Phasing_and_Synchronization",
        "title": "I-UVM-5: UVM Phasing and Synchronization",
        "topics": [
          {
            "description": "Understand the UVM phasing mechanism for synchronizing testbench execution and the core UVM class hierarchy.",
            "slug": "index",
            "title": "I-UVM-5: UVM Phasing and Synchronization",
          },
          {
            "description": "Separate components into custom phase domains and redirect execution with phase jumping.",
            "slug": "domains-phase-jumping",
            "title": "Domains and Phase Jumping | The UVM Universe - Core Concepts",
          },
          {
            "description": "Coordinate activity using lightweight events and blocking barriers for synchronization.",
            "slug": "uvm-event-barrier",
            "title": "uvm_event and uvm_barrier | The UVM Universe - Core Concepts",
          },
        ],
      },
    ],
    "slug": "T2_Intermediate",
    "tier": "T2",
    "title": "Intermediate",
  },
  {
    "sections": [
      {
        "slug": "A-UVM-1_Advanced_Sequencing",
        "title": "A-UVM-1: Advanced UVM Sequencing",
        "topics": [
          {
            "description": "Learn about advanced UVM sequencing techniques, including layered sequences, virtual sequences, and sequence libraries.",
            "slug": "index",
            "title": "A-UVM-1: Advanced UVM Sequencing",
          },
          {
            "description": "...",
            "slug": "connecting",
            "title": "Connecting the Agent Components | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "environment-test-classes",
            "title": "The Environment and Test Classes | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "interrupt-handling",
            "title": "Interrupt Handling and Layered Stimulus | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "...",
            "slug": "layered-sequences",
            "title": "Layered Sequences and p_sequencer | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "sequence-arbitration",
            "title": "Sequence Arbitration and Priority | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "...",
            "slug": "sequence-libraries",
            "title": "Sequence Libraries and grab/ungrab | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "sequencer-driver-handshake",
            "title": "The Sequencer-Driver Handshake | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "uvm-monitor",
            "title": "uvm_monitor and Analysis Ports | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "uvm-scoreboard",
            "title": "The UVM Scoreboard | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "uvm-sequence-item",
            "title": "uvm_sequence_item and uvm_sequence | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "uvm-subscriber",
            "title": "uvm_subscriber | Building a UVM Testbench",
          },
          {
            "description": "Coordinating stimulus across multiple agents.",
            "slug": "uvm-virtual-sequencer",
            "title": "UVM Virtual Sequencer",
          },
          {
            "description": "Learn how to use virtual sequences and sequencers to coordinate and synchronize stimulus across multiple agents in a UVM testbench.",
            "slug": "virtual-sequences",
            "title": "Virtual Sequences and Sequencers",
          },
        ],
      },
      {
        "slug": "A-UVM-2_The_UVM_Factory_In-Depth",
        "title": "A-UVM-2: The UVM Factory In-Depth",
        "topics": [
          {
            "description": "Explore advanced UVM factory features, including instance overrides, string-based overrides, and debugging techniques.",
            "slug": "index",
            "title": "A-UVM-2: The UVM Factory In-Depth",
          },
          {
            "description": "...",
            "slug": "heartbeats",
            "title": "Heartbeats and Testbench Monitoring | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "...",
            "slug": "uvm-callbacks",
            "title": "UVM Callbacks and Facade Classes | Advanced UVM Techniques & Strategy",
          },
        ],
      },
      {
        "slug": "A-UVM-3_Advanced_UVM_Techniques",
        "title": "Advanced UVM Techniques & Strategy | Advanced UVM",
        "topics": [
          {
            "description": "Expert-level concepts like RAL, virtual sequences, callbacks, and coverage integration.",
            "slug": "index",
            "title": "Advanced UVM Techniques & Strategy | Advanced UVM",
          },
        ],
      },
      {
        "slug": "A-UVM-4_The_UVM_Register_Abstraction_Layer_RAL",
        "title": "A-UVM-4: The UVM Register Abstraction Layer (RAL)",
        "topics": [
          {
            "description": "Learn how to use the UVM Register Abstraction Layer (RAL) to model and access DUT registers in a standardized and reusable way.",
            "slug": "index",
            "title": "A-UVM-4: The UVM Register Abstraction Layer (RAL)",
          },
          {
            "description": "...",
            "slug": "built-in-ral-sequences",
            "title": "Built-in RAL Sequences and Adapters | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "...",
            "slug": "explicit-vs-implicit",
            "title": "Explicit vs. Implicit Prediction | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "...",
            "slug": "frontdoor-vs-backdoor",
            "title": "Frontdoor vs. Backdoor Access | Advanced UVM Techniques & Strategy",
          },
        ],
      },
    ],
    "slug": "T3_Advanced",
    "tier": "T3",
    "title": "Advanced",
  },
  {
    "sections": [
      {
        "slug": "E-CUST-1_UVM_Methodology_Customization",
        "title": "E-CUST-1: UVM Methodology Customization",
        "topics": [
          {
            "description": "Learn how to customize the UVM methodology to meet the specific needs of your project.",
            "slug": "index",
            "title": "E-CUST-1: UVM Methodology Customization",
          },
        ],
      },
      {
        "slug": "E-DBG-1_Advanced_UVM_Debug_Methodologies",
        "title": "E-DBG-1: Advanced UVM Debug Methodologies",
        "topics": [
          {
            "description": "Learn advanced techniques for debugging complex UVM environments.",
            "slug": "index",
            "title": "E-DBG-1: Advanced UVM Debug Methodologies",
          },
          {
            "description": "Tried-and-true methods for diagnosing tricky failures.",
            "slug": "effective-debug",
            "title": "Effective Debug Techniques in UVM | The Professional Verification Craft",
          },
          {
            "description": "Patterns for building maintainable verification components.",
            "slug": "reusable-vip",
            "title": "Reusable Verification IP (VIP) Architecture | The Professional Verification Craft",
          },
        ],
      },
      {
        "slug": "E-INT-1_Integrating_UVM_with_Formal_Verification",
        "title": "E-INT-1: Integrating UVM with Formal Verification",
        "topics": [
          {
            "description": "Learn how to combine the power of UVM and formal verification to create a more robust verification environment.",
            "slug": "index",
            "title": "E-INT-1: Integrating UVM with Formal Verification",
          },
          {
            "description": "C interoperability for performance and modeling flexibility.",
            "slug": "dpi",
            "title": "Direct Programming Interface (DPI) | The Professional Verification Craft",
          },
          {
            "description": "Conceptual overview of portable stimulus methodology.",
            "slug": "pss",
            "title": "Introduction to Portable Stimulus (PSS) | The Professional Verification Craft",
          },
        ],
      },
      {
        "slug": "E-PERF-1_UVM_Performance",
        "title": "E-PERF-1: UVM Performance",
        "topics": [
          {
            "description": "Learn how to identify and address performance bottlenecks in your UVM testbench.",
            "slug": "index",
            "title": "E-PERF-1: UVM Performance",
          },
        ],
      },
      {
        "slug": "E-SOC-1_SoC-Level_Verification_Strategies",
        "title": "E-SOC-1: SoC-Level Verification Strategies",
        "topics": [
          {
            "description": "Learn about the unique challenges and strategies for verifying a complete System-on-Chip (SoC).",
            "slug": "index",
            "title": "E-SOC-1: SoC-Level Verification Strategies",
          },
          {
            "description": "Using coverage results to measure verification completeness.",
            "slug": "coverage-closure",
            "title": "Coverage Closure and Metrics | The Professional Verification Craft",
          },
          {
            "description": "Building stable regressions and quickly diagnosing failures.",
            "slug": "regression-triage",
            "title": "Regression and Triage Strategies | The Professional Verification Craft",
          },
        ],
      },
    ],
    "slug": "T4_Expert",
    "tier": "T4",
    "title": "Expert",
  },
  {
    "sections": [
      {
        "slug": "uvm-visualizers",
        "title": "Uvm Visualizers",
        "topics": [
          {
            "description": "A hands-on, interactive visualizer for exploring the UVM testbench architecture, phasing, and data flow in real-time.",
            "slug": "interactive-testbench",
            "title": "Interactive UVM Testbench",
          },
        ],
      },
    ],
    "slug": "interactive-tools",
    "tier": "interactive-tools",
    "title": "Interactive Tools",
  },
  {
    "sections": [
      {
        "slug": "essentials",
        "title": "Essentials",
        "topics": [
          {
            "description": "Learn how to use agents and environments to build modular and reusable UVM testbenches.",
            "slug": "agents-and-environment",
            "title": "Agents and Environment",
          },
          {
            "description": "Learn how to use monitors, scoreboards, and other analysis components to check the correctness of your DUT.",
            "slug": "analysis-components",
            "title": "Analysis Components",
          },
          {
            "description": "An overview of the standard UVM testbench architecture.",
            "slug": "architecture-overview",
            "title": "Testbench Architecture Overview",
          },
          {
            "description": "Learn how to generate stimulus in a UVM testbench using sequences and sequencers.",
            "slug": "stimulus-generation",
            "title": "Stimulus Generation",
          },
        ],
      },
    ],
    "slug": "uvm-building",
    "tier": "uvm-building",
    "title": "Uvm Building",
  },
  {
    "sections": [
      {
        "slug": "fundamentals",
        "title": "Fundamentals",
        "topics": [
          {
            "description": "",
            "slug": "base-classes",
            "title": "UVM Base Classes",
          },
          {
            "description": "Learn how UVM components communicate using Transaction-Level Modeling (TLM), a high-level approach that enables interoperability and reuse.",
            "slug": "component-communication",
            "title": "Component Communication",
          },
          {
            "description": "Learn how the UVM factory enables test-specific customization and replacement of components and objects without modifying the original testbench code.",
            "slug": "factory",
            "title": "UVM Factory",
          },
          {
            "description": "",
            "slug": "phasing",
            "title": "Phasing",
          },
        ],
      },
    ],
    "slug": "uvm-core",
    "tier": "uvm-core",
    "title": "Uvm Core",
  },
]
`;

exports[`curriculum generator > generates expected curriculum data 1`] = `
[
  {
    "sections": [
      {
        "slug": "F1_Why_Verification",
        "title": "F1: Why Verification?",
        "topics": [
          {
            "description": "An introduction to the world of hardware verification.",
            "slug": "index",
            "title": "F1: Why Verification?",
          },
        ],
      },
      {
        "slug": "F2_Data_Types",
        "title": "F2: SystemVerilog Data Types",
        "topics": [
          {
            "description": "Understand SystemVerilog data types: the crucial difference between 2-state (bit, int) and 4-state (logic, wire, reg) types, and their application in modeling hardware signals and building verification testbenches.",
            "slug": "index",
            "title": "F2: SystemVerilog Data Types",
          },
          {
            "description": "An overview of arrays in SystemVerilog.",
            "slug": "arrays",
            "title": "Arrays: Packed, Unpacked, Dynamic, Queues, Associative | SystemVerilog Language Foundations",
          },
          {
            "description": "How to create user-defined types.",
            "slug": "user-defined",
            "title": "User-Defined Types: structs, unions, enums, typedef | SystemVerilog Language Foundations",
          },
        ],
      },
      {
        "slug": "F2_SystemVerilog_Basics",
        "title": "F2: SystemVerilog Language Basics",
        "topics": [
          {
            "description": "A comprehensive introduction to the fundamental building blocks of the SystemVerilog language.",
            "slug": "index",
            "title": "F2: SystemVerilog Language Basics",
          },
        ],
      },
      {
        "slug": "F2_SystemVerilog_Primer",
        "title": "Module F-2: Digital Logic & HDL Primer",
        "topics": [
          {
            "description": "A crash course in the essential digital logic and HDL concepts for verification.",
            "slug": "index",
            "title": "Module F-2: Digital Logic & HDL Primer",
          },
        ],
      },
      {
        "slug": "F3_Behavioral_RTL_Modeling",
        "title": "F3: Behavioral & RTL Modeling",
        "topics": [
          {
            "description": "A core module that teaches how to describe hardware behavior in SystemVerilog.",
            "slug": "index",
            "title": "F3: Behavioral & RTL Modeling",
          },
        ],
      },
      {
        "slug": "F3_Procedural_Constructs",
        "title": "F3: Procedural Constructs",
        "topics": [
          {
            "description": "Understanding the building blocks of SystemVerilog code.",
            "slug": "index",
            "title": "F3: Procedural Constructs",
          },
          {
            "description": "Guide decisions with if, case, and loop constructs to steer simulation flow.",
            "slug": "flow-control",
            "title": "Procedural Flow Control | SystemVerilog Language Foundations",
          },
          {
            "description": "Launch parallel threads and synchronize them with join variants.",
            "slug": "fork-join",
            "title": "Fork-Join and Process Control | SystemVerilog Language Foundations",
          },
          {
            "description": "Compare callable blocks with and without timing to structure reusable code.",
            "slug": "tasks-functions",
            "title": "Tasks and Functions: Scoping and Lifetimes | SystemVerilog Language Foundations",
          },
        ],
      },
      {
        "slug": "F3_SystemVerilog_Intro",
        "title": "Module F-3: Introduction to the SystemVerilog Language",
        "topics": [
          {
            "description": "An introduction to the basic building blocks of the SystemVerilog language for verification.",
            "slug": "index",
            "title": "Module F-3: Introduction to the SystemVerilog Language",
          },
        ],
      },
      {
        "slug": "F4_RTL_and_Testbench_Constructs",
        "title": "F4: RTL and Testbench Constructs",
        "topics": [
          {
            "description": "Key constructs for design and verification.",
            "slug": "index",
            "title": "F4: RTL and Testbench Constructs",
          },
          {
            "description": "Learn how to use SystemVerilog interfaces and modports to simplify connections and create reusable verification components.",
            "slug": "interfaces",
            "title": "F4: Interfaces and Modports",
          },
          {
            "description": "Group shared declarations into reusable namespaces and manage visibility.",
            "slug": "packages",
            "title": "Packages and Compilation Scopes | SystemVerilog Language Foundations",
          },
          {
            "description": "Understand how program and clocking blocks help create race-free testbenches by separating the testbench from the DUT and defining clear timing for signal interaction.",
            "slug": "program-clocking",
            "title": "F4: Program and Clocking Blocks",
          },
        ],
      },
      {
        "slug": "F4_Verification_Basics_without_UVM",
        "title": "F4: Verification Basics without UVM",
        "topics": [
          {
            "description": "Bridging the gap between basic SystemVerilog and the complex UVM methodology.",
            "slug": "index",
            "title": "F4: Verification Basics without UVM",
          },
        ],
      },
      {
        "slug": "F4_Your_First_Testbench",
        "title": "Module F-4: Your First Testbench",
        "topics": [
          {
            "description": "A guided, hands-on lab to build your first simple, self-checking SystemVerilog testbench.",
            "slug": "index",
            "title": "Module F-4: Your First Testbench",
          },
        ],
      },
      {
        "slug": "F5_Intro_to_OOP_in_SV",
        "title": "F5: Intro to Object-Oriented Programming (OOP) in SV",
        "topics": [
          {
            "description": "The final prerequisite before diving into UVM.",
            "slug": "index",
            "title": "F5: Intro to Object-Oriented Programming (OOP) in SV",
          },
        ],
      },
    ],
    "slug": "T1_Foundational",
    "tier": "T1",
    "title": "Foundational",
  },
  {
    "sections": [
      {
        "slug": "I-SV-1_OOP",
        "title": "I-SV-1: Object-Oriented Programming for Verification",
        "topics": [
          {
            "description": "Understanding OOP as the foundation for modern verification methodologies like UVM.",
            "slug": "index",
            "title": "I-SV-1: Object-Oriented Programming for Verification",
          },
          {
            "description": "How to create objects with new and reference parent and current class members using this and super.",
            "slug": "constructors",
            "title": "Constructors, 'this', and 'super' | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Use generics and abstract classes to build reusable components while avoiding common pitfalls.",
            "slug": "parameterized-classes",
            "title": "Parameterized Classes and Abstract Classes | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-2_Constrained_Randomization",
        "title": "I-SV-2: Constrained Randomization",
        "topics": [
          {
            "description": "Using constrained randomization to intelligently search for bugs.",
            "slug": "index",
            "title": "I-SV-2: Constrained Randomization",
          },
          {
            "description": "Express conditional and iterative rules with implication and foreach constructs.",
            "slug": "advanced-constraints",
            "title": "Advanced Constraints: implication and iteration | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Control dependencies and defaults using constraint blocks, soft values, and solve-before ordering.",
            "slug": "constraint-blocks",
            "title": "Constraint Blocks, soft, and solve...before | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Hook solver callbacks with pre_randomize and post_randomize to prepare and finalize objects.",
            "slug": "controlling-randomization",
            "title": "Controlling Randomization: pre_randomize and post_randomize | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-3_Functional_Coverage",
        "title": "I-SV-3: Functional Coverage",
        "topics": [
          {
            "description": "Answering the question 'Are we done yet?' by modeling and measuring functional coverage.",
            "slug": "index",
            "title": "I-SV-3: Functional Coverage",
          },
          {
            "description": "Learn how covergroup options influence when and how data is sampled.",
            "slug": "coverage-options",
            "title": "Coverage Options and Sampling | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "Synchronize parallel processes with SystemVerilog events.",
            "slug": "events",
            "title": "Events | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Tie functional coverage points back to verification plan items.",
            "slug": "linking-coverage",
            "title": "Linking Coverage to the V-Plan | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "Use mailboxes for thread-safe communication between processes.",
            "slug": "mailboxes",
            "title": "Mailboxes | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Control access to shared resources using semaphore keys.",
            "slug": "semaphores",
            "title": "Semaphores | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-SV-4_Assertions_SVA",
        "title": "I-SV-4: SystemVerilog Assertions (SVA)",
        "topics": [
          {
            "description": "Learn how to use SystemVerilog Assertions (SVA) to specify design behavior over time and create powerful functional checks.",
            "slug": "index",
            "title": "I-SV-4: SystemVerilog Assertions (SVA)",
          },
          {
            "description": "Compare procedural checks with temporal properties through hands-on examples.",
            "slug": "immediate-vs-concurrent",
            "title": "Immediate vs. Concurrent Assertions | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Capture and reuse values within sequences to create robust properties.",
            "slug": "local-variables",
            "title": "Local Variables in Sequences | Advanced SystemVerilog for Verification",
          },
          {
            "description": "Coordinate assertions across clock domains and mask reset behavior with disable iff.",
            "slug": "multi-clocking",
            "title": "Multi-Clocking and disable-iff | Advanced SystemVerilog for Verification",
          },
        ],
      },
      {
        "slug": "I-UVM-1_UVM_Intro",
        "title": "I-UVM-1: UVM Introduction: Objects, Components, and Factory",
        "topics": [
          {
            "description": "Understanding the most fundamental UVM concepts: uvm_object, uvm_component, and the UVM Factory.",
            "slug": "index",
            "title": "I-UVM-1: UVM Introduction: Objects, Components, and Factory",
          },
        ],
      },
      {
        "slug": "I-UVM-2_Building_TB",
        "title": "I-UVM-2: Building a UVM Testbench: Components & Hierarchy",
        "topics": [
          {
            "description": "Assembling a standard UVM testbench and understanding the role of each component.",
            "slug": "index",
            "title": "I-UVM-2: Building a UVM Testbench: Components & Hierarchy",
          },
          {
            "description": "Centralized UVM message control and how to override it with a custom report handler.",
            "slug": "uvm-report-server",
            "title": "UVM Report Server and Verbosity | The UVM Universe - Core Concepts",
          },
          {
            "description": "The singleton that orchestrates UVM phases and launches tests.",
            "slug": "uvm-root",
            "title": "uvm_root and Test Execution | The UVM Universe - Core Concepts",
          },
        ],
      },
      {
        "slug": "I-UVM-3_Sequences",
        "title": "I-UVM-3: Basic UVM Sequences and Stimulus Generation",
        "topics": [
          {
            "description": "Mastering the core of UVM's powerful stimulus generation methodology by writing sequences.",
            "slug": "index",
            "title": "I-UVM-3: Basic UVM Sequences and Stimulus Generation",
          },
          {
            "description": "Use the UVM configuration database to pass settings down the hierarchy without tight coupling.",
            "slug": "uvm-config-db",
            "title": "uvm_config_db: set and get | The UVM Universe - Core Concepts",
          },
          {
            "description": "Resolve configuration conflicts using the underlying resource database and precedence rules.",
            "slug": "uvm-resource-db",
            "title": "uvm_resource_db and Precedence | The UVM Universe - Core Concepts",
          },
        ],
      },
      {
        "slug": "I-UVM-4_Factory_and_Overrides",
        "title": "I-UVM-4: UVM Factory and Overrides",
        "topics": [
          {
            "description": "Swap component implementations on the fly using the UVM factory's type and instance overrides.",
            "slug": "index",
            "title": "I-UVM-4: UVM Factory and Overrides",
          },
        ],
      },
      {
        "slug": "I-UVM-5_Phasing_and_Synchronization",
        "title": "I-UVM-5: UVM Phasing and Synchronization",
        "topics": [
          {
            "description": "Understand the UVM phasing mechanism for synchronizing testbench execution and the core UVM class hierarchy.",
            "slug": "index",
            "title": "I-UVM-5: UVM Phasing and Synchronization",
          },
          {
            "description": "Separate components into custom phase domains and redirect execution with phase jumping.",
            "slug": "domains-phase-jumping",
            "title": "Domains and Phase Jumping | The UVM Universe - Core Concepts",
          },
          {
            "description": "Coordinate activity using lightweight events and blocking barriers for synchronization.",
            "slug": "uvm-event-barrier",
            "title": "uvm_event and uvm_barrier | The UVM Universe - Core Concepts",
          },
        ],
      },
    ],
    "slug": "T2_Intermediate",
    "tier": "T2",
    "title": "Intermediate",
  },
  {
    "sections": [
      {
        "slug": "A-UVM-1_Advanced_Sequencing",
        "title": "A-UVM-1: Advanced UVM Sequencing",
        "topics": [
          {
            "description": "Learn about advanced UVM sequencing techniques, including layered sequences, virtual sequences, and sequence libraries.",
            "slug": "index",
            "title": "A-UVM-1: Advanced UVM Sequencing",
          },
          {
            "description": "...",
            "slug": "connecting",
            "title": "Connecting the Agent Components | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "environment-test-classes",
            "title": "The Environment and Test Classes | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "interrupt-handling",
            "title": "Interrupt Handling and Layered Stimulus | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "...",
            "slug": "layered-sequences",
            "title": "Layered Sequences and p_sequencer | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "sequence-arbitration",
            "title": "Sequence Arbitration and Priority | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "...",
            "slug": "sequence-libraries",
            "title": "Sequence Libraries and grab/ungrab | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "sequencer-driver-handshake",
            "title": "The Sequencer-Driver Handshake | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "uvm-monitor",
            "title": "uvm_monitor and Analysis Ports | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "uvm-scoreboard",
            "title": "The UVM Scoreboard | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "uvm-sequence-item",
            "title": "uvm_sequence_item and uvm_sequence | Building a UVM Testbench",
          },
          {
            "description": "...",
            "slug": "uvm-subscriber",
            "title": "uvm_subscriber | Building a UVM Testbench",
          },
          {
            "description": "Coordinating stimulus across multiple agents.",
            "slug": "uvm-virtual-sequencer",
            "title": "UVM Virtual Sequencer",
          },
          {
            "description": "Learn how to use virtual sequences and sequencers to coordinate and synchronize stimulus across multiple agents in a UVM testbench.",
            "slug": "virtual-sequences",
            "title": "Virtual Sequences and Sequencers",
          },
        ],
      },
      {
        "slug": "A-UVM-2_The_UVM_Factory_In-Depth",
        "title": "A-UVM-2: The UVM Factory In-Depth",
        "topics": [
          {
            "description": "Explore advanced UVM factory features, including instance overrides, string-based overrides, and debugging techniques.",
            "slug": "index",
            "title": "A-UVM-2: The UVM Factory In-Depth",
          },
          {
            "description": "...",
            "slug": "heartbeats",
            "title": "Heartbeats and Testbench Monitoring | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "...",
            "slug": "uvm-callbacks",
            "title": "UVM Callbacks and Facade Classes | Advanced UVM Techniques & Strategy",
          },
        ],
      },
      {
        "slug": "A-UVM-3_Advanced_UVM_Techniques",
        "title": "Advanced UVM Techniques & Strategy | Advanced UVM",
        "topics": [
          {
            "description": "Expert-level concepts like RAL, virtual sequences, callbacks, and coverage integration.",
            "slug": "index",
            "title": "Advanced UVM Techniques & Strategy | Advanced UVM",
          },
        ],
      },
      {
        "slug": "A-UVM-4_The_UVM_Register_Abstraction_Layer_RAL",
        "title": "A-UVM-4: The UVM Register Abstraction Layer (RAL)",
        "topics": [
          {
            "description": "Learn how to use the UVM Register Abstraction Layer (RAL) to model and access DUT registers in a standardized and reusable way.",
            "slug": "index",
            "title": "A-UVM-4: The UVM Register Abstraction Layer (RAL)",
          },
          {
            "description": "...",
            "slug": "built-in-ral-sequences",
            "title": "Built-in RAL Sequences and Adapters | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "...",
            "slug": "explicit-vs-implicit",
            "title": "Explicit vs. Implicit Prediction | Advanced UVM Techniques & Strategy",
          },
          {
            "description": "...",
            "slug": "frontdoor-vs-backdoor",
            "title": "Frontdoor vs. Backdoor Access | Advanced UVM Techniques & Strategy",
          },
        ],
      },
    ],
    "slug": "T3_Advanced",
    "tier": "T3",
    "title": "Advanced",
  },
  {
    "sections": [
      {
        "slug": "E-CUST-1_UVM_Methodology_Customization",
        "title": "E-CUST-1: UVM Methodology Customization",
        "topics": [
          {
            "description": "Learn how to customize the UVM methodology to meet the specific needs of your project.",
            "slug": "index",
            "title": "E-CUST-1: UVM Methodology Customization",
          },
        ],
      },
      {
        "slug": "E-DBG-1_Advanced_UVM_Debug_Methodologies",
        "title": "E-DBG-1: Advanced UVM Debug Methodologies",
        "topics": [
          {
            "description": "Learn advanced techniques for debugging complex UVM environments.",
            "slug": "index",
            "title": "E-DBG-1: Advanced UVM Debug Methodologies",
          },
          {
            "description": "Tried-and-true methods for diagnosing tricky failures.",
            "slug": "effective-debug",
            "title": "Effective Debug Techniques in UVM | The Professional Verification Craft",
          },
          {
            "description": "Patterns for building maintainable verification components.",
            "slug": "reusable-vip",
            "title": "Reusable Verification IP (VIP) Architecture | The Professional Verification Craft",
          },
        ],
      },
      {
        "slug": "E-INT-1_Integrating_UVM_with_Formal_Verification",
        "title": "E-INT-1: Integrating UVM with Formal Verification",
        "topics": [
          {
            "description": "Learn how to combine the power of UVM and formal verification to create a more robust verification environment.",
            "slug": "index",
            "title": "E-INT-1: Integrating UVM with Formal Verification",
          },
          {
            "description": "C interoperability for performance and modeling flexibility.",
            "slug": "dpi",
            "title": "Direct Programming Interface (DPI) | The Professional Verification Craft",
          },
          {
            "description": "Conceptual overview of portable stimulus methodology.",
            "slug": "pss",
            "title": "Introduction to Portable Stimulus (PSS) | The Professional Verification Craft",
          },
        ],
      },
      {
        "slug": "E-PERF-1_UVM_Performance",
        "title": "E-PERF-1: UVM Performance",
        "topics": [
          {
            "description": "Learn how to identify and address performance bottlenecks in your UVM testbench.",
            "slug": "index",
            "title": "E-PERF-1: UVM Performance",
          },
        ],
      },
      {
        "slug": "E-SOC-1_SoC-Level_Verification_Strategies",
        "title": "E-SOC-1: SoC-Level Verification Strategies",
        "topics": [
          {
            "description": "Learn about the unique challenges and strategies for verifying a complete System-on-Chip (SoC).",
            "slug": "index",
            "title": "E-SOC-1: SoC-Level Verification Strategies",
          },
          {
            "description": "Using coverage results to measure verification completeness.",
            "slug": "coverage-closure",
            "title": "Coverage Closure and Metrics | The Professional Verification Craft",
          },
          {
            "description": "Building stable regressions and quickly diagnosing failures.",
            "slug": "regression-triage",
            "title": "Regression and Triage Strategies | The Professional Verification Craft",
          },
        ],
      },
    ],
    "slug": "T4_Expert",
    "tier": "T4",
    "title": "Expert",
  },
  {
    "sections": [
      {
        "slug": "uvm-visualizers",
        "title": "Uvm Visualizers",
        "topics": [
          {
            "description": "A hands-on, interactive visualizer for exploring the UVM testbench architecture, phasing, and data flow in real-time.",
            "slug": "interactive-testbench",
            "title": "Interactive UVM Testbench",
          },
        ],
      },
    ],
    "slug": "interactive-tools",
    "tier": "interactive-tools",
    "title": "Interactive Tools",
  },
  {
    "sections": [
      {
        "slug": "essentials",
        "title": "Essentials",
        "topics": [
          {
            "description": "Learn how to use agents and environments to build modular and reusable UVM testbenches.",
            "slug": "agents-and-environment",
            "title": "Agents and Environment",
          },
          {
            "description": "Learn how to use monitors, scoreboards, and other analysis components to check the correctness of your DUT.",
            "slug": "analysis-components",
            "title": "Analysis Components",
          },
          {
            "description": "An overview of the standard UVM testbench architecture.",
            "slug": "architecture-overview",
            "title": "Testbench Architecture Overview",
          },
          {
            "description": "Learn how to generate stimulus in a UVM testbench using sequences and sequencers.",
            "slug": "stimulus-generation",
            "title": "Stimulus Generation",
          },
        ],
      },
    ],
    "slug": "uvm-building",
    "tier": "uvm-building",
    "title": "Uvm Building",
  },
  {
    "sections": [
      {
        "slug": "fundamentals",
        "title": "Fundamentals",
        "topics": [
          {
            "description": "",
            "slug": "base-classes",
            "title": "UVM Base Classes",
          },
          {
            "description": "Learn how UVM components communicate using Transaction-Level Modeling (TLM), a high-level approach that enables interoperability and reuse.",
            "slug": "component-communication",
            "title": "Component Communication",
          },
          {
            "description": "Learn how the UVM factory enables test-specific customization and replacement of components and objects without modifying the original testbench code.",
            "slug": "factory",
            "title": "UVM Factory",
          },
          {
            "description": "",
            "slug": "phasing",
            "title": "Phasing",
          },
        ],
      },
    ],
    "slug": "uvm-core",
    "tier": "uvm-core",
    "title": "Uvm Core",
  },
]
`;
