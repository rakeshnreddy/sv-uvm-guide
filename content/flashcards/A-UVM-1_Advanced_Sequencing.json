[
  {
    "front": "Why do virtual sequences run on a virtual sequencer instead of a driver-connected sequencer?",
    "back": "A virtual sequencer acts as a container for handles to multiple real sequencers. Virtual sequences coordinate other sequences across agents, so they do not need a driver connection themselves."
  },
  {
    "front": "When would you use `lock()`/`unlock()` versus `grab()`/`ungrab()` on a sequencer?",
    "back": "Use `lock()`/`unlock()` to guard short, critical bursts while still allowing arbitration afterward. `grab()`/`ungrab()` seizes the sequencer across phases and should be reserved for rare or debugging scenarios."
  },
  {
    "front": "What advantage does layering atomic, scenario, and test-level sequences provide?",
    "back": "Layering keeps stimulus modular and reusable: atomic sequences capture fundamental actions, scenario sequences combine them into meaningful flows, and virtual sequences orchestrate scenarios per agent without duplicating code."
  }
]
