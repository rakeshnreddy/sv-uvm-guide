[
  {
    "id": "uvm3-intent",
    "question": "What core responsibility does a UVM sequence handle?",
    "answer": "It encapsulates stimulus intent—procedural logic that creates and randomizes transactions before handing them to the sequencer/driver pipeline." 
  },
  {
    "id": "uvm3-handshake",
    "question": "List the three driver-side calls that must run for each transaction in order.",
    "answer": "`get_next_item()`, drive the transfer, and `item_done()`—skipping the last call will stall the sequencer." 
  },
  {
    "id": "uvm3-lock",
    "question": "When should a sequence call `lock()`/`unlock()`?",
    "answer": "Use it to reserve exclusive access to the sequencer so a critical burst (like programming a control register) is not interleaved by other sequences." 
  },
  {
    "id": "uvm3-default",
    "question": "How do you configure a sequencer to launch a default sequence without touching the test?",
    "answer": "Set `default_sequence` via `uvm_config_db` (or the sequencer's `default_sequence` field) so the sequence starts automatically during `start_phase`." 
  },
  {
    "id": "uvm3-debug",
    "question": "What log evidence tells you the handshake is blocked waiting on `item_done()`?",
    "answer": "You'll see the driver logging the same transaction repeatedly or nothing after `get_next_item()` while the sequencer shows pending items—classic sign `item_done()` never fired." 
  }
]
