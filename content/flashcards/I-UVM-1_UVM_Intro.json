[
  {
    "id": "uvm1-objects-components",
    "question": "How do `uvm_object` and `uvm_component` differ in a UVM testbench?",
    "answer": "`uvm_object` derivatives are transactional data that can be created, copied, and sent around; `uvm_component` derivatives live in the hierarchy, run through phasing, and wire the environment together."
  },
  {
    "id": "uvm1-register",
    "question": "Why must each class call `uvm_object_utils` or `uvm_component_utils`?",
    "answer": "The macros register the class with the factory so it can be constructed via `type_id::create`, cloned, and targeted by overrides."
  },
  {
    "id": "uvm1-create",
    "question": "What happens if a component calls `new()` instead of `type_id::create()`?",
    "answer": "The factory never sees the construction request, so any overrides or configuration that rely on the factory are ignored."
  },
  {
    "id": "uvm1-override-scope",
    "question": "When would you choose an instance override over a type override?",
    "answer": "Use an instance override when only a specific hierarchy path should swap implementationsâ€”for example, one agent in a multi-agent environment."
  },
  {
    "id": "uvm1-verify",
    "question": "How can you confirm that a factory override actually took effect?",
    "answer": "Print the topology or log `get_type_name()` calls (e.g., via `uvm_top.print_topology()` or custom `print_type()` methods) to see the substituted class names."
  }
]
