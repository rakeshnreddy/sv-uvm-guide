[
  {
    "front": "Why wrap UVM components with a project-specific base class?",
    "back": "It centralizes shared behaviour (config handles, logging, metrics) so every component inherits policy without duplicating plumbing." 
  },
  {
    "front": "When should you introduce a custom UVM phase?",
    "back": "Add a phase when you need a coordinated activity (e.g., firmware load) that must run between standard phases without hacking `run_phase`." 
  },
  {
    "front": "How do hooks or callbacks help methodology consumers?",
    "back": "They let block teams override behaviour in one method instead of copying base classes, keeping the core methodology stable." 
  }
]
