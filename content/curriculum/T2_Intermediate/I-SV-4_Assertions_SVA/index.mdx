---
title: "I-SV-4: SystemVerilog Assertions (SVA)"
description: "Specify temporal intent with SystemVerilog Assertions so your verification environment automatically checks protocol rules." 
flashcards: "I-SV-4_Assertions_SVA"
---

import { InteractiveCode, Quiz } from '@/components/ui';
import AssertionBuilder from '@/components/animations/AssertionBuilder';

## Quick Take
- **What it is:** SystemVerilog Assertions let you describe how signals should behave over time and automatically flag violations.
- **Why it matters:** Assertions catch protocol bugs the instant they occur, shrink debug time, and document the contract between blocks.
- **The Analogy:** Think of SVA as highway patrol. Sequences spot patterns like “car stops at red”; properties turn them into laws; an `assert` issues a ticket when a driver misbehaves.

> **Retention Hook:** Repeat “Sequence = pattern, Property = rule, Assert = enforcement” before you leave this page.

## Build Your Mental Model
### Traffic Rules for Signals
How do you guarantee an `ack` follows a `req` within three cycles? Assertions codify those timing rules. Immediate assertions are quick checkpoints inside procedural code; concurrent assertions sit alongside the design watching every clock tick.

### Immediate vs. Concurrent Assertions
Immediate assertions execute once, exactly where they are written. Concurrent assertions evaluate on a clock edge and observe time windows. Use concurrent assertions for protocol rules.

<InteractiveCode>
```systemverilog
// Sequence: request followed by acknowledge one cycle later
sequence s_req_then_ack;
  req ##1 ack;
endsequence

property p_req_implies_ack;
  @(posedge clk)
  req |-> s_req_then_ack;
endproperty

// Assertions and coverage derived from the property
assert_req_ack: assert property (p_req_implies_ack)
  else $error("Request not acknowledged in one cycle");

cover_req_ack: cover property (p_req_implies_ack);
```
</InteractiveCode>

### Temporal Operators at a Glance
- `##1` — delay by one cycle; `##[1:3]` — permit a range.
- `|->` — overlapping implication (consequent can happen now); `|=>` — non-overlapping (consequent must happen on the next sample).
- `throughout`, `until`, `s_eventually` — express “holds while” and liveness expectations.

<AssertionBuilder />

## Make It Work
1. **Identify intent:** Translate protocol rules or handshake timing into short English statements.
2. **Capture the pattern:** Write a `sequence` that names the events and timing separation.
3. **Promote to a rule:** Wrap the sequence inside a `property`, add clocking, and select `|->` or `|=>` based on the required alignment.
4. **Enforce & observe:** Instantiate the property with `assert` (and optionally `cover`) in an interface, bind file, or checker class.

**Checklist before moving on:**
- [ ] You can write a sequence that mirrors a verbal spec.
- [ ] You know when to use immediate versus concurrent assertions.
- [ ] You can choose `|->` or `|=>` to express timing intent.

## Push Further
- **Layered checking:** Combine assertions with functional coverage—every property can double as a coverage point.
- **Formal verification:** The same SVA feeds formal tools; they prove whether a property *can ever* fail.
- **Reusable checkers:** Package assertions in interfaces or bind files so DUT code stays untouched.
- **Memory trick:** Sequence = pattern, Property = rule, Assert/Cover = enforce/measure.

## Practice & Reinforce
- Flashcards – Drill the core vocabulary (`sequence`, `property`, `bind`, temporal operators).
- Micro-lab – Write a property enforcing “burst writes must stay aligned” and bind it to a virtual interface.
- Quiz – Confirm you understand assertions below.

<Quiz
  questions={[
    {
      question: 'What is the primary difference between an immediate and a concurrent assertion?',
      answers: [
        { text: 'Immediate assertions can only be used in modules.', correct: false },
        { text: 'Concurrent assertions are checked on every clock cycle over time; immediate assertions are checked once when the statement executes.', correct: true },
        { text: 'Immediate assertions cannot have a failure message.', correct: false },
        { text: 'Concurrent assertions do not require a clock.', correct: false }
      ],
      explanation:
        'Concurrent assertions run alongside the design and evaluate every sampling event, whereas immediate assertions are single-point checks.'
    },
    {
      question: 'In the property `req |-> ##[1:5] gnt;`, what does it specify?',
      answers: [
        { text: 'If req is high, gnt must be high on the same cycle.', correct: false },
        { text: 'If req is high, gnt must be high sometime between 1 and 5 cycles later.', correct: true },
        { text: 'req and gnt must both be high for 5 cycles.', correct: false },
        { text: 'gnt must be high one cycle before req.', correct: false }
      ],
      explanation:
        'The delay `##[1:5]` widens the acceptance window so the acknowledgement may arrive in any of the next five samples.'
    },
    {
      question: 'Where should you house reusable concurrent assertions?',
      answers: [
        { text: 'Inside random stimulus constraints.', correct: false },
        { text: 'Within interfaces or bind files so multiple components can share them.', correct: true },
        { text: 'Sprinkled throughout the DUT RTL for convenience.', correct: false },
        { text: 'Only in test classes to keep compilation order simple.', correct: false }
      ],
      explanation:
        'Interfaces or checkers keep assertions close to the signals they observe without modifying DUT source.'
    }
  ]}
/>

## References & Next Topics
- IEEE 1800-2017 §16 “Assertions.”
- Mentor Graphics, *Assertion-Based Verification Methodology*.
- Next: [/curriculum/T2_Intermediate/I-UVM-1_UVM_Intro](../I-UVM-1_UVM_Intro/index).
