---
title: "I-SV-1: Object-Oriented Programming for Verification"
description: "Build reusable, polymorphic verification components with SystemVerilog classes, inheritance, and virtual methods."
flashcards: "I-SV-1_OOP"
---

import { InteractiveCode, Quiz } from '@/components/ui';

## Quick Take
- **What it is:** Object-Oriented Programming (OOP) wraps data and behavior into classes so we can spawn many tailored verification objects from a single blueprint.
- **Why it matters:** UVM is built entirely on OOP. Without classes, inheritance, and polymorphism, you cannot create reusable drivers, sequences, or factories that scale across projects.
- **The Analogy:** Think of a high-end kitchen. A **class** is your recipe card; an **object** is the plated dish. **Inheritance** tweaks the base recipe (vegan, gluten-free) while **polymorphism** lets the same chef robot cook any variant as long as it knows the recipe interface.

> **Note:** Mastering OOP is the gatekeeper skill between procedural benches and professional-grade UVM environments.

### Foundation Refresh (from Tier 1)
- **Class vs. object vs. handle:** the class defines the blueprint, `new()` creates the object in memory, and the handle is the remote control you store in variables.
- **Constructors:** add a `function new()` to seed default field values so every object starts sane.
- **Random-ready properties:** mark fields with `rand` and call `.randomize()` to generate stimulus; guide it with `constraint` blocks (`a != 0; b < 10;`).
- **Memory hook:** remember *Instantiate → Drive → Check*—now you’ll wrap each step in classes instead of raw tasks. If these ideas feel rusty, revisit the Tier-1 spotlight embedded in `F2_SystemVerilog_Basics` before continuing.

## Build Your Mental Model
### Visual Blueprint
<div className="my-8 glass-card glow-border px-6 py-8">
  <Image
    src="/visuals/oop-blueprint.svg"
    alt="Diagram showing base packet, specialized packet, and polymorphic driver"
    width={720}
    height={360}
    sizes="(min-width: 1024px) 720px, 100vw"
    className="w-full"
  />
</div>

### Classes & Objects – Creating Blueprints
<InteractiveCode>
```systemverilog
// Blueprint for a reusable transaction
class BasePacket;
  rand bit [31:0] addr;
  rand bit [31:0] data;

  function void print();
    $display("Packet addr=0x%h data=0x%h", addr, data);
  endfunction
endclass

program demo;
  initial begin
    BasePacket pkt1 = new();
    BasePacket pkt2 = new();
    void'(pkt1.randomize());
    pkt1.print();
  end
endprogram
```
</InteractiveCode>

### Encapsulation – Guard the Internals
<InteractiveCode>
```systemverilog
class CrcPacket;
  rand bit [7:0] payload;
  local bit [3:0] crc;

  function void calculate_crc();
    crc = ^payload; // toy CRC
  endfunction

  function bit [3:0] get_crc();
    return crc;
  endfunction
endclass
```
</InteractiveCode>
Encapsulation hides implementation details (`crc`) while exposing intent (`calculate_crc`, `get_crc`). This prevents careless external writes and keeps APIs clean.

### Inheritance & Polymorphism – Specialize Without Rewrite
<InteractiveCode>
```systemverilog
class BasePacket;
  virtual function void pack();
    $display("[BasePacket] generic packing");
  endfunction
endclass

class EthernetPacket extends BasePacket;
  rand bit [47:0] dst_mac;

  function void pack();
    $display("[EthernetPacket] packing MAC=%h", dst_mac);
  endfunction
endclass

class UsbPacket extends BasePacket;
  function void pack();
    $display("[UsbPacket] packing USB framing");
  endfunction
endclass

class GenericDriver;
  task run(BasePacket pkt);
    pkt.pack(); // resolves to the concrete implementation
  endtask
endclass
```
</InteractiveCode>
A single `GenericDriver` talks to any `BasePacket` descendant—exactly how UVM drivers use `uvm_sequence_item` handles.

## Make It Work
1. **Define your transactions:** Start with a base class containing shared fields, methods, and automation (`rand`, `constraint`, `copy`/`compare`).
2. **Specialize via inheritance:** Create derived packet classes for protocol-specific fields. Override virtual methods (e.g., `pack`, `convert2string`).
3. **Drive polymorphically:** Use base-class handles (`BasePacket pkt_h`) across sequencers, drivers, and scoreboards to minimize coupling.
4. **Instrument with encapsulation:** expose intent methods (`start_transfer`) while protecting internals with `local`/`protected` attributes.

**Checklist before moving on:**
- [ ] You can explain class vs. object vs. handle.
- [ ] You can demonstrate encapsulation with `local`/`protected` members.
- [ ] You can show how virtual methods enable polymorphic drivers.

## Push Further
- Implement factory overrides (UVM `type_id::create`) to swap derived packets at runtime.
- Explore abstract classes & pure virtual methods for defining protocol templates.
- Profile simulation performance when using deep inheritance hierarchies—know when composition might be cleaner.

## Practice & Reinforce
- Flashcards – Drill the vocabulary for classes, handles, inheritance, polymorphism.
- Quiz – Answer the OOP readiness questions below.
- Mini-lab – Convert a procedural driver to a class-based, polymorphic driver that accepts any packet type.
- Visual notebook – Sketch your transaction hierarchy and mark which methods are virtual/overridden.

## References & Next Topics
- IEEE SystemVerilog LRM – Classes & OOP chapter.
- Chris Spear, *SystemVerilog for Verification*, Chapters 7–9.
- Siemens Verification Academy: “Object Oriented Programming in UVM.”
- Next: [`/curriculum/T2_Intermediate/I-SV-2_Constrained_Randomization`](../I-SV-2_Constrained_Randomization/).

<Quiz
  questions={[
    {
      question: 'Why declare methods virtual in base classes?',
      answers: [
        { text: 'To prevent derived classes from overriding them', correct: false },
        { text: 'So base handles call the derived implementation at runtime', correct: true },
        { text: 'To make the method private', correct: false },
        { text: 'Virtual methods simulate faster', correct: false }
      ],
      explanation:
        'Polymorphism relies on virtual methods—handles of the base type invoke the correct override in derived objects.'
    },
    {
      question: 'What problem does encapsulation solve in verification classes?',
      answers: [
        { text: 'It speeds up simulation', correct: false },
        { text: 'It hides internal state so only intent-driven APIs mutate data', correct: true },
        { text: 'It avoids the need for constructors', correct: false },
        { text: 'It allows multiple inheritance', correct: false }
      ],
      explanation:
        'Encapsulation prevents accidental external writes and keeps transaction APIs stable as implementations evolve.'
    },
    {
      question: 'When would you extend a base transaction class?',
      answers: [
        { text: 'When you need a brand-new protocol unrelated to existing fields', correct: false },
        { text: 'When you want to reuse shared fields/methods but add or override specialized behavior', correct: true },
        { text: 'To copy-paste code faster', correct: false },
        { text: 'Only when using UVM factories', correct: false }
      ],
      explanation:
        'Inheritance shines when most behavior is shared and you only need targeted specialization.'
    }
  ]}
/>
