import { InfoPage } from "@/components/templates/InfoPage";
import { InteractiveCode } from "@/components/ui";

export const metadata = {
  title: "Domains and Phase Jumping | The UVM Universe - Core Concepts",
  description: "...",
};

<InfoPage
  title="Domains and Phase Jumping"
  uvm_concept_tags={["domains", "phase jumping"]}
>

  ## Phase Domains

  Phases execute in a **domain**. The default *common* domain runs all components
  through the standard phase sequence. You can create additional domains to run
  a subset of components with their own phase scheduleâ€”for example, to keep a
  configuration agent alive after the rest of the environment has stopped.

  <InteractiveCode
    language="systemverilog"
    fileName="custom_domain_example.sv"
    code={`class cfg_agent extends uvm_agent;
  `uvm_component_utils(cfg_agent)
  // ...
endclass

class my_env extends uvm_env;
  `uvm_component_utils(my_env)
  cfg_agent cfg;
  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    cfg = cfg_agent::type_id::create("cfg", this);
    uvm_domain cfg_dom = new("cfg_dom");
    cfg.set_domain(cfg_dom); // cfg runs in its own domain
  endfunction
endclass`}
  />

  ## Phase Jumping

  UVM allows components to **jump** to another phase. This is rarely used but can
  be helpful to skip remaining runtime phases when a stopping condition is met.

  <InteractiveCode
    language="systemverilog"
    fileName="phase_jump_example.sv"
    code={`task run_phase(uvm_phase phase);
  if(stop_simulation)
    phase.jump(uvm_shutdown_phase::get());
endtask`}
  />

</InfoPage>