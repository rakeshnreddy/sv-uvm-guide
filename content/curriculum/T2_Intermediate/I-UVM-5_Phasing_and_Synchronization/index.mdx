---
title: "I-UVM-5: UVM Phasing and Synchronization"
description: "Orchestrate build, run, and cleanup with UVM phases and objections so every component stays in lockstep."
flashcards: "I-UVM-5_Phasing_and_Synchronization"
---

import dynamic from 'next/dynamic';
import { InteractiveCode, Quiz } from '@/components/ui';
import UvmPhasingDiagram from '@/components/diagrams/UvmPhasingDiagram';

const VisualizationPlaceholder = () => (
  <div className="flex h-48 items-center justify-center">Loading visualization...</div>
);

const UvmHierarchySunburstChart = dynamic(
  () => import('@/components/charts/UvmHierarchySunburstChart'),
  { ssr: false, loading: () => <VisualizationPlaceholder /> },
);

## Quick Take
- **What it is:** UVM phasing defines the sequence of build, run, and cleanup steps each component follows; objections control when task-based phases end.
- **Why it matters:** Consistent phasing keeps agents, scoreboards, and tests synchronized—no component starts driving before everything is connected.
- **The Analogy:** Think of phases as a rehearsal schedule: setup, sound check, showtime, encore. Objections are the stage manager holding the curtain until performers finish.

> **Retention Hook:** Say “build → connect → run → report” and picture objections as the brake pedal on `run_phase`.

## Build Your Mental Model
### Three Buckets of Phases
Phases fall into predictable groups:
- **Build-time (functions, top-down):** `build`, `connect`, `end_of_elaboration` create and wire components.
- **Run-time (tasks, parallel):** `run_phase` is the workhorse; optional runtime phases (`reset`, `configure`, `main`, `shutdown`) execute in order but allow overlap across components.
- **Cleanup (functions, bottom-up):** `extract`, `check`, `report` gather results and print summaries.

<UvmPhasingDiagram />

### Objection Flow
Task-based phases end only when all objections drop.

<InteractiveCode>
```systemverilog
class my_driver extends uvm_driver#(my_txn);
  `uvm_component_utils(my_driver)

  virtual task run_phase(uvm_phase phase);
    phase.raise_objection(this, "Driver warming up");

    repeat (10) begin
      drive_one_transaction();
    end

    phase.drop_objection(this, "Driver finished");
  endtask
endclass
```
</InteractiveCode>

Forget to drop an objection and your simulation hangs. Automate safety nets with `phase.raise_objection(this, reason, 1)` timeouts or `uvm_objection::set_drain_time` to drain gracefully.

### Hierarchy Reminder
`uvm_component` descendants participate in phasing; `uvm_object` descendants do not.

<div className="my-6">
  <UvmHierarchySunburstChart />
</div>

- Components (envs, agents, drivers, scoreboards) inherit phasing callbacks.
- Objects (sequence items, configs) travel between components without phases.

## Make It Work
1. **Implement the lifecycle:** Override relevant phases (`build_phase`, `connect_phase`, `run_phase`, `report_phase`) and always call `super`.
2. **Control runtime:** Raise objections before asynchronous work and drop them when done. Centralize long-running sequences in virtual tests so a single component coordinates lifetime.
3. **Instrument reporting:** Use `report_phase` for pass/fail summaries; keep heavy analysis in `check_phase` to separate evaluation from logging.
4. **Validate ordering:** Run with `+UVM_PHASE_TRACE` (or `uvm_top.print_topology()`) to confirm which components fire each phase.

**Checklist before moving on:**
- [ ] You can list build/run/cleanup phases without peeking at docs.
- [ ] You know how objections gate the end of `run_phase`.
- [ ] You can explain why only components, not objects, receive phases.

## Push Further
- **Custom phase nodes:** Insert user-defined phases (e.g., `configure_phase`) to line up multi-interface bring-up.
- **Phase jumping:** Use `phase.jump()` sparingly to reset or fast-forward, and only when every component expects it.
- **Drain times:** Leverage `set_drain_time` to allow monitors to flush FIFOs after objections clear.
- **Phase automation:** Add assertions that `phase.is_ready_to_end()` returns true before dropping final objections.

## Practice & Reinforce
- Flashcards – Drill phase ordering and objection semantics.
- Micro-lab – Instrument a monitor to raise an objection until it sees a DONE packet, then drop it.
- Debug drill – Enable `+UVM_PHASE_TRACE` and annotate the log with who raises/drops objections.
- Quiz – Check your understanding below.

<Quiz questions={[
  {
    question: 'Which UVM phase executes top-down and is responsible for instantiating components?',
    answers: [
      { text: 'connect_phase', correct: false },
      { text: 'run_phase', correct: false },
      { text: 'build_phase', correct: true },
      { text: 'report_phase', correct: false }
    ],
    explanation: 'The `build_phase` walks the hierarchy top-down, giving each parent the chance to create its children before those children run.'
  },
  {
    question: 'What is the primary role of the objection mechanism in UVM?',
    answers: [
      { text: 'To configure components before build', correct: false },
      { text: 'To keep a run-time phase active while work remains', correct: true },
      { text: 'To report scoreboard mismatches', correct: false },
      { text: 'To randomize sequences', correct: false }
    ],
    explanation: 'Objections are cooperative counters; `run_phase` ends only after every component that raised one has dropped it.'
  }
]} />

## References & Next Topics
- Accellera, *UVM User Guide* – Chapter on phasing and objections.
- Mentor Graphics, *UVM Phase Jumping Best Practices*.
- Next: [Tier 3 planning](../../../docs/topic-template-migration).
