---
title: "I-UVM-3: Basic UVM Sequences and Stimulus Generation"
description: "Author reusable UVM sequences, understand the sequencer ↔ driver handshake, and stitch stimulus into layered scenarios."
flashcards: "I-UVM-3_Sequences"
---

import { InteractiveCode, Quiz } from '@/components/ui';
import { AnimatedUvmSequenceDriverHandshakeDiagram } from '@/components/diagrams/AnimatedUvmSequenceDriverHandshakeDiagram.tsx';

## Quick Take
- **What it is:** UVM sequences encapsulate stimulus intent—procedural code that generates transactions and hands them to the driver through the sequencer.
- **Why it matters:** Sequencing keeps tests reusable. You can replay the same sequence across different agents or mix sequences together without rewriting drivers.
- **The Analogy:** Think of sequences as playlists: they decide which songs (transactions) play and in what order, while the driver is the DJ mixing them onto the bus.

> **Retention Hook:** Whisper “start, drive, item_done” until the handshake cadence sticks.

## Build Your Mental Model
### Why Sequences Exist
Instead of scripting stimulus in a test, sequences (`uvm_sequence`) house the scenario logic. Because they extend `uvm_object`, they are easy to configure, clone, and reuse across agents.
- Reuse a `register_reset_check` sequence across dozens of IPs.
- Layer small helper sequences inside bigger ones for realistic scenarios.
- Swap drivers without touching the sequence—intent stays separate from pin-level implementation.

### The Sequencer ↔ Driver Handshake
The handshake is a blocking baton pass between sequence, sequencer, and driver.

<AnimatedUvmSequenceDriverHandshakeDiagram />

1. Driver calls `get_next_item(req)` and waits.
2. Sequence randomizes data, calls `start_item(req)` / `finish_item(req)` (or `uvm_do`) to hand over the transaction.
3. Driver drives the bus.
4. Driver calls `item_done()` to unblock the next item—skip it and the pipeline jams.

### Your First Sequence
Use the `uvm_do` macros to create, randomize, and send items inside `body()`.

<InteractiveCode>
```systemverilog
class my_transaction extends uvm_sequence_item;
  rand int data;
  `uvm_object_utils_begin(my_transaction)
    `uvm_field_int(data, UVM_DEFAULT)
  `uvm_object_utils_end
endclass

class my_simple_sequence extends uvm_sequence#(my_transaction);
  `uvm_object_utils(my_simple_sequence)

  virtual task body();
    my_transaction req;
    repeat (5) begin
      `uvm_do(req)
    end
  endtask
endclass

class my_driver extends uvm_driver#(my_transaction);
  `uvm_component_utils(my_driver)

  virtual task run_phase(uvm_phase phase);
    forever begin
      seq_item_port.get_next_item(req);
      drive_transfer(req);
      seq_item_port.item_done();
    end
  endtask
endclass

// Start the sequence on an agent's sequencer:
// my_simple_sequence::type_id::create("seq").start(env.agent.sqr);
```
</InteractiveCode>

### Guarding Critical Bursts
Need exclusive access (e.g., program a mode register)? Use `lock()`/`unlock()` around the critical section or `pre_do()`/`mid_do()` overrides to control arbitration.

```systemverilog
task body();
  my_transaction req;
  lock();
  repeat (5) `uvm_do_with(req, { burst_mode == 1; })
  unlock();
endtask
```

### Hooking Into Configuration & Analysis
- Register default sequences via [`uvm_config_db`](./uvm-config-db) so agents pull the right stimulus at runtime.
- Expose results with analysis ports or to coverage subscribers, keeping stimulus and checking loosely coupled.

## Make It Work
1. **Define the transaction:** Extend `uvm_sequence_item` with the fields and constraints sequences will manipulate.
2. **Build the base sequence:** Override `body()`, call `uvm_do`/`uvm_do_with`, and add logging so failures are traceable.
3. **Schedule it:** Start the sequence directly or configure it as an `default_sequence` through the sequencer/config DB.
4. **Verify the handshake:** Watch the driver log and ensure every `get_next_item` is matched with `item_done()`.

**Checklist before moving on:**
- [ ] You can sketch the four-step handshake from memory.
- [ ] You know when to reach for `lock()` or sequencer arbitration hooks.
- [ ] You can describe how sequences stay agnostic of driver implementation.

## Push Further
- **Layer sequences:** Compose virtual sequences that orchestrate multiple interface agents at once.
- **Parameterize intent:** Use sequence parameters or configuration objects to tweak behavior without new subclasses.
- **Tie into coverage:** Trigger covergroups inside sequences to correlate stimulus with coverage bins.
- **Regression tip:** Seed sequences from the test to replay failing scenarios deterministically.

## Practice & Reinforce
- Flashcards – Cement the handshake verbs and sequencing patterns.
- Micro-lab – Add `lock()`/`unlock()` to protect a register programming burst and observe the driver logs.
- Debug drill – Comment out `item_done()` and practice diagnosing the resulting hang.
- Quiz – Check your understanding below.

<Quiz questions={[
    {
      "question": "A sequence needs to send a critical, uninterrupted burst of 5 transactions to program a mode register. Which mechanism should it use?",
      "answers": [
        {"text": "A `for` loop with `uvm_do`", "correct": false},
        {"text": "`lock()` before the burst and `unlock()` after", "correct": true},
        {"text": "Using `p_sequencer`", "correct": false},
        {"text": "Calling `get_next_item()` directly", "correct": false}
      ],
      "explanation": "`lock()` ensures that no other sequence can send transactions to the driver, guaranteeing that the 5-transaction burst is sent atomically without interruption."
    },
    {
      "question": "What is the primary purpose of the `item_done()` call in the driver?",
      "answers": [
        {"text": "To tell the scoreboard that the transaction is complete.", "correct": false},
        {"text": "To log the transaction to a file.", "correct": false},
        {"text": "To signal to the sequencer that the driver is finished with the current transaction and is ready for the next one.", "correct": true},
        {"text": "To return the transaction to the sequence.", "correct": false}
      ],
      "explanation": "Forgetting to call `item_done()` is a very common bug. It prevents the sequencer from unblocking and sending the next transaction, causing the testbench to hang."
    }
  ]} />

## References & Next Topics
- Accellera, *UVM Cookbook* sequencer and arbitration chapter.
- Verification Academy, *Virtual Sequences and Layered Stimulus* webinar.
- Next: [/curriculum/T2_Intermediate/I-UVM-4_Factory_and_Overrides](../I-UVM-4_Factory_and_Overrides/index).
