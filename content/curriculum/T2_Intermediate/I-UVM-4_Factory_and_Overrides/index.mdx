---
title: "I-UVM-4: UVM Factory and Overrides"
description: "Swap component implementations on demand with UVM factory overrides and keep your testbench wiring untouched."
flashcards: "I-UVM-4_Factory_and_Overrides"
---

import { InteractiveCode, Quiz } from '@/components/ui';

## Quick Take
- **What it is:** The UVM factory lets you create components and objects through a registry so tests can substitute concrete implementations at runtime.
- **Why it matters:** Overrides enable A/B drivers, negative tests, and mock instrumentation without editing the environment that builds components.
- **The Analogy:** Think of the factory as a casting director—register every actor, then swap who plays the role without rewriting the script.

> **Retention Hook:** Repeat “register → create → override” every time you add a new component class.

## Build Your Mental Model
### Registration & Creation Rules
Every class you want to override must register with the factory and be constructed through `type_id::create`.

<InteractiveCode>
```systemverilog
class base_driver extends uvm_driver#(seq_item);
  `uvm_component_utils(base_driver)
endclass

class mock_driver extends base_driver;
  `uvm_component_utils(mock_driver)
endclass

class my_env extends uvm_env;
  `uvm_component_utils(my_env)
  base_driver drv;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    drv = base_driver::type_id::create("drv", this); // hook for overrides
  endfunction
endclass
```
</InteractiveCode>

Skip the registration macro or call `new()` directly and the factory loses visibility—no overrides, no configuration hooks.

### Type vs. Instance Overrides
- **Type overrides** replace every creation of a class with another class.
- **Instance overrides** target a specific hierarchy path (with wildcards if needed).

<InteractiveCode>
```systemverilog
initial begin
  // Global swap: every base_driver becomes a mock_driver
  mock_driver::type_id::set_type_override(base_driver::get_type());
  run_test();
end
```
</InteractiveCode>

<InteractiveCode>
```systemverilog
initial begin
  // Swap only env.drv (and matching wildcards)
  mock_driver::type_id::set_inst_override(base_driver::get_type(), "*.env.drv");
end
```
</InteractiveCode>

### Managing Scope & Debugging
- Wildcards (`*`, `?`) are powerful—log overrides with `uvm_factory::print()` to ensure you didn’t override too broadly.
- Instance overrides cascade down; place them before components are built (tests or virtual sequences are common homes).
- Combine overrides with configuration DB entries for fine-grained tuning (e.g., mock monitor + custom verbosity).

## Make It Work
1. **Register everything:** Add `uvm_*_utils` macros to classes you plan to override.
2. **Construct via the factory:** Replace direct `new` calls with `::type_id::create` everywhere in your environment.
3. **Select your override API:** Use `set_type_override_by_type` (global) or `set_inst_override_by_type` (scoped) before `build_phase` instantiates components.
4. **Verify the swap:** Call `uvm_top.print_topology()` or `uvm_factory::get().print()` to confirm the final mapping.

**Checklist before moving on:**
- [ ] You can explain why registration and factory construction are both required for overrides.
- [ ] You know when to pick type vs. instance overrides.
- [ ] You have a habit of printing the factory when debugging swaps.

## Push Further
- **Override chains:** Stack overrides (e.g., base → mock → fault-injecting) to build test-specific behavior.
- **Runtime control:** Gate overrides with plusargs or configuration objects so regressions can steer behavior without recompiling.
- **Prevent collisions:** Namespace test-specific overrides to avoid wildcard clashes in multi-interface environments.
- **Factory audit:** Automate a check that every `uvm_component` and `uvm_object` uses `::type_id::create`.

## Practice & Reinforce
- Flashcards – Drill the override APIs and registration rules.
- Micro-lab – Replace a driver with a latency-injecting variant and verify the swap via factory printouts.
- Debug drill – Intentionally skip `uvm_component_utils` on a class and watch the override silently fail.
- Quiz – Validate your understanding below.

<Quiz questions={[
  {
    question: 'Which method replaces every instance of a class with another type?',
    answers: [
      { text: 'set_inst_override', correct: false },
      { text: 'set_type_override', correct: true },
      { text: 'clone', correct: false }
    ],
    explanation: '`set_type_override` globally swaps one class for another during factory creation.'
  },
  {
    question: 'Why must a class include `uvm_component_utils` for factory overrides to work?',
    answers: [
      { text: 'It enables the class to be randomized', correct: false },
      { text: 'It registers the class with the factory', correct: true },
      { text: 'It adds a run_phase', correct: false }
    ],
    explanation: 'Registration macros insert the hooks the factory uses to create and override objects.'
  }
]} />

## References & Next Topics
- Accellera, *UVM Factory Reference Guide*.
- Cadence, *Practical Factory Overrides and Debugging Tips*.
- Next: [/curriculum/T2_Intermediate/I-UVM-5_Phasing_and_Synchronization](../I-UVM-5_Phasing_and_Synchronization/index).
