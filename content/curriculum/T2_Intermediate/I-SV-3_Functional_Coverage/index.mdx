---
title: "I-SV-3: Functional Coverage"
description: "Model verification intent with covergroups, coverpoints, and crosses to prove you've exercised every critical scenario."
flashcards: "I-SV-3_Functional_Coverage"
---

import { InteractiveCode, Quiz } from '@/components/ui';
import CoverageAnalyzer from '/src/components/animations/CoverageAnalyzer';

## Quick Take
- **What it is:** Functional coverage captures the design scenarios you *intend* to test, recording hits whenever stimulus exercises them.
- **Why it matters:** Code coverage only says which lines executed; functional coverage maps directly to the verification plan, answering “Are we done yet?”
- **The Analogy:** Imagine a mission checklist—every time a specific combination happens (burst write, secure mode, minimal latency), you tick a box. Unticked boxes reveal coverage holes.

> **Reminder:** Coverage is actionable only when tied to a plan. Define meaningful bins, not just random value ranges.

## Build Your Mental Model
### Coverage Blueprint
<div className="glass-card glow-border my-8 px-6 py-8">
  <img src="/visuals/coverage-blueprint.svg" alt="Diagram showing stimulus feeding coverpoints, crosses, and coverage reports" className="w-full" />
</div>

### Core Constructs in Action
<InteractiveCode>
```systemverilog
interface bus_if (input logic clk);
  logic [3:0] addr;
  logic [7:0] data;
  logic       rw;
  logic       valid;

  covergroup cg_bus @(posedge clk);
    // Address coverage
    cp_addr: coverpoint addr {
      bins low   = {[0:3]};
      bins high  = {[12:15]};
      bins mid[] = {[4:11]};
    }

    // Data sampled only on valid writes
    cp_data: coverpoint data iff (valid && rw) {
      bins zero = {8'h00};
      bins full = {8'hFF};
      bins others = default;
    }

    // Read vs write
    cp_rw: coverpoint rw;

    // Cross coverage for interaction
    addr_x_rw: cross cp_addr, cp_rw {
      ignore_bins write_low = binsof(cp_addr.low) && binsof(cp_rw) intersect {1};
    }
  endgroup

  cg_bus bus_cov = new();
endinterface
```
</InteractiveCode>

### Visualize & Iterate
Coverage is part of a loop: randomize → measure → analyze → refine. Use coverage reports, or in this case, the analyzer, to spot unhit bins.

<CoverageAnalyzer />

### Beyond Basics
- **Illegal bins:** flag scenarios that must never occur—ideal for catching spec violations early.
- **Soft bins:** `ignore_bins` drop uninteresting combinations from metrics.
- **Crosses:** verify feature interactions (e.g., command × power mode).

<InteractiveCode>
```systemverilog
class Packet;
  rand bit [1:0] kind;
  rand bit       has_crc;
endclass

class PacketCoverage;
  covergroup cg with function sample(Packet p);
    kind_cp: coverpoint p.kind;
    crc_cp : coverpoint p.has_crc;

    kind_crc: cross kind_cp, crc_cp {
      illegal_bins bad_combo = binsof(kind_cp) intersect {2} &&
                               binsof(crc_cp) intersect {0};
    }
  endgroup

  function new();
    cg = new();
  endfunction
endclass
```
</InteractiveCode>

## Make It Work
1. **Forecast scenarios:** Derive coverpoints and crosses directly from the verification plan features.
2. **Sample intelligently:** Place covergroups where the data is observable (monitors, subscribers) and use `iff` for valid sampling.
3. **Review reports:** After regressions, inspect bin hit counts; prioritize holes that map to high-risk features.
4. **Close the loop:** Adjust stimulus (constraints, directed sequences) to target unhit bins, rerun, and iterate.

**Checklist before moving on:**
- [ ] You can author a covergroup with meaningful bins and documented intent.
- [ ] You know when to add `ignore_bins` or `illegal_bins`.
- [ ] You can explain how cross coverage catches interaction bugs.

## Push Further
- Integrate coverage goals into automation (e.g., stop regression when goals met).
- Use weighted coverage (`option.goal`) to focus on critical bins first.
- Tie coverage data to dashboards that show closure status by feature.

## Practice & Reinforce
- Flashcards – Solidify terminology for coverpoints, bins, crosses.
- Quiz – Complete the coverage fundamentals check below.
- Mini-lab – Build a covergroup for a custom protocol, add an illegal bin, and observe simulator behavior.
- Visual notebook – Sketch how coverage bins map to your plan and track holes over time.

## References & Next Topics
- IEEE 1800-2017 §19 “Functional Coverage.”
- Accellera UVM User Guide – Coverage guidelines.
- Siemens Verification Academy: “Functional Coverage Strategies.”
- Next: [`/curriculum/T2_Intermediate/I-SV-4_Assertions_SVA`](../I-SV-4_Assertions_SVA/).

<Quiz
  questions={[
    {
      question: 'When would you use `illegal_bins`?',
      answers: [
        { text: 'To gain code coverage credit for a scenario', correct: false },
        { text: 'To flag that a scenario must never occur; hitting it raises an error', correct: true },
        { text: 'To exclude scenarios from coverage metrics', correct: false },
        { text: 'To define default bins automatically', correct: false }
      ],
      explanation:
        'Illegal bins terminate simulation if sampled, catching forbidden combinations as soon as they occur.'
    },
    {
      question: 'Why add cross coverage?',
      answers: [
        { text: 'To speed up sampling', correct: false },
        { text: 'To verify interactions between features defined by multiple coverpoints', correct: true },
        { text: 'To reduce the number of bins required', correct: false },
        { text: 'To convert code coverage to functional coverage', correct: false }
      ],
      explanation:
        'Cross coverage ensures that combinations like (command type × power mode) have been observed, not just each feature independently.'
    },
    {
      question: 'What’s the first step when a bin stays at zero?',
      answers: [
        { text: 'Disable the bin with ignore_bins', correct: false },
        { text: 'Verify whether the scenario is actually reachable and stimulus can produce it', correct: true },
        { text: 'Increase simulation time without analysis', correct: false },
        { text: 'Declare coverage closure anyway', correct: false }
      ],
      explanation:
        'Always check reachability and stimulus support before deciding whether to add directed tests, bias constraints, or mark the bin as irrelevant.'
    }
  ]}
/>
