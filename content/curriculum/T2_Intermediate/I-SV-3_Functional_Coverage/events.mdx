import { InfoPage } from "@/components/templates/InfoPage";
import { Quiz, InteractiveCode } from "@/components/ui";

export const metadata = {
  title: "Events | Advanced SystemVerilog for Verification",
  description: "Synchronize parallel processes with SystemVerilog events.",
};

<InfoPage
  title="Events"
  sv_concept_tags={["events"]}
>

  ## Level 1: The Big Idea

  An **event** is a simple synchronization object. One process can signal an event, and another can wait for it. It's like ringing a doorbell and waiting for someone to answer.

  ## Level 2: Practical Usage

  ### Declaring and Triggering

  -   Declare an event: `event done;`
  -   Trigger once: `-> done;` (all waiters run in the current timestep).
  -   Trigger with persistence: `->> done;` (waiters that start later in the same timestep still wake up).
  -   Wait for it: `@done;` or, if you need to poll, `wait(done.triggered);`.

  <InteractiveCode>
  ```systemverilog
  event start, done;

  initial begin
    // Producer thread
    repeat (3) begin
      #10 -> start;          // fire the start event
      @done;                 // wait for acknowledgement
    end
  end

  initial begin
    // Consumer thread
    forever begin
      @start;
      $display("Start seen at %0t", $time);
      #2 ->> done;           // acknowledge with persistence
    end
  end

  initial begin
    // Late listener still sees the persistent trigger
    wait(done.triggered);
    $display("First completion observed at %0t", $time);
  end
  ```
  </InteractiveCode>

  Events often coordinate randomized stimulus or monitor actions. Review [Constrained Randomization](/curriculum/T2_Intermediate/I-SV-2_Constrained_Randomization) to see how events can trigger new random transactions.

  ## Level 3: Expert Insights

  **Multiple triggers & lost pulses:** Native events do not queue requests. If you trigger with `->` before anyone is waiting, the pulse is gone. Use `->>` or keep a `done_seen` flag to avoid races.

  **Ordering constraints:** `wait_order(e1, e2)` (or the array form) asserts that events arrive in a given sequenceâ€”perfect for handshake protocols. Pair with assertions so violations show up in logs.

  **Leveraging `triggered`:** The built-in `event.triggered` bit goes high for the remainder of the timestep after a trigger. Combine it with `wait(event.triggered)` when you need to poll or drive scoreboard state machines.

  **Bridging to UVM:** `uvm_event` adds `wait_on()`, `wait_off()`, callbacks, and a `trigger_cnt`. Manage them through an `uvm_event_pool` so components can look up events by name without hard-coded handles. See [analysis components](/curriculum/T2_Intermediate/I-UVM-2_Building_TB/index#monitors-scoreboards-and-the-analysis-fabric) for how that integrates with monitors.

  ## Quiz

  <Quiz questions={[
    {
      question: "Which statement waits for event `go` to be triggered?",
      answers: [
        { text: "`-> go;`", correct: false },
        { text: "`@go;`", correct: true },
        { text: "`wait(go);`", correct: false },
        { text: "`disable go;`", correct: false }
      ],
      explanation: "`@go;` suspends the process until the event `go` is triggered."
    },
    {
      question: "How do you trigger an event named `done`?",
      answers: [
        { text: "`@done;`", correct: false },
        { text: "`-> done;`", correct: true },
        { text: "`event done;`", correct: false },
        { text: "`done.trigger();`", correct: false }
      ],
      explanation: "The `->` operator triggers a SystemVerilog event."
    }
  ]} />

</InfoPage>
