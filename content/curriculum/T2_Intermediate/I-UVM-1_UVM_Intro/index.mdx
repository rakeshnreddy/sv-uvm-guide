---
title: "I-UVM-1: UVM Introduction: Objects, Components, and Factory"
description: "Understand how UVM objects, components, and the factory stitch together so your testbench stays configurable."
flashcards: "I-UVM-1_UVM_Intro"
---

import { InteractiveCode, Quiz } from '@/components/ui';
import UvmHierarchySunburstChart from '@/components/charts/UvmHierarchySunburstChart';
import UvmPhasingDiagram from '@/components/diagrams/UvmPhasingDiagram';

## Quick Take
- **What it is:** UVM splits reusable logic into `uvm_object` data containers, `uvm_component` infrastructure, and a factory that decides which concrete types actually get built.
- **Why it matters:** Factory-driven creation keeps testbenches configurable—teams can swap sequences or drivers without touching the code that instantiates them.
- **The Analogy:** Objects are “packages” moving through the mail; components are “buildings” wired into the city; the factory is dispatch control deciding which package variant arrives where.

> **Retention Hook:** Say out loud: "Register, create, override"—that rhythm mirrors how every factory substitution works.

## Build Your Mental Model
### Objects Travel, Components Stay Anchored
`uvm_object` derivatives (sequence items, configs) travel between components. `uvm_component` derivatives (agents, drivers, envs) stay anchored in the hierarchy and join UVM phasing.

<UvmHierarchySunburstChart />

- `uvm_component` participates in build/connect/run phases—skip `super.build_phase` and child components never appear.
- `uvm_object` copies should go through `clone()` to preserve factory type info.
- Remember: **package vs. building**—one moves, one is installed.

### The Factory Contract
Every override hinges on the same contract: **register** the class, **create** through the factory, and **override** where needed.

```systemverilog
import uvm_pkg::*;
`include "uvm_macros.svh"

class base_packet extends uvm_sequence_item;
  `uvm_object_utils(base_packet)
  function new(string name = "base_packet");
    super.new(name);
  endfunction
endclass

class error_packet extends base_packet;
  `uvm_object_utils(error_packet)
  function new(string name = "error_packet");
    super.new(name);
  endfunction
endclass

class my_env extends uvm_env;
  `uvm_component_utils(my_env)
  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
  task run_phase(uvm_phase phase);
    base_packet pkt;
    phase.raise_objection(this);
    `uvm_info("ENV", "Creating a packet...", UVM_LOW)
    pkt = base_packet::type_id::create("pkt");
    pkt.print_type();
    phase.drop_objection(this);
  endtask
endclass
```

### Overrides in Action
Factory overrides let tests redirect traffic without touching environment code.

<InteractiveCode>
```systemverilog
class my_test extends uvm_test;
  `uvm_component_utils(my_test)
  my_env env;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    `uvm_info("TEST", "Setting factory override: base_packet -> error_packet", UVM_LOW)
    factory.set_type_override_by_type(base_packet::get_type(), error_packet::get_type());
    env = my_env::type_id::create("env", this);
  endfunction
endclass

module top;
  initial run_test("my_test");
endmodule
```
</InteractiveCode>

## Make It Work
1. **Register every class:** Drop `uvm_object_utils` or `uvm_component_utils` inside the class body.
2. **Create through the factory:** Use `::type_id::create` instead of `new()` so overrides can intercept construction.
3. **Select override scope:** Use `set_type_override_by_type` for global swaps; `set_inst_override_by_type` when only one path should change.
4. **Verify with print hooks:** Call `uvm_top.print_topology()` or custom `print_type()` logs to ensure overrides landed.

**Checklist before moving on:**
- [ ] You can explain the object vs. component split using the package/building analogy.
- [ ] You can write the register → create → override sequence without checking docs.
- [ ] You know which override API to use for global vs. single-instance substitutions.

## Push Further
- **Layer in configuration:** Pair factory overrides with configuration DB entries for fine-grained tweaks.
- **Leverage type overrides in regressions:** Swap in predictive monitors or error-injecting drivers per test.
- **Audit registration:** Lint for missing `*_utils` macros—without them the factory can’t help you.
- **Memory trick:** Say "register, create, override" whenever you stub a new component.

## UVM Phasing in Context
Phasing is the rehearsal schedule that keeps buildings (components) coordinated—build before connect, run before report.

<UvmPhasingDiagram />

- Always call parent implementations of each phase (`super.build_phase`, etc.).
- Raise/drop objections in `run_phase` to control when simulation ends.
- Jump phases (`phase.jump(...)`) sparingly; use when resetting, not for normal flow.

## Practice & Reinforce
- Flashcards – Drill the object/component split and factory lifecycle.
- Micro-lab – Override a scoreboard component in a toy testbench and confirm the replacement logs.
- Quiz – Validate your understanding below.

<Quiz questions={[
    {
      "question": "To replace ALL instances of `my_driver` with `my_error_driver` throughout the entire testbench, which factory method is most appropriate?",
      "answers": [
        {"text": "`set_inst_override_by_name`", "correct": false},
        {"text": "`set_type_override_by_type`", "correct": true},
        {"text": "`set_override_by_type`", "correct": false},
        {"text": "`set_inst_override`", "correct": false}
      ],
      "explanation": "`set_type_override_by_type` performs a global replacement of one type with another, which is exactly what is needed for a testbench-wide substitution."
    },
    {
      "question": "Why must we use the `factory.create()` method instead of the SystemVerilog `new()` constructor?",
      "answers": [
        {"text": "`create()` is faster than `new()`.", "correct": false},
        {"text": "`create()` is the hook that allows the factory to intercept the object creation request and apply an override if one exists.", "correct": true},
        {"text": "`new()` does not automatically call the parent class constructor.", "correct": false},
        {"text": "`create()` automatically registers the class with the factory.", "correct": false}
      ],
      "explanation": "The factory can only substitute a type if it is involved in the creation process. Using `factory.create()` gives the factory the control it needs to perform the substitution."
    },
    {
      "question": "Which phase is primarily used for creating component instances?",
      "answers": [
        {"text": "connect_phase", "correct": false},
        {"text": "run_phase", "correct": false},
        {"text": "build_phase", "correct": true},
        {"text": "report_phase", "correct": false}
      ],
      "explanation": "The `build_phase` executes top-down, ensuring that parent components are created before their children, which is the logical order for construction."
    }
  ]} />

## References & Next Topics
- Accellera, *UVM Class Reference* (uvm_component, uvm_object, factory API).
- Mentor Graphics, *Cookbook for UVM Factory Overrides*.
- Next: [/curriculum/T2_Intermediate/I-UVM-2_Building_TB](../I-UVM-2_Building_TB/index).
