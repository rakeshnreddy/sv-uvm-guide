import { InfoPage } from "@/components/templates/InfoPage";
import { Quiz, InteractiveCode, InterviewQuestionPlayground } from "@/components/ui";

export const metadata = {
  title: "Mailboxes | Advanced SystemVerilog for Verification",
  description: "Use mailboxes for thread-safe communication between processes.",
};

<InfoPage
  title="Mailboxes"
  sv_concept_tags={["mailboxes"]}
>

  ## Level 1: The Big Idea
  *IEEE 1800-2023, Clause 15.4: Mailboxes*

  A **mailbox** is a built-in message queue. One process `put`s an item into the mailbox while another `get`s it out. It's like dropping a letter into a box for someone else to pick up later.

  ## Level 2: Practical Usage

  ### Basic Operations

  | Call | Blocking? | Use it when |
  | --- | --- | --- |
  | `put(item)` | Blocks if the mailbox is full | Backpressure producer threads until consumers catch up. |
  | `try_put(item)` | Returns 0 if full | Drop low-priority work instead of stalling. |
  | `get(item)` | Blocks until something arrives | Classic producer/consumer handshakes. |
  | `try_get(item)` | Returns 0 if empty | Poll without blocking a monitor. |
  | `peek(item)` | Non-destructive read | Look at the next transaction while leaving it queued. |
  | `num()` | Instant | Inspect queue depth for assertions or adaptive throttling. |

  <InteractiveCode>
  ```systemverilog
  typedef struct { int id; bit [7:0] data; } packet_t;
  mailbox #(packet_t) mbx = new(4); // depth-limited queue

  task automatic produce_packet(int id);
    packet_t p = '{id: id, data: $urandom_range(0, 255)};
    if (!mbx.try_put(p)) begin
      // Backpressure: wait for space, then block on put
      wait (mbx.num() < 4);
      mbx.put(p);
    end
  endtask

  initial begin
    for (int idx = 0; idx < 8; idx++) begin
      produce_packet(idx);
    end
  end

  initial begin
    packet_t pkt;
    forever begin
      mbx.get(pkt);
      $display("[%0t] Consumer saw id=%0d depth=%0d", $time, pkt.id, mbx.num());
    end
  end
  ```
  </InteractiveCode>

  Mailboxes often carry randomized transactions. For generating those transactions, see [Constrained Randomization](/curriculum/T2_Intermediate/I-SV-2_Constrained_Randomization).

  ## Level 3: Expert Insights

  **Bounded vs. unbounded:** `new()` with no arguments gives you an infinite queue—useful for scoreboards, dangerous for drivers that might overrun memory. Set a depth to spot backpressure issues during bring-up.

  **Typed mailboxes:** Parameterized mailboxes (`mailbox#(packet_t)`) prevent accidental mixing of transaction types. Pair them with `typedef`ed structs so refactors stay safe.

  **Monitoring depth:** `mbx.num()` is a quick health indicator—assert it never exceeds your architectural limits, or expose it via telemetry to visualize congestion.

  **Mailboxes vs. TLM/FIFOs:** UVM’s `uvm_tlm_fifo` wraps a mailbox with analysis ports, reset control, and blocking/non-blocking APIs. Reach for it when you need producer/consumer plus broadcast behavior; stick with raw mailboxes for lightweight handshakes.

  **One-to-one only:** Mailboxes always deliver each message to a single consumer. When you need broadcast semantics, rely on [analysis ports](/curriculum/T2_Intermediate/I-UVM-2_Building_TB/index#monitors-scoreboards-and-the-analysis-fabric) or register callbacks.

  ## Quiz

  <Quiz questions={[
    {
      question: "What happens when `get()` is called on an empty mailbox?",
      answers: [
        { text: "It returns immediately with a default value", correct: false },
        { text: "It blocks until an item is available", correct: true },
        { text: "It deletes the mailbox", correct: false },
        { text: "It throws a runtime error", correct: false }
      ],
      explanation: "`get()` blocks the calling process until data is present in the mailbox."
    }
  ]} />

  <div className="mt-8">
    <InterviewQuestionPlayground
      question="What is the potential danger of instantiating a mailbox with `mbx = new()` (no arguments) when passing transactions from a fast generator thread to a slow driver thread?"
      options={[
        { text: "It causes a syntax error because depth cannot be left unspecified.", isCorrect: false, feedback: "Leaving it empty creates an unbounded mailbox." },
        { text: "It causes the driver thread to lock up waiting for a start signal.", isCorrect: false, feedback: "A driver reading from an unbounded mailbox still blocks if empty, but that's normal." },
        { text: "The generator will run infinitely far ahead, exhausting simulator memory with queued objects.", isCorrect: true, feedback: "Correct! An unbounded block never blocks the `put()`. If the consumer is slower than the producer, the queue grows infinitely. You should always use bounded mailboxes `new(DEPTH)` to create backpressure on the producer." },
        { text: "The mailbox will default to a depth of 1.", isCorrect: false, feedback: "It defaults to unbounded (infinite)." }
      ]}
    />
  </div>

</InfoPage>
