import { InfoPage } from "@/components/templates/InfoPage";
import { Quiz, InteractiveCode, InterviewQuestionPlayground } from "@/components/ui";

export const metadata = {
  title: "Semaphores | Advanced SystemVerilog for Verification",
  description: "Control access to shared resources using semaphore keys.",
};

<InfoPage
  title="Semaphores"
  sv_concept_tags={["semaphores"]}
>

  ## Level 1: The Big Idea
  *IEEE 1800-2023, Clause 15.3: Semaphores*

  A **semaphore** is like a set of keys. Processes must take a key (`get`) before using a shared resource and return it (`put`) when done. If no keys are available, the process waits.

  ## Level 2: Practical Usage

  ### Getting and Putting Keys

  -   `semaphore sem = new(1);` creates a semaphore with one key.
  -   `sem.get(1);` acquires a key (blocks if none are free).
  -   `sem.put(1);` releases a key.
  -   `sem.try_get(1);` attempts to get a key without blocking.

  <InteractiveCode>
  ```systemverilog
  semaphore bus_sem = new(1);

  task master(string name);
    bus_sem.get(1);        // wait for access
    $display("%s using bus at %0t", name, $time);
    #10;
    bus_sem.put(1);        // release
  endtask

  initial begin
    fork
      master("A");
      master("B");
    join
  end
  ```
  </InteractiveCode>

  ## Level 3: Expert Insights

  **Resource Pools:** Use semaphores with more than one key to model pools like DMA channels or memory ports.

  **Fairness:** Combining `try_get` with random delays can prevent starvation in heavily contended systems.

  **Coordinating Random Stimulus:** When multiple threads generate randomized transactions, semaphores ensure only a safe number run concurrently. For more on stimulus generation, revisit [Constrained Randomization](/curriculum/T2_Intermediate/I-SV-2_Constrained_Randomization).

  ## Quiz

  <Quiz questions={[
    {
      question: "Which method acquires a semaphore key without blocking?",
      answers: [
        { text: "`get`", correct: false },
        { text: "`put`", correct: false },
        { text: "`try_get`", correct: true },
        { text: "`wait`", correct: false }
      ],
      explanation: "`try_get` attempts to get keys and returns immediately if none are available."
    }
  ]} />

  <div className="mt-8">
    <InterviewQuestionPlayground
      question="A junior engineer complains that their testbench hangs forever. They are using a semaphore to guard a shared memory bus: `bus_sem.get(1); write_to_bus(); bus_sem.put(1);`. What is the most likely way this code can cause a deadlock?"
      options={[
        { text: "There is no issue; `get()` and `put()` handles queuing automatically.", isCorrect: false, feedback: "Under normal conditions, yes, but what if something interrupts the flow between the get and the put?" },
        { text: "The `write_to_bus()` task threw a fatal error, crashing the simulator.", isCorrect: false, feedback: "A fatal error stops simulation, it doesn't cause a hang/deadlock." },
        { text: "SystemVerilog semaphores are not thread-safe.", isCorrect: false, feedback: "They are specifically designed to be thread-safe built-in primitives." },
        { text: "The `write_to_bus()` task contains a thread-killing statement (like `disable`) or throws an unhandled exception before reaching the `put(1)` statement.", isCorrect: true, feedback: "Correct! The 'lost key' problem. If a thread dies, errors out, or is explicitly disabled via `disable fork` while holding a semaphore key, the key is never returned. All other threads waiting for that bus will hang forever." }
      ]}
    />
  </div>

</InfoPage>

