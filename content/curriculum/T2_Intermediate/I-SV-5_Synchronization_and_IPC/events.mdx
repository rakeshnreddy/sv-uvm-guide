import { InfoPage } from "@/components/templates/InfoPage";
import { Quiz, InteractiveCode, InterviewQuestionPlayground } from "@/components/ui";

export const metadata = {
  title: "Events | Advanced SystemVerilog for Verification",
  description: "Synchronize parallel processes with SystemVerilog events.",
};

<InfoPage
  title="Events"
  sv_concept_tags={["events"]}
>

  ## Level 1: The Big Idea
  *IEEE 1800-2023, Clause 15.5: Events*

  An **event** is a simple synchronization object. One process can signal an event, and another can wait for it. It's like ringing a doorbell and waiting for someone to answer.

  ## Level 2: Practical Usage

  ### Declaring and Triggering

  -   Declare an event: `event done;`
  -   Trigger once: `-> done;` (all waiters run in the current timestep).
  -   Trigger with persistence: `->> done;` (waiters that start later in the same timestep still wake up).
  -   Wait for it: `@done;` or, if you need to poll, `wait(done.triggered);`.

  <InteractiveCode>
  ```systemverilog
  event start, done;

  initial begin
    // Producer thread
    repeat (3) begin
      #10 -> start;          // fire the start event
      @done;                 // wait for acknowledgement
    end
  end

  initial begin
    // Consumer thread
    forever begin
      @start;
      $display("Start seen at %0t", $time);
      #2 ->> done;           // acknowledge with persistence
    end
  end

  initial begin
    // Late listener still sees the persistent trigger
    wait(done.triggered);
    $display("First completion observed at %0t", $time);
  end
  ```
  </InteractiveCode>

  Events often coordinate randomized stimulus or monitor actions. Review [Constrained Randomization](/curriculum/T2_Intermediate/I-SV-2_Constrained_Randomization) to see how events can trigger new random transactions.

  ## Level 3: Expert Insights

  **Multiple triggers & lost pulses:** Native events do not queue requests. If you trigger with `->` before anyone is waiting, the pulse is gone. Use `->>` or keep a `done_seen` flag to avoid races.

  **Ordering constraints:** `wait_order(e1, e2)` (or the array form) asserts that events arrive in a given sequenceâ€”perfect for handshake protocols. Pair with assertions so violations show up in logs.

  **Leveraging `triggered`:** The built-in `event.triggered` bit goes high for the remainder of the timestep after a trigger. Combine it with `wait(event.triggered)` when you need to poll or drive scoreboard state machines.

  **Bridging to UVM:** `uvm_event` adds `wait_on()`, `wait_off()`, callbacks, and a `trigger_cnt`. Manage them through an `uvm_event_pool` so components can look up events by name without hard-coded handles. See [analysis components](/curriculum/T2_Intermediate/I-UVM-2_Building_TB/index#monitors-scoreboards-and-the-analysis-fabric) for how that integrates with monitors.

  ## Quiz

  <Quiz questions={[
    {
      question: "Which statement waits for event `go` to be triggered?",
      answers: [
        { text: "`-> go;`", correct: false },
        { text: "`@go;`", correct: true },
        { text: "`wait(go);`", correct: false },
        { text: "`disable go;`", correct: false }
      ],
      explanation: "`@go;` suspends the process until the event `go` is triggered."
    }
  ]} />

  <div className="mt-8">
    <InterviewQuestionPlayground
      question="A junior engineer writes two threads that start at time 0. Thread A executes `-> done;` and Thread B executes `@done;`. Thread B never unblocks. Why?"
      options={[
        { text: "Thread B must use `wait(done.triggered)` instead of `@done`.", isCorrect: false, feedback: "While `wait(done.triggered)` is safer, `@done` works if the wait happens BEFORE the trigger." },
        { text: "SystemVerilog events are local to the thread that creates them.", isCorrect: false, feedback: "Events are shared as long as both threads have visibility." },
        { text: "There is a zero-delay race condition. Thread A fired the event before Thread B reached the `@done` statement.", isCorrect: true, feedback: "Correct! If Thread A executes `->` before Thread B executes `@`, the event is 'lost'. This is why `->>` (non-blocking trigger) or `wait(done.triggered)` are preferred for zero-delay synchronization." },
        { text: "You cannot trigger an event at time 0.", isCorrect: false, feedback: "You can trigger events at any time." }
      ]}
    />
  </div>

</InfoPage>
