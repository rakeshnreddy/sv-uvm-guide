---
title: "I-SV-2: Constrained Randomization"
description: "Guide SystemVerilog's random stimulus with constraints, distributions, and inline tweaks to uncover corner-case bugs fast."
flashcards: "I-SV-2_Constrained_Randomization"
conceptLinking: false
---

import { InteractiveCode, Quiz } from '@/components/ui';

## Quick Take
- **What it is:** Constrained randomization lets you describe legal stimulus space with constraints so the solver generates thousands of intelligent variations automatically.
- **Why it matters:** Directed tests miss combinations; constrained random exploration paired with coverage exposes subtle corner cases and shrinks bug escape risk.
- **The Analogy:** It’s a programmable dice tower—tell it “only roll sums of 7 where die1 > die2,” and it feeds you every valid combo, not noise.

> **Tip:** Always pair constraints with coverage goals—random stimulus without measurement is aimless wandering.

## Build Your Mental Model
### Smart Stimulus Blueprint
<div className="glass-card glow-border my-8 px-6 py-8">
  <Image
    src="/visuals/randomization-blueprint.svg"
    alt="Diagram showing constraints feeding the random solver and producing legal transactions"
    width={720}
    height={360}
    sizes="(min-width: 1024px) 720px, 100vw"
    className="w-full"
  />
</div>

### Random Variables & Constraint Blocks
<InteractiveCode>
```systemverilog
class Packet;
  rand bit        is_read;
  rand bit [7:0]  length;
  rand bit [3:0]  opcode;
  rand byte       payload[];

  // Hard constraints define legal space
  constraint legal_length { length inside {[8:16], [64:96]}; }
  constraint payload_size { payload.size() == length; }

  // Distribution biases interesting cases
  constraint opcode_dist {
    opcode dist { 4'h0 := 10, [4'h1:4'h3] :/ 70, [4'h8:4'hF] :/ 20 };
  }

  // Relational constraint
  constraint read_defaults { if (is_read) length == 8; }

  function void post_randomize();
    $display("Packet(opcode=%0h len=%0d is_read=%0b)", opcode, length, is_read);
  endfunction
endclass

program demo;
  initial begin
    Packet pkt = new();
    repeat (3) begin
      if (!pkt.randomize())
        $fatal("Randomization failed");
    end
    // Inline constraint for targeted scenario
    void'(pkt.randomize() with { opcode == 4'hF; length == 16; });
  end
endprogram
```
</InteractiveCode>

### Visual Explorer
Dive deeper with the interactive explorer under
[`Practice → Visualizations → Randomization Explorer`](/practice/visualizations/randomization-explorer).
There you can tweak constraints live and watch solver outcomes update in real time.

### Constraint Patterns
- **Relational:** guard dependent variables with `if...else`.
- **Ordering:** `solve addr before data;` ensures solver picks address first.
- **Soft defaults:** `soft length == 32;` provides gentle defaults overridden by stricter constraints.

<InteractiveCode>
```systemverilog
class Config;
  rand bit is_secure;
  rand bit [1:0] burst_len;

  constraint burst_rules {
    soft burst_len == 2'b10;           // default burst = 4 beats
    if (is_secure) burst_len == 2'b01; // secure mode shortens bursts
  }

  // Tie-breaker: choose is_secure before burst
  solve is_secure before burst_len;
endclass
```
</InteractiveCode>

## Make It Work
1. **Model legality:** Translate protocol rules into constraints—illegal stimulus wastes regression time.
2. **Layer distributions:** Bias randomization toward risky scenarios (e.g., error opcodes) while still covering the space.
3. **Validate success:** Always check `randomize()` return value and log failures with an actionable message.
4. **Measure:** Pair random stimulus with functional coverage to confirm constraint intent is met.

**Checklist before moving on:**
- [ ] You can explain the difference between `rand` and `randc`.
- [ ] You can write relational and distribution constraints that reflect spec rules.
- [ ] You confirm randomize success and understand how to debug failures.

## Push Further
- Use pre/post-randomize hooks to enforce computed constraints (e.g., dependent arrays).
- Create constraint mode toggles (`constraint_mode(0)`) for reusable classes in different scenarios.
- Explore `randomize() with` blocks in sequences to target coverage holes without new classes.

## Practice & Reinforce
- Flashcards – Drill keyword meaning and solver behaviors.
- Quiz – Complete the constrained-random knowledge check below.
- Lab prompt – Build a transaction with soft defaults; toggle them via inline constraints and observe coverage hits.
- Visual notebook – Sketch how your constraints map to testplan features and coverage bins.

## References & Next Topics
- IEEE 1800-2017 §18 “Randomization and Constraints.”
- Doulos: “SystemVerilog Constraints Tutorial.”
- Siemens Verification Academy: “Constraint Solving Tips.”
- Next: [`/curriculum/T2_Intermediate/I-SV-3_Functional_Coverage`](../I-SV-3_Functional_Coverage/).

<Quiz
  questions={[
    {
      question: 'How does `randc` differ from `rand`?',
      answers: [
        { text: '`randc` cycles through every value in a random order before repeating.', correct: true },
        { text: '`randc` cannot be constrained.', correct: false },
        { text: '`rand` is only for integers.', correct: false },
        { text: '`randc` is slower and should be avoided.', correct: false }
      ],
      explanation:
        '`randc` is ideal for finite sets such as opcodes—you get permutation coverage before repeats.'
    },
    {
      question: 'What happens when constraints contradict each other?',
      answers: [
        { text: 'The solver picks one at random.', correct: false },
        { text: 'Randomization fails (`randomize()` returns 0).', correct: true },
        { text: 'The simulator ignores constraints.', correct: false },
        { text: 'The variables revert to defaults.', correct: false }
      ],
      explanation:
        'Over-constrained classes return 0 from `randomize()`—always check and handle the failure path.'
    },
    {
      question: 'Why use `soft` constraints?',
      answers: [
        { text: 'They are required for polymorphism.', correct: false },
        { text: 'They provide defaults that can be overridden by stronger constraints or inline `with` clauses.', correct: true },
        { text: 'They randomize faster than hard constraints.', correct: false },
        { text: 'They are only for randc variables.', correct: false }
      ],
      explanation:
        '`soft` constraints establish gentle defaults—great for shared classes reused across many scenarios.'
    }
  ]}
/>
