---
title: "I-SV-3A: Functional Coverage Fundamentals"
description: "Model verification intent with covergroups, coverpoints, and crosses to prove you've exercised every critical scenario."
flashcards: "I-SV-3A_Functional_Coverage_Fundamentals"
---

import { InteractiveCode, Quiz, InterviewQuestionPlayground } from '@/components/ui';
import CoverageAnalyzer from '@/components/animations/CoverageAnalyzer';
import dynamic from 'next/dynamic';

const Coverage3D = dynamic(() => import('@/components/curriculum/interactives/3d/Coverage3D'), { ssr: false });

## Quick Take
- **What it is:** Functional coverage captures the design scenarios you *intend* to test, recording hits whenever stimulus exercises them.
- **Why it matters:** Code coverage only says which lines executed; functional coverage maps directly to the verification plan, answering “Are we done yet?”
- **The Analogy:** Imagine a mission checklist—every time a specific combination happens (burst write, secure mode, minimal latency), you tick a box. Unticked boxes reveal coverage holes.

> **Reminder:** Coverage is actionable only when tied to a plan. Define meaningful bins, not just random value ranges.
> *SystemVerilog Functional Coverage is formally defined in **IEEE 1800-2023, Clause 19**.*

## Build Your Mental Model
### Coverage Blueprint
<div className="glass-card glow-border my-8 px-6 py-8">
  <Image
    src="/visuals/coverage-blueprint.svg"
    alt="Diagram showing stimulus feeding coverpoints, crosses, and coverage reports"
    width={720}
    height={360}
    sizes="(min-width: 1024px) 720px, 100vw"
    className="w-full"
  />
</div>

### Core Constructs in Action
<InteractiveCode>
```systemverilog
interface bus_if (input logic clk);
  logic [3:0] addr;
  logic [7:0] data;
  logic       rw;
  logic       valid;

  covergroup cg_bus @(posedge clk);
    // Address coverage
    cp_addr: coverpoint addr {
      bins low   = {[0:3]};
      bins high  = {[12:15]};
      bins mid[] = {[4:11]};
    }

    // Data sampled only on valid writes
    cp_data: coverpoint data iff (valid && rw) {
      bins zero = {8'h00};
      bins full = {8'hFF};
      bins others = default;
    }

    // Read vs write
    cp_rw: coverpoint rw;

    // Cross coverage for interaction
    addr_x_rw: cross cp_addr, cp_rw {
      ignore_bins write_low = binsof(cp_addr.low) && binsof(cp_rw) intersect {1};
    }
  endgroup

  cg_bus bus_cov = new();
endinterface
```
</InteractiveCode>

### Visualize & Iterate
Coverage is part of a loop: randomize → measure → analyze → refine. Use coverage reports, or in this case, the analyzer, to spot unhit bins.

<CoverageAnalyzer />

<Coverage3D />

### Beyond Basics
- **Illegal bins:** flag scenarios that must never occur—ideal for catching spec violations early.
- **Soft bins:** `ignore_bins` drop uninteresting combinations from metrics.
- **Crosses:** verify feature interactions (e.g., command × power mode).

<InteractiveCode>
```systemverilog
class Packet;
  rand bit [1:0] kind;
  rand bit       has_crc;
endclass

class PacketCoverage;
  covergroup cg with function sample(Packet p);
    kind_cp: coverpoint p.kind;
    crc_cp : coverpoint p.has_crc;

    kind_crc: cross kind_cp, crc_cp {
      illegal_bins bad_combo = binsof(kind_cp) intersect {2} &&
                               binsof(crc_cp) intersect {0};
    }
  endgroup

  function new();
    cg = new();
  endfunction
endclass
```
</InteractiveCode>

## Make It Work
1. **Forecast scenarios:** Derive coverpoints and crosses directly from the verification plan features.
2. **Sample intelligently:** Place covergroups where the data is observable (monitors, subscribers) and use `iff` for valid sampling.
3. **Review reports:** After regressions, inspect bin hit counts; prioritize holes that map to high-risk features.
4. **Close the loop:** Adjust stimulus (constraints, directed sequences) to target unhit bins, rerun, and iterate.

**Checklist before moving on:**
- [ ] You can author a covergroup with meaningful bins and documented intent.
- [ ] You know when to add `ignore_bins` or `illegal_bins`.
- [ ] You can explain how cross coverage catches interaction bugs.

## Push Further
- Integrate coverage goals into automation (e.g., stop regression when goals met).
- Use weighted coverage (`option.goal`) to focus on critical bins first.
- Tie coverage data to dashboards that show closure status by feature.

## Practice & Reinforce
- Flashcards – Solidify terminology for coverpoints, bins, crosses.
- Quiz – Complete the coverage fundamentals check below.
- Mini-lab – Build a covergroup for a custom protocol, add an illegal bin, and observe simulator behavior.
- Visual notebook – Sketch how coverage bins map to your plan and track holes over time.

## Deep Dives in this Track
- [Coverage Options and Sampling](./coverage-options)

## References & Next Topics
- **IEEE 1800-2023, Clause 19:** Functional coverage.
- Next: [`/curriculum/T2_Intermediate/I-SV-3B_Advanced_Functional_Coverage`](../I-SV-3B_Advanced_Functional_Coverage/).

<Quiz
  questions={[
    {
      question: 'When would you use `illegal_bins`?',
      answers: [
        { text: 'To gain code coverage credit for a scenario', correct: false },
        { text: 'To flag that a scenario must never occur; hitting it raises an error', correct: true },
        { text: 'To exclude scenarios from coverage metrics', correct: false },
        { text: 'To define default bins automatically', correct: false }
      ],
      explanation:
        'Illegal bins terminate simulation if sampled, catching forbidden combinations as soon as they occur.'
    },
    {
      question: 'Why add cross coverage?',
      answers: [
        { text: 'To speed up sampling', correct: false },
        { text: 'To verify interactions between features defined by multiple coverpoints', correct: true },
        { text: 'To reduce the number of bins required', correct: false },
        { text: 'To convert code coverage to functional coverage', correct: false }
      ],
      explanation:
        'Cross coverage ensures that combinations like (command type × power mode) have been observed, not just each feature independently.'
    }
  ]}
/>

<div className="mt-8">
  <InterviewQuestionPlayground
    question="You notice a specific coverage bin for a rare error condition remains at 0% hit rate in your regression. What is the CORRECT first step to take?"
    options={[
      { text: "Write a directed test to hit the error condition.", isCorrect: false, feedback: "While this might work, it masks a potential bug if the random stimulus *should* have hit it." },
      { text: "Use `ignore_bins` to exclude it, since it's a rare error and you only care about normal operation.", isCorrect: false, feedback: "Error conditions are often the most critical parts to verify!" },
      { text: "Check whether the stimulus constraints actually allow the error condition to be generated.", isCorrect: true, feedback: "Correct! The number one reason a valid bin is empty is that the constraints preventing it are too tight, or no test sequences exist that target that operational mode." },
      { text: "Increase `option.auto_bin_max` to force the simulator to discover the bin.", isCorrect: false, feedback: "Auto bins just automatically divvy up variables into groups; they don't magically make the stimulus hit new areas." }
    ]}
  />
</div>
