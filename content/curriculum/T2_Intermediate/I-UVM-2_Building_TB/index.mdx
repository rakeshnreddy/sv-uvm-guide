---
title: "I-UVM-2: Building a UVM Testbench: Components & Hierarchy"
description: "Assemble a layered UVM environment—agents, drivers, sequencers, monitors, and scoreboards—and know how data flows between them."
flashcards: "I-UVM-2_Building_TB"
---

import { InteractiveCode, Quiz } from '@/components/ui';
import AnimatedUvmTestbenchDiagram from '@/components/diagrams/AnimatedUvmTestbenchDiagram';
import { AnimatedUvmSequenceDriverHandshakeDiagram } from '@/components/diagrams/AnimatedUvmSequenceDriverHandshakeDiagram';

## Quick Take
- **What it is:** The UVM testbench is a layered environment where agents wrap protocol knowledge, sequencers feed intent, drivers wiggle pins, monitors observe, and scoreboards compare.
- **Why it matters:** Using the standard hierarchy keeps big projects consistent—teams can plug in reusable agents, swap drivers, and share scoreboards without rewiring.
- **The Analogy:** Think of a city transit system—sequencers post routes, drivers operate buses, monitors collect rider data, and the scoreboard is central dispatch verifying riders reach their stops.

> **Retention Hook:** Repeat “agent = driver + sequencer + monitor” whenever you sketch an interface block.

## Build Your Mental Model
### Layered Environment Snapshot
With objects vs. components under your belt, zoom out to the full environment: tests configure and launch an `uvm_env`, the environment instantiates agents and scoreboards, and each agent encapsulates everything needed for a single DUT interface.

<div className="my-8">
  <div className="glass-card glow-border mx-auto max-w-4xl overflow-hidden border border-white/10 bg-[var(--blueprint-glass)] p-6">
    <AnimatedUvmTestbenchDiagram />
  </div>
</div>

<div className="my-6 rounded-3xl border border-white/10 bg-white/5 p-6 text-sm text-[rgba(230,241,255,0.8)] backdrop-blur">
  <h3 className="text-lg font-semibold text-white">Need the interactive view?</h3>
  <p className="mt-3 text-sm text-[rgba(230,241,255,0.75)]">
    Launch the <strong>UVM Testbench Visualizer</strong> under
    <code className="mx-1">Practice → Visualizations → UVM Architecture</code> to hover each
    component, trace stimulus routing, and see the factory substitution points animated.
  </p>
  <p className="mt-4 text-xs uppercase tracking-[0.25em] text-[rgba(230,241,255,0.55)]">
    This lesson keeps the focus on the architecture narrative; use the viz as a companion tool when
    you build your own environment.
  </p>
</div>

### Tests Configure the Run
UVM tests do the orchestration work before control flows into the environment hierarchy.

- Set factory overrides and configuration knobs so environments and agents build the right variants.
- Choose which default or virtual sequences kick off on each sequencer.
- Seed analysis subscribers or scoreboard handles that need to be shared across the hierarchy.

### Agents as the Unit of Reuse
An `uvm_agent` packages the sequencer, driver, and monitor for one interface. Flip `is_active` to control behavior:
- **Active agents** generate stimulus—driver + sequencer come alive.
- **Passive agents** listen only—instantiate just the monitor to tap traffic non-invasively.

> **Interface Tip:** Keep agents self-contained by binding them to a SystemVerilog `interface` handle (via the config DB). Drivers dereference a virtual interface; monitors sample via the same handle. That separation is what lets the agent drop into any testbench without rewiring pins.

### Sequencer ↔ Driver Handshake
Sequencers manage high-level intent, drivers translate that intent into pin-wiggles. Their protocol keeps stimulus moving—step through the handshake timeline below.

<AnimatedUvmSequenceDriverHandshakeDiagram />

The code mirrors the animation. Watch how the driver blocks in `get_next_item()` until the sequence hands off the item, and how everything releases only after `item_done()`:

```systemverilog
// Driver requesting transactions from the sequencer
task my_driver::run_phase(uvm_phase phase);
  forever begin
    seq_item_port.get_next_item(req);
    drive_transfer(req);
    seq_item_port.item_done();
  end
endtask
```

### Monitors, Scoreboards, and the Analysis Fabric
Monitors reconstruct transactions without touching pins, analysis ports broadcast those transactions, and subscribers (scoreboards, coverage collectors) consume them.

- **Monitor = security camera.** It quietly records bus activity and publishes polished transactions.
- **Scoreboard = security guard.** It watches the monitor feed and compares reality to the rules defined by your reference model.
- **Coverage collector = data analyst.** It taps the same feed to measure which scenarios your stimulus actually exercised.

<InteractiveCode>
```systemverilog
class my_agent extends uvm_agent;
  `uvm_component_utils(my_agent)
  my_driver d;
  my_sequencer s;
  my_monitor m;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    if (is_active == UVM_ACTIVE) begin
      d = my_driver::type_id::create("d", this);
      s = my_sequencer::type_id::create("s", this);
    end
    m = my_monitor::type_id::create("m", this);
  endfunction

  function void connect_phase(uvm_phase phase);
    if (is_active == UVM_ACTIVE) begin
      d.seq_item_port.connect(s.seq_item_export);
    end
  endfunction
endclass

class my_env extends uvm_env;
  `uvm_component_utils(my_env)
  my_agent a;
  my_scoreboard scb;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    a = my_agent::type_id::create("a", this);
    scb = my_scoreboard::type_id::create("scb", this);
  endfunction

  function void connect_phase(uvm_phase phase);
    a.m.ap.connect(scb.analysis_export);
  endfunction
endclass
```
</InteractiveCode>

### TLM Is Your Wiring Harness
Transaction-Level Modeling (TLM) abstracts communication so components move data instead of toggling pins.
- **Ports** send transactions (like mail slots).
- **Exports/Imps** receive them (the mailboxes).
- **Analysis ports** broadcast to many listeners.

```systemverilog
// Producer/consumer via blocking put
uvm_blocking_put_port #(my_txn) put_port;
uvm_blocking_put_imp  #(my_txn, my_consumer) put_export;

// Analysis fabric for monitors and subscribers
uvm_analysis_port #(my_txn) ap;
uvm_analysis_imp  #(my_txn, my_scoreboard) analysis_export;
```

- Use **`put`/`get` ports** for point-to-point producer ↔ consumer flows.
- Use the **sequencer handshake** (`get_next_item`/`item_done`) for stimulus delivery.
- Use **analysis ports** when one monitor needs to fan out transactions to scoreboards, subscribers, and coverage collectors simultaneously.

Review the [mailbox primer](../I-SV-3_Functional_Coverage/mailboxes) if the terminology feels rusty.

<div className="my-6 rounded-2xl border border-muted bg-muted/40 p-6">
  <h3 className="text-lg font-semibold">Component Relationship Drill</h3>
  <p className="mt-2 text-sm text-muted-foreground">
    Recreate the hierarchy in the <strong>UVM Component Relationships</strong> visual (also in the
    Practice → Visualizations gallery). Drag agents, sequencers, drivers, and monitors into place to
    reinforce which ports connect where.
  </p>
</div>

## Make It Work
1. **Map interfaces to agents:** List every DUT interface and decide which need active vs. passive agents.
2. **Instantiate via the factory:** In `build_phase`, call `::type_id::create` for each driver, sequencer, monitor, and scoreboard so overrides and configuration stay viable.
3. **Wire the data paths:** Connect sequencer ↔ driver TLM ports and hook monitor analysis ports into scoreboards and coverage collectors.
4. **Verify the topology:** Run `uvm_top.print_topology()`—if an agent or connection is missing, fix it before writing sequences.

**Checklist before moving on:**
- [ ] You can sketch the agent/driver/sequencer/monitor relationships from memory.
- [ ] You know how to flip an agent between active and passive using configuration.
- [ ] You can trace which component owns each analysis port or export.

## Push Further
- **Coordinate with virtual sequencers:** Expose child sequencer handles and create a parent `uvm_virtual_sequencer` so complex SoCs can script cross-agent stimulus without fragile global handles.
- **Compose environments:** Build parent envs that instantiate multiple protocol agents and share a scoreboard.
- **Instrument coverage collectors:** Subscribe coverage components to the same analysis ports the scoreboard uses.
- **Standardize config knobs:** Centralize agent configuration (passive mode, virtual interfaces) in the environment's `build_phase`.
- **Regression trick:** Keep shallow passive agents for busses you only monitor—less connection code, more reuse.

## Practice & Reinforce
- Flashcards – Drill the agent makeup, handshake, and analysis fabric vocabulary.
- Micro-lab – Convert an agent from active to passive and confirm the driver stops requesting items.
- Architecture sketch – Draw a dual-agent environment and label each TLM connection.
- Interactive wiring drill – Use the [Scoreboard Connector exercise](/exercises/scoreboard-connector) to practice wiring analysis ports and `analysis_imp`s.
- Quiz – Lock in the fundamentals below.

<Quiz questions={[
    {
      "question": "Which UVM component is responsible for receiving transactions from a monitor and comparing them against expected results?",
      "answers": [
        {"text": "uvm_driver", "correct": false},
        {"text": "uvm_sequencer", "correct": false},
        {"text": "uvm_scoreboard", "correct": true},
        {"text": "uvm_agent", "correct": false}
      ],
      "explanation": "The scoreboard's primary role is self-checking. It typically subscribes to data from one or more monitors and contains logic to compare actual DUT output against a golden reference or an expected model."
    },
    {
      "question": "What is the key benefit of separating the sequencer and the driver?",
      "answers": [
        {"text": "It allows the driver to run faster.", "correct": false},
        {"text": "It decouples the abstract test scenario (what to send) from the physical signaling (how to send it), which greatly enhances reusability.", "correct": true},
        {"text": "It is required by the UVM base classes.", "correct": false},
        {"text": "It simplifies the monitor's job.", "correct": false}
      ],
      "explanation": "This separation is a cornerstone of UVM methodology. You can write a complex sequence once and reuse it with different drivers for different physical interfaces without touching the sequence code."
    }
  ]} />

## References & Next Topics
- Accellera, *UVM Class Reference* (uvm_agent, uvm_monitor, analysis ports).
- Verification Academy, *UVM Testbench Architecture Cookbook*.
- Next: [/curriculum/T2_Intermediate/I-UVM-3_Sequences](../I-UVM-3_Sequences/index).
