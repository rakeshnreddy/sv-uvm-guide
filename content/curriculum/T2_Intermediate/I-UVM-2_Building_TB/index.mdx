---
title: "I-UVM-2: Building a UVM Testbench: Components & Hierarchy"
description: "Assemble a layered UVM environment—agents, drivers, sequencers, monitors, and scoreboards—and know how data flows between them."
flashcards: "I-UVM-2_Building_TB"
---

import { InteractiveCode, Quiz } from '@/components/ui';
import AnimatedUvmTestbenchDiagram from '@/components/diagrams/AnimatedUvmTestbenchDiagram';
import UvmComponentRelationshipVisualizer from '@/components/diagrams/UvmComponentRelationshipVisualizer';
import { AnimatedUvmSequenceDriverHandshakeDiagram } from '@/components/diagrams/AnimatedUvmSequenceDriverHandshakeDiagram';

## Quick Take
- **What it is:** The UVM testbench is a layered environment where agents wrap protocol knowledge, sequencers feed intent, drivers wiggle pins, monitors observe, and scoreboards compare.
- **Why it matters:** Using the standard hierarchy keeps big projects consistent—teams can plug in reusable agents, swap drivers, and share scoreboards without rewiring.
- **The Analogy:** Think of a city transit system—sequencers post routes, drivers operate buses, monitors collect rider data, and the scoreboard is central dispatch verifying riders reach their stops.

> **Retention Hook:** Repeat “agent = driver + sequencer + monitor” whenever you sketch an interface block.

## Build Your Mental Model
### Layered Environment Snapshot
With objects vs. components under your belt, zoom out to the full environment: tests configure and launch an `uvm_env`, the environment instantiates agents and scoreboards, and each agent encapsulates everything needed for a single DUT interface.

<div className="my-8">
  <div className="glass-card glow-border mx-auto max-w-4xl overflow-hidden border border-white/10 bg-[var(--blueprint-glass)] p-6">
    <AnimatedUvmTestbenchDiagram />
  </div>
</div>

### Agents as the Unit of Reuse
An `uvm_agent` packages the sequencer, driver, and monitor for one interface. Flip `is_active` to control behavior:
- **Active agents** generate stimulus—driver + sequencer come alive.
- **Passive agents** listen only—instantiate just the monitor to tap traffic non-invasively.

### Sequencer ↔ Driver Handshake
Sequencers manage high-level intent, drivers translate that intent into pin-wiggles. Their protocol keeps stimulus moving—step through the handshake timeline below.

<AnimatedUvmSequenceDriverHandshakeDiagram />

The code mirrors the animation. Watch how the driver blocks in `get_next_item()` until the sequence hands off the item, and how everything releases only after `item_done()`:

```systemverilog
// Driver requesting transactions from the sequencer
task my_driver::run_phase(uvm_phase phase);
  forever begin
    seq_item_port.get_next_item(req);
    drive_transfer(req);
    seq_item_port.item_done();
  end
endtask
```

### Monitors, Scoreboards, and the Analysis Fabric
Monitors reconstruct transactions without touching pins, analysis ports broadcast those transactions, and subscribers (scoreboards, coverage collectors) consume them.

<InteractiveCode>
```systemverilog
class my_agent extends uvm_agent;
  `uvm_component_utils(my_agent)
  my_driver d;
  my_sequencer s;
  my_monitor m;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    if (is_active == UVM_ACTIVE) begin
      d = my_driver::type_id::create("d", this);
      s = my_sequencer::type_id::create("s", this);
    end
    m = my_monitor::type_id::create("m", this);
  endfunction

  function void connect_phase(uvm_phase phase);
    if (is_active == UVM_ACTIVE) begin
      d.seq_item_port.connect(s.seq_item_export);
    end
  endfunction
endclass

class my_env extends uvm_env;
  `uvm_component_utils(my_env)
  my_agent a;
  my_scoreboard scb;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    a = my_agent::type_id::create("a", this);
    scb = my_scoreboard::type_id::create("scb", this);
  endfunction

  function void connect_phase(uvm_phase phase);
    a.m.ap.connect(scb.analysis_export);
  endfunction
endclass
```
</InteractiveCode>

### TLM Is Your Wiring Harness
Transaction-Level Modeling (TLM) abstracts communication so components move data instead of toggling pins.
- **Ports** send transactions (like mail slots).
- **Exports/Imps** receive them (the mailboxes).
- **Analysis ports** broadcast to many listeners.

Review the [mailbox primer](../I-SV-3_Functional_Coverage/mailboxes) if the terminology feels rusty.

<UvmComponentRelationshipVisualizer />

## Make It Work
1. **Map interfaces to agents:** List every DUT interface and decide which need active vs. passive agents.
2. **Instantiate via the factory:** In `build_phase`, call `::type_id::create` for each driver, sequencer, monitor, and scoreboard so overrides and configuration stay viable.
3. **Wire the data paths:** Connect sequencer ↔ driver TLM ports and hook monitor analysis ports into scoreboards and coverage collectors.
4. **Verify the topology:** Run `uvm_top.print_topology()`—if an agent or connection is missing, fix it before writing sequences.

**Checklist before moving on:**
- [ ] You can sketch the agent/driver/sequencer/monitor relationships from memory.
- [ ] You know how to flip an agent between active and passive using configuration.
- [ ] You can trace which component owns each analysis port or export.

## Push Further
- **Compose environments:** Build parent envs that instantiate multiple protocol agents and share a scoreboard.
- **Instrument coverage collectors:** Subscribe coverage components to the same analysis ports the scoreboard uses.
- **Standardize config knobs:** Centralize agent configuration (passive mode, virtual interfaces) in the environment's `build_phase`.
- **Regression trick:** Keep shallow passive agents for busses you only monitor—less connection code, more reuse.

## Practice & Reinforce
- Flashcards – Drill the agent makeup, handshake, and analysis fabric vocabulary.
- Micro-lab – Convert an agent from active to passive and confirm the driver stops requesting items.
- Architecture sketch – Draw a dual-agent environment and label each TLM connection.
- Quiz – Lock in the fundamentals below.

<Quiz questions={[
    {
      "question": "Which UVM component is responsible for receiving transactions from a monitor and comparing them against expected results?",
      "answers": [
        {"text": "uvm_driver", "correct": false},
        {"text": "uvm_sequencer", "correct": false},
        {"text": "uvm_scoreboard", "correct": true},
        {"text": "uvm_agent", "correct": false}
      ],
      "explanation": "The scoreboard's primary role is self-checking. It typically subscribes to data from one or more monitors and contains logic to compare actual DUT output against a golden reference or an expected model."
    },
    {
      "question": "What is the key benefit of separating the sequencer and the driver?",
      "answers": [
        {"text": "It allows the driver to run faster.", "correct": false},
        {"text": "It decouples the abstract test scenario (what to send) from the physical signaling (how to send it), which greatly enhances reusability.", "correct": true},
        {"text": "It is required by the UVM base classes.", "correct": false},
        {"text": "It simplifies the monitor's job.", "correct": false}
      ],
      "explanation": "This separation is a cornerstone of UVM methodology. You can write a complex sequence once and reuse it with different drivers for different physical interfaces without touching the sequence code."
    }
  ]} />

## References & Next Topics
- Accellera, *UVM Class Reference* (uvm_agent, uvm_monitor, analysis ports).
- Verification Academy, *UVM Testbench Architecture Cookbook*.
- Next: [/curriculum/T2_Intermediate/I-UVM-3_Sequences](../I-UVM-3_Sequences/index).
