---
title: "I-SV-2A: Constrained Randomization Fundamentals"
description: "Guide SystemVerilog's random stimulus with constraints, distributions, and inline tweaks to uncover corner-case bugs fast."
flashcards: "I-SV-2A_Constrained_Randomization_Fundamentals"
conceptLinking: false
---

import { InteractiveCode, Quiz, InterviewQuestionPlayground } from '@/components/ui';
import ConstraintSolverVisualizer from '@/components/curriculum/interactives/ConstraintSolverVisualizer';
import dynamic from 'next/dynamic';

const Constraint3D = dynamic(() => import('@/components/curriculum/interactives/3d/Constraint3D'), { ssr: false });

## Quick Take
- **What it is:** Constrained randomization lets you describe legal stimulus space with constraints so the solver generates thousands of intelligent variations automatically.
- **Why it matters:** Directed tests miss combinations; constrained random exploration paired with coverage exposes subtle corner cases and shrinks bug escape risk.
- **The Analogy:** It’s a programmable dice tower—tell it “only roll sums of 7 where die1 > die2,” and it feeds you every valid combo, not noise.

> **Tip:** Always pair constraints with coverage goals—random stimulus without measurement is aimless wandering.
> *SystemVerilog Constrained Randomization is formally defined in **IEEE 1800-2023, Clause 18**.*

## Build Your Mental Model
### Smart Stimulus Blueprint
<div className="glass-card glow-border my-8 px-6 py-8">
  <Image
    src="/visuals/randomization-blueprint.svg"
    alt="Diagram showing constraints feeding the random solver and producing legal transactions"
    width={720}
    height={360}
    sizes="(min-width: 1024px) 720px, 100vw"
    className="w-full"
  />
</div>

### Random Variables & Constraint Blocks
<InteractiveCode>
```systemverilog
class Packet;
  rand bit        is_read;
  rand bit [7:0]  length;
  rand bit [3:0]  opcode;
  rand byte       payload[];

  // Hard constraints define legal space
  constraint legal_length { length inside {[8:16], [64:96]}; }
  constraint payload_size { payload.size() == length; }

  // Distribution biases interesting cases
  constraint opcode_dist {
    opcode dist { 4'h0 := 10, [4'h1:4'h3] :/ 70, [4'h8:4'hF] :/ 20 };
  }

  // Relational constraint
  constraint read_defaults { if (is_read) length == 8; }

  function void post_randomize();
    $display("Packet(opcode=%0h len=%0d is_read=%0b)", opcode, length, is_read);
  endfunction
endclass

program demo;
  initial begin
    Packet pkt = new();
    repeat (3) begin
      if (!pkt.randomize())
        $fatal("Randomization failed");
    end
    // Inline constraint for targeted scenario
    void'(pkt.randomize() with { opcode == 4'hF; length == 16; });
  end
endprogram
```
</InteractiveCode>

### Visual Explorer
<ConstraintSolverVisualizer />

<Constraint3D />

### Constraint Patterns
- **Relational:** guard dependent variables with `if...else`.
- **Ordering:** `solve addr before data;` ensures solver picks address first.
- **Soft defaults:** `soft length == 32;` provides gentle defaults overridden by stricter constraints.

<InteractiveCode>
```systemverilog
class Config;
  rand bit is_secure;
  rand bit [1:0] burst_len;

  constraint burst_rules {
    soft burst_len == 2'b10;           // default burst = 4 beats
    if (is_secure) burst_len == 2'b01; // secure mode shortens bursts
  }

  // Tie-breaker: choose is_secure before burst
  solve is_secure before burst_len;
endclass
```
</InteractiveCode>

## Make It Work
1. **Model legality:** Translate protocol rules into constraints—illegal stimulus wastes regression time.
2. **Layer distributions:** Bias randomization toward risky scenarios (e.g., error opcodes) while still covering the space.
3. **Validate success:** Always check `randomize()` return value and log failures with an actionable message.
4. **Measure:** Pair random stimulus with functional coverage to confirm constraint intent is met.

**Checklist before moving on:**
- [ ] You can explain the difference between `rand` and `randc`.
- [ ] You can write relational and distribution constraints that reflect spec rules.
- [ ] You confirm randomize success and understand how to debug failures.

## Push Further
- Use pre/post-randomize hooks to enforce computed constraints (e.g., dependent arrays).
- Create constraint mode toggles (`constraint_mode(0)`) for reusable classes in different scenarios.
- Explore `randomize() with` blocks in sequences to target coverage holes without new classes.

## Practice & Reinforce
- Flashcards – Drill keyword meaning and solver behaviors.
- Quiz – Complete the constrained-random knowledge check below.
- Lab prompt – Build a transaction with soft defaults; toggle them via inline constraints and observe coverage hits.
- Visual notebook – Sketch how your constraints map to testplan features and coverage bins.

## Deep Dives in this Track
- [Constraint Blocks and Soft Contexts](./constraint-blocks)

## References & Next Topics
- **IEEE 1800-2023, Clause 18:** Constrained random value generation.
- Doulos: “SystemVerilog Constraints Tutorial.”
- Siemens Verification Academy: “Constraint Solving Tips.”
- Next: [`/curriculum/T2_Intermediate/I-SV-2B_Advanced_Constrained_Randomization`](../I-SV-2B_Advanced_Constrained_Randomization/).

<Quiz
  questions={[
    {
      question: 'How does `randc` differ from `rand`?',
      answers: [
        { text: '`randc` cycles through every value in a random order before repeating.', correct: true },
        { text: '`randc` cannot be constrained.', correct: false },
        { text: '`rand` is only for integers.', correct: false },
        { text: '`randc` is slower and should be avoided.', correct: false }
      ],
      explanation:
        '`randc` is ideal for finite sets such as opcodes—you get permutation coverage before repeats.'
    },
    {
      question: 'What happens when constraints contradict each other?',
      answers: [
        { text: 'The solver picks one at random.', correct: false },
        { text: 'Randomization fails (`randomize()` returns 0).', correct: true },
        { text: 'The simulator ignores constraints.', correct: false },
        { text: 'The variables revert to defaults.', correct: false }
      ],
      explanation:
        'Over-constrained classes return 0 from `randomize()`—always check and handle the failure path.'
    }
  ]}
/>

<div className="mt-8">
  <InterviewQuestionPlayground
    question="You have a class with a `rand bit [7:0] delay` and a `soft delay == 10;` constraint. If you run `obj.randomize() with { delay > 20; };`, what happens?"
    options={[
      { text: "The randomization fails because the inline constraint contradicts the class constraint.", isCorrect: false, feedback: "This would be true if the class constraint was a hard constraint, but it's soft." },
      { text: "The solver succeeds and generates a delay greater than 20.", isCorrect: true, feedback: "Correct! The `with` clause acts as a hard inline constraint. Since it contradicts the soft base constraint, the soft constraint is dropped and the hard constraint is satisfied." },
      { text: "The solver generates 10 anyway, because class constraints have higher priority than inline.", isCorrect: false, feedback: "Inline hard constraints always override soft base constraints." },
      { text: "It fails to compile because `soft` is not a valid SystemVerilog keyword.", isCorrect: false, feedback: "`soft` was added in IEEE 1800-2012." }
    ]}
  />
</div>
