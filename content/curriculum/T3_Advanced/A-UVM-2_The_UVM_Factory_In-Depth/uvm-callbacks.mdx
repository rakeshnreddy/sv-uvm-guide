import { InfoPage } from "@/components/templates/InfoPage";

export const metadata = {
  title: "UVM Callbacks & Factory Overrides | Advanced UVM Sequencing",
  description: "Combine callbacks with factory overrides so you can instrument VIP, inject errors, and audit behaviour without touching source modules.",
};

<InfoPage
  title="UVM Callbacks & Factory Overrides"
  uvm_concept_tags={["uvm_callback", "factory override", "instrumentation"]}
>

  ## Elevator Pitch

  Callbacks are tap-in points. The factory swaps the implementation; callbacks tweak behaviour at runtime—logging, fault injection, protocol tweaks—without subclass explosion.

  ## Callback Implementation Pattern

  ```systemverilog
  class my_driver_cb extends uvm_callback;
    `uvm_object_utils(my_driver_cb)

    virtual function void pre_drive(my_driver drv, my_item item);
    endfunction

    virtual function void post_drive(my_driver drv, my_item item);
    endfunction
  endclass

  typedef uvm_callbacks#(my_driver, my_driver_cb) my_driver_cbs_t;

  class logging_driver_cb extends my_driver_cb;
    `uvm_object_utils(logging_driver_cb)

    virtual function void pre_drive(my_driver drv, my_item item);
      `uvm_info("DRV_CB", $sformatf("About to drive %s", item.convert2string()), UVM_LOW)
    endfunction
  endclass

  class my_driver extends uvm_driver#(my_item);
    `uvm_component_utils(my_driver)

    virtual task run_phase(uvm_phase phase);
      forever begin
        seq_item_port.get_next_item(req);
        my_driver_cbs_t::pre_drive(this, req);
        drive_transfer(req);
        my_driver_cbs_t::post_drive(this, req);
        seq_item_port.item_done();
      end
    endtask
  endclass

  class my_env extends uvm_env;
    `uvm_component_utils(my_env)
    my_driver drv;

    function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      drv = my_driver::type_id::create("drv", this);
      my_driver_cbs_t::add(drv, logging_driver_cb::type_id::create("cb"));
    endfunction
  endclass
  ```

  **Implementation checklist**
  - Lines 2-10 define a base callback with `pre_drive`/`post_drive` hooks so specializations can override the behaviour.
  - Lines 12-20 introduce a logging callback that prints transactions before the driver acts on them.
  - Lines 22-36 wire callbacks into the driver’s `run_phase`, invoking hooks around the data transfer.
  - Lines 38-46 show how the environment creates the driver and registers the callback without modifying vendor code.

  ## Factory + Callback Synergy

  - Override the driver via the factory to insert callback hooks if the vendor version lacks them.
  - Use callbacks to record coverage or collect telemetry without forking the driver implementation.
  - Turn callbacks on/off via configuration objects or plusargs to keep regressions deterministic.

  ## Checklist

  - [ ] Callback typedef (`uvm_callbacks#`) declared once per component.
  - [ ] Driver calls pre/post hooks at appropriate points.
  - [ ] Callbacks registered at build time (or dynamically) and cleaned up if needed.

  ## Quiz Yourself

  **Why prefer callbacks over subclassing for logging?**
  - They execute faster
  - They add behaviour without needing a new driver subclass *(correct)*
  - They replace the factory
  - They only work with monitors

  **How do you invoke registered callbacks?**
  - Call `uvm_callbacks#(...).do()`
  - Use the typedef helper, e.g., `my_driver_cbs_t::pre_drive(...)` *(correct)*
  - Callbacks fire automatically
  - `factory.print()`

</InfoPage>
