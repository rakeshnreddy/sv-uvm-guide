import { InfoPage } from "@/components/templates/InfoPage";

export const metadata = {
  title: "Heartbeats & Hang Detection | Advanced UVM Factory",
  description: "Instrument your testbench with automated heartbeat monitors so overrides or callbacks can recover from stimulus hangs fast.",
};

<InfoPage
  title="Heartbeats & Hang Detection"
  uvm_concept_tags={["heartbeats", "hang detection", "uvm_heartbeat"]}
>

  ## Elevator Pitch

  Heartbeats are watchdogs for your stimulus. They watch sequences and phases, ensuring factory overrides or callbacks don’t accidentally stall traffic. When the heartbeat stops, the monitor raises alarms, captures diagnostics, or forces a recovery sequence.

  ## Wiring a Heartbeat

  ```systemverilog
  class soc_test extends uvm_test;
    `uvm_component_utils(soc_test)

    soc_env      m_env;
    uvm_heartbeat hb;

    function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      m_env = soc_env::type_id::create("m_env", this);
    endfunction

    function void connect_phase(uvm_phase phase);
      super.connect_phase(phase);
      hb = uvm_heartbeat::type_id::create("hb", this);
      hb.set_heartbeat(m_env.vseqr, "main_phase");
      hb.add(m_env.vseqr.get_global_seq());
      hb.set_timeout(.timeout = 1ms, .grace = 100us);
    endfunction

    task run_phase(uvm_phase phase);
      phase.raise_objection(this);

      boot_vseq boot = boot_vseq::type_id::create("boot");
      boot.start(m_env.vseqr);

      wait (hb.is_stopped() || boot.is_finished);
      phase.drop_objection(this);
    endtask

    virtual function void report_phase(uvm_phase phase);
      if (hb.is_stopped())
        `uvm_fatal("HB", "Heartbeat stopped—sequence likely hung")
    endfunction
  endclass
  ```

  **Implementation highlights**
  - Lines 2-10 create the environment and heartbeat component during build/connect phases.
  - Lines 12-20 target the virtual sequencer’s main phase, register the sequence to watch, and configure timeout/grace periods.
  - Lines 22-32 start the boot sequence, wait for heartbeat status, and escalate in `report_phase` if the monitor detects a hang.

  ## Patterns for Reliability

  - **Multiple sequences:** Register each critical sequence (`hb.add(seq_handle);`) so parallel stimulus is monitored.
  - **Dynamic registration:** Use callbacks or factory overrides to auto-register sequences when they start (`uvm_heartbeat::add` inside `pre_start` hook).
  - **Recovery flows:** Pair a heartbeat with an interrupt-handling virtual sequence to kick off resets or soft recovery sequences.
  - **Telemetry:** Record heartbeat events to your logging pipeline to correlate with DUT hangs.

  ## Checklist

  - [ ] Heartbeat timeout aligns with expected stimulus cadence.
  - [ ] Sequences are registered and deregistered as they start/finish.
  - [ ] Report/log actions give enough context (phase name, sequence handles).

  ## Quiz Yourself

  **What does `set_timeout` configure?**
  - The time a sequence waits before starting
  - How long the heartbeat can stay idle before flagging a hang *(correct)*
  - When the driver calls `item_done()`
  - The duration of `raise_objection`

  **Where should you typically register sequences with a heartbeat?**
  - Inside the DUT
  - When sequences are started (e.g., in the test or a callback) *(correct)*
  - In the driver
  - You do not need to register them

</InfoPage>
