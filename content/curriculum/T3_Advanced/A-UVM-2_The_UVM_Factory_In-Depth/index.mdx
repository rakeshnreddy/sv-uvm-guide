---
title: "A-UVM-2: The UVM Factory In-Depth"
description: "Target overrides precisely, debug factory configuration, and architect reusable agents with advanced UVM factory techniques."
flashcards: "A-UVM-2_The_UVM_Factory"
---

import { InteractiveCode } from '@/components/ui';

## Quick Take
- **What it is:** The UVM factory lets you substitute components or objects dynamically—per type, per instance, or even per command-line option.
- **Why it matters:** Precise overrides unlock reuse: one agent can act active at block level and passive at SoC level without forked code.
- **The Analogy:** Think of a theme park ride with "skins." The chassis stays the same, but you can swap decor or behavior modules before the ride starts.

> **Signal:** If you copy/paste an agent just to tweak one field, you probably needed an instance override or a config object instead.

## Build Your Mental Model
### Override techniques at a glance

<InteractiveCode
  language="systemverilog"
  fileName="factory_overrides.sv"
  code={`
class base_test extends uvm_test;
  `uvm_component_utils(base_test)

  alu_env m_env;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);

    // 1. Type override: swap all alu_drivers everywhere
    alu_driver::type_id::set_type_override(error_injecting_driver::get_type());

    // 2. Instance override: only touch the DMA agent's driver
    factory.set_inst_override_by_type(
      "m_env.m_dma_agent.m_driver",
      alu_driver::get_type(),
      dma_err_driver::get_type()
    );

    m_env = alu_env::type_id::create("m_env", this);
  endfunction

  function void end_of_elaboration_phase(uvm_phase phase);
    super.end_of_elaboration_phase(phase);
    factory.print(); // Debug what actually got registered
  endfunction
endclass
  `}
  explanationSteps={[
    { target: "9-12", title: "Global swap", explanation: "`set_type_override` replaces the driver everywhere it's built. Use for broad policy decisions." },
    { target: "15-21", title: "Scoped override", explanation: "Instance overrides key off a hierarchical path—perfect when only one agent needs custom behavior." },
    { target: "24-27", title: "Visibility", explanation: "`factory.print()` is the go-to diagnostic when overrides don't behave." }
  ]}
/>

### Patterns to internalize
- **Configurable agent:** Build a common `*_base_agent` that constructs subcomponents via the factory. Tests override it with protocol-specific descendants to reuse the same environment everywhere.
- **Company extensions:** Override base UVM classes globally so house style (logging, metrics) flows through the entire environment without touching vendor code.
- **Command-line tuning:** Allow string-based overrides only for high-level scripting; keep RTL-level benches on safe `get_type()` overrides.

## Make It Work
1. **Centralize overrides:** Collect factory policy in base tests or dedicated configuration modules so teams know where behavior is defined.
2. **Prefer handles over strings:** Use `::get_type()` for compile-time safety. String overrides are a last resort for prototyping or CLI knobs.
3. **Instrument debugging:** Call `factory.print()` or `uvm_factory::find_override_by_name()` during `end_of_elaboration_phase` to audit active overrides.
4. **Document default behavior:** Publish the intended override map (module doc, README) so newcomers understand how agents change personality.

**Checklist before moving on:**
- [ ] You can explain the difference between type and instance overrides and when to use each.
- [ ] You have a plan for locating all factory policy in one place.
- [ ] You can demonstrate how to debug a missing override with `factory.print()`.

## Push Further
- **Layered personalities:** Override an agent with a monitor-only variant for SoC regression while keeping the active version for block testing.
- **Factory governance:** Create lint rules or CI checks that ban string overrides in reusable VIP.
- **Dynamic experiments:** Use plusargs or JSON configs to feed override decisions without recompiling—great for cross-team experiments.
- **Factory + config_db:** Combine both: use the factory to swap classes, and config objects to tweak parameters inside the substituted component.

## Practice & Reinforce
- Explore targeted overrides in [/curriculum/T3_Advanced/A-UVM-2_The_UVM_Factory_In-Depth/heartbeats](./heartbeats).
- Learn about callback registration and factory interplay in [/curriculum/T3_Advanced/A-UVM-2_The_UVM_Factory_In-Depth/uvm-callbacks](./uvm-callbacks).
- Prototype a base-vs-specialized agent pattern in your sandbox environment.

## References & Next Topics
- Accellera *UVM User Guide*, Section 5.7 (Factory Overrides).
- Mentor Verification Academy, *UVM Factory and Configuration Strategies*.
- Company design guidelines or factory governance docs.
- Next: [/curriculum/T3_Advanced/A-UVM-3_Advanced_UVM_Techniques/index](../A-UVM-3_Advanced_UVM_Techniques/index) for callbacks, heartbeats, and phase control that rely on these overrides.
