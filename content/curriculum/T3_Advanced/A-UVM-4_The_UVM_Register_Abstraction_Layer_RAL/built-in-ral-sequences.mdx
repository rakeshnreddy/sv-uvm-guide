import Image from "next/image";
import { InfoPage } from "@/components/templates/InfoPage";

export const metadata = {
  title: "Built-in RAL Sequences & Utilities | Advanced UVM RAL",
  description: "Leverage UVM’s prebuilt register sequences—reset, bit-bash, mem tests—and learn how to extend or constrain them safely.",
};

<InfoPage
  title="Built-in RAL Sequences & Utilities"
  uvm_concept_tags={["RAL sequences", "uvm_reg_sequence", "bit-bash"]}
>

  ## Elevator Pitch

  RAL ships with powerful sequences—`uvm_reg_hw_reset_seq`, `uvm_reg_bit_bash_seq`, `uvm_mem_walk_seq`. Use them to prove the model and silicon (or emulation) agree, then extend them to fit your access rules.

  ## Reset & Mirror Validation

  ```systemverilog
  class soc_reset_seq extends uvm_reg_hw_reset_seq;
    `uvm_object_utils(soc_reset_seq)

    constraint c_paths {
      register_sequences == {"cfg_map"};
    }

    virtual task body();
      uvm_status_e status;
      super.body();
      foreach (model.default_map.regs[i]) begin
        uvm_reg rg = model.default_map.regs[i];
        if (!rg.has_hdl_path("CFG")) continue;
        rg.mirror(status, UVM_CHECK);
      end
    endtask
  endclass
  ```

  **How to extend it**
  - Lines 2-8 show how to constrain which address maps the built-in reset sequence touches.
  - Lines 10-17 add a post-reset mirror sweep so you catch registers that drift from their reset values immediately.

  ## Bit-Bash & Field Policies

  - `uvm_reg_bit_bash_seq`: toggles W/R bits to validate access types. Override `is_legal` to skip write-one-to-clear (W1C) or reserved bits.
  - `uvm_reg_access_seq`: simple sweeping read/write; great smoke test for new adapters.
  - `uvm_mem_walk_seq`: diag for memories; ensure the adapter handles bursts correctly.

  <figure className="my-8 flex flex-col items-center space-y-4">
    <Image
      src="/visuals/tier-4/mirror-health-heatmap.svg"
      alt="Heatmap illustrating register mirror delta severity"
      width={320}
      height={320}
      sizes="(min-width: 768px) 320px, 100vw"
      className="w-full max-w-sm rounded-2xl border border-white/10 bg-white/5 p-4"
    />
    <figcaption className="text-sm text-muted-foreground">
      Mirror health dashboards flag registers whose observed values drift from the model—use them after bit-bash to focus follow-up investigations.
    </figcaption>
  </figure>

  ```systemverilog
  class filtered_bit_bash_seq extends uvm_reg_bit_bash_seq;
    `uvm_object_utils(filtered_bit_bash_seq)

    virtual function bit is_legal(uvm_reg_field field);
      if (field.get_access() inside {"WO", "W1C"})
        return 0;
      return super.is_legal(field);
    endfunction
  endclass
  ```

  **Why override legality**
  - Lines 2-8 demonstrate skipping fields that could corrupt DUT state while still reusing the robust bit-bash engine.

  ## Checklist

  - [ ] Built-in sequences are subclassed to respect DUT-specific access restrictions.
  - [ ] Coverage/scoreboards observe these sequences to collect reset/bit coverage metrics.
  - [ ] Register model and adapters are synchronized before running memory walk tests.

  ## Quiz Yourself

  **What does `uvm_reg_bit_bash_seq` primarily validate?**
  - Adapters convert opcodes correctly
  - Register fields honor their access policies (RW/RO/etc.) *(correct)*
  - The DUT boots correctly
  - Scoreboards are connected

  **How do you prevent a built-in sequence from corrupting W1C fields?**
  - Disable mirroring
  - Override `is_legal()` and return 0 for those fields *(correct)*
  - Switch to backdoor
  - Use `set_sequencer(null)`

</InfoPage>
