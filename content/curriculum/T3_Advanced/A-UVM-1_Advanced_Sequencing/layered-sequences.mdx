import { InfoPage } from "@/components/templates/InfoPage";

export const metadata = {
  title: "Layered Sequences and p_sequencer | Advanced UVM Sequencing",
  description: "Design atomic, scenario, and virtual layers of sequences while using p_sequencer to orchestrate cross-agent stimulus.",
};

<InfoPage
  title="Layered Sequences and p_sequencer"
  uvm_concept_tags={["layered sequences", "p_sequencer", "virtual sequence"]}
>

  ## Elevator Pitch

  Layered sequencing keeps stimulus maintainable: atomic sequences capture protocol verbs, scenario sequences compose them, and virtual sequences (via `p_sequencer`) synchronize agents. With clear layers, you can swap drivers or rebuild corner-case stimulus without rewriting the whole flow.

  ## Stack Your Stimulus

  1. **Atomic layer:** Minimal sequences that drive a single transaction type (`write_reg_seq`, `send_token_seq`).
  2. **Scenario layer:** Compositions that stitch atomic pieces with timing, coverage hooks, or error injection.
  3. **Virtual/test layer:** Sequencer-agnostic coordinators that start scenarios across agents using typed `p_sequencer` handles.

  Benefits:
  - Swap atomic sequences as protocol revisions land—scenarios stay intact.
  - Allow teams to own separate layers (VIP vendor supplies atomics; you supply scenarios).
  - Make debugging easier: failures surface at the highest layer that changed.

  ## p_sequencer in Practice

  ```systemverilog
  typedef uvm_sequencer#(mem_item) mem_sqr_t;

  class mem_atomic_write extends uvm_sequence#(mem_item);
    `uvm_object_utils(mem_atomic_write)

    rand bit [31:0] addr;
    rand bit [63:0] data;

    virtual task body();
      start_item(req);
      assert(req.randomize() with { rw == WRITE; this.addr == addr; this.data == data; });
      finish_item(req);
    endtask
  endclass

  class mem_burst_program extends uvm_sequence#(mem_item);
    `uvm_object_utils(mem_burst_program)

    rand bit [31:0] base_addr;

    virtual task body();
      repeat (8) begin
        `uvm_do_with(req, { rw == WRITE; addr == base_addr + idx * 8; })
      end
    endtask
  endclass

  class soc_init_vseq extends uvm_sequence;
    `uvm_object_utils(soc_init_vseq)

    typedef virtual_sequencer pseq_t;
    pseq_t p_sequencer;

    virtual task body();
      if (!$cast(p_sequencer, m_sequencer))
        `uvm_fatal("VSEQ", "Unable to cast m_sequencer to virtual_sequencer")

      mem_atomic_write   csr_seq;
      mem_burst_program  boot_seq;

      csr_seq  = mem_atomic_write::type_id::create("csr_seq");
      boot_seq = mem_burst_program::type_id::create("boot_seq");

      csr_seq.addr = 'hFF00_0000;
      csr_seq.data = 64'h1;

      csr_seq.start(p_sequencer.cfg_sqr);
      boot_seq.start(p_sequencer.mem_sqr);
    endtask
  endclass
  ```

  **Walkthrough highlights**
  - Lines 1-20 form the atomic layer: `mem_atomic_write` owns the minimal transaction logic and can be reused across scenarios.
  - Lines 22-31 compose a scenario layer that repeats the atomic write pattern—easy to swap for error injection or coverage sampling.
  - Lines 33-54 showcase the virtual layer that casts `m_sequencer` into a typed handle and routes work to individual agent sequencers.

  **Tip:** Give each layer a naming convention (`*_atomic_seq`, `*_scenario_seq`, `*_vseq`) so it is obvious which level to modify.

  ## Governance & Maintenance

  - **Configuration:** Pass knobs through sequence constructors or `uvm_config_db` instead of hard-coded globals. Scenario sequences can aggregate knobs and relay them to atomics.
  - **Coverage:** Keep coverage sampling in scenario sequences—they know which combination is under test, while atomics stay protocol-agnostic.
  - **Reusability:** Publish scenario sequences via `uvm_sequence_library` so tests pick them by name or weight.

  ## Checklist

  - [ ] Atomic, scenario, and virtual layers have clear responsibilities.
  - [ ] `p_sequencer` casts succeed and are guarded by fatal messages.
  - [ ] Configuration flows downward (tests → virtual sequences → scenarios → atomics).

  ## Quiz Yourself

  **Where should coverage bins that span multiple transactions live?**
  - Inside each atomic sequence
  - Inside the scenario sequence that composes the traffic *(correct)*
  - Inside the driver
  - In the monitor only

  **What does `p_sequencer` provide in a virtual sequence?**
  - A handle to the driver
  - A typed handle to the virtual sequencer so you can reach agent sequencers *(correct)*
  - A shortcut to the monitor
  - Nothing—it is optional sugar

</InfoPage>
