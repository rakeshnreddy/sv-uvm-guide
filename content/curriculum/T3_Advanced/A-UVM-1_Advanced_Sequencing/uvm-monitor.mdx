import { InfoPage } from "@/components/templates/InfoPage";
import { InteractiveCode, Quiz } from "@/components/ui";

export const metadata = {
  title: "uvm_monitor & Analysis Fabric | Advanced UVM Sequencing",
  description: "Instrument monitors to reconstruct transactions, publish them reliably, and feed subscribers and scoreboards.",
};

<InfoPage
  title="uvm_monitor & Analysis Fabric"
  uvm_concept_tags={["uvm_monitor", "analysis port", "observation"]}
>

  ## Elevator Pitch

  Monitors convert pin wiggles into transactions, driving the analysis fabric that powers scoreboards, coverage, and debug widgets. Treat them as observation-only components with precise sampling and logging.

  ## Monitor Blueprint

  <InteractiveCode
    language="systemverilog"
    fileName="axi_monitor.sv"
    code={`
class axi_monitor extends uvm_monitor;
  `uvm_component_utils(axi_monitor)

  virtual axi_if vif;
  uvm_analysis_port#(axi_tr) ap;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    ap = new("ap", this);
    if (!uvm_config_db#(virtual axi_if)::get(this, "", "vif", vif))
      `uvm_fatal("MON", "No virtual interface supplied")
  endfunction

  task run_phase(uvm_phase phase);
    forever begin
      axi_tr tr = axi_tr::type_id::create("tr");
      collect_address_phase(tr);
      collect_data_phase(tr);
      ap.write(tr);
    end
  endtask

  task collect_address_phase(axi_tr tr);
    @(posedge vif.aclk iff vif.awvalid && vif.awready);
    tr.addr = vif.awaddr;
    tr.len  = vif.awlen;
    tr.op   = WRITE;
  endtask

  task collect_data_phase(axi_tr tr);
    repeat (tr.len + 1) begin
      @(posedge vif.aclk iff vif.wvalid && vif.wready);
      tr.data_q.push_back(vif.wdata);
    end
  endtask
endclass
    `}
    explanationSteps={[
      { target: "1-11", title: "Setup", explanation: "Monitors grab a virtual interface and create an analysis port for downstream consumers." },
      { target: "12-20", title: "Run loop", explanation: "Each transaction is reconstructed, then written to the analysis port." },
      { target: "22-35", title: "Phase capture", explanation: "Dedicated tasks make it obvious which protocol phases are observed and when." }
    ]}
  />

  ## Best Practices

  - **Do not drive pins:** Monitors are purely observational—never write to the interface.
  - **Time-stamp:** Capture simulation time for each transaction to help scoreboards align streams.
  - **Error checking:** Use immediate assertions or `uvm_error` when unsupported protocol combinations occur—great early warning for VIP mismatches.
  - **Analysis fanout:** Provide separate ports if you want to split traffic (e.g., `write_ap`, `read_ap`) to avoid downstream filtering costs.
  - **Connectivity rehearsal:** Walk through the [Scoreboard Connector exercise](/exercises/scoreboard-connector) to validate analysis_port wiring before you wire a complex scoreboard tree.

  ## Checklist

  - [ ] Virtual interface fetched successfully via `uvm_config_db`.
  - [ ] Analysis port is instantiated and every transaction is written exactly once.
  - [ ] Protocol timing is respected (`iff valid && ready`).

  ## Quiz Yourself

  <Quiz questions={[
    {
      question: "What happens if the monitor misses `awvalid`/`awready`?",
      answers: [
        { text: "The driver retries automatically", correct: false },
        { text: "The transaction loses its address/length context", correct: true },
        { text: "Nothing—data beats carry the info", correct: false },
        { text: "The sequencer reports an error", correct: false }
      ],
      explanation: "Without the address phase, scoreboards and coverage have no idea what the subsequent data belongs to." }
    },
    {
      question: "Where should monitors obtain their virtual interface?",
      answers: [
        { text: "By importing a global handle", correct: false },
        { text: "From the config DB in `build_phase`", correct: true },
        { text: "From the driver directly", correct: false },
        { text: "They do not need one", correct: false }
      ],
      explanation: "Config DB keeps interface binding centralized and flexible." }
    }
  ]} />

  > **Keep going:** Once your monitor publishes transactions, plug them into the advanced scoreboard patterns in this module and sample them for functional coverage using the Tier-2 refresher on [coverage options](/curriculum/T2_Intermediate/I-SV-3_Functional_Coverage/coverage-options).

</InfoPage>
