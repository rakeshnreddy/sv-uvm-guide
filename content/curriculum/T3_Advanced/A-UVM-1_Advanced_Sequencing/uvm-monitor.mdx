import { InfoPage } from "@/components/templates/InfoPage";

export const metadata = {
  title: "uvm_monitor & Analysis Fabric | Advanced UVM Sequencing",
  description: "Instrument monitors to reconstruct transactions, publish them reliably, and feed subscribers and scoreboards.",
};

<InfoPage
  title="uvm_monitor & Analysis Fabric"
  uvm_concept_tags={["uvm_monitor", "analysis port", "observation"]}
>

  ## Elevator Pitch

  Monitors convert pin wiggles into transactions, driving the analysis fabric that powers scoreboards, coverage, and debug widgets. Treat them as observation-only components with precise sampling and logging.

  ## Monitor Blueprint

  ```systemverilog
  class axi_monitor extends uvm_monitor;
    `uvm_component_utils(axi_monitor)

    virtual axi_if vif;
    uvm_analysis_port#(axi_tr) ap;

    function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      ap = new("ap", this);
      if (!uvm_config_db#(virtual axi_if)::get(this, "", "vif", vif))
        `uvm_fatal("MON", "No virtual interface supplied")
    endfunction

    task run_phase(uvm_phase phase);
      forever begin
        axi_tr tr = axi_tr::type_id::create("tr");
        collect_address_phase(tr);
        collect_data_phase(tr);
        ap.write(tr);
      end
    endtask

    task collect_address_phase(axi_tr tr);
      @(posedge vif.aclk iff vif.awvalid && vif.awready);
      tr.addr = vif.awaddr;
      tr.len  = vif.awlen;
      tr.op   = WRITE;
    endtask

    task collect_data_phase(axi_tr tr);
      repeat (tr.len + 1) begin
        @(posedge vif.aclk iff vif.wvalid && vif.wready);
        tr.data_q.push_back(vif.wdata);
      end
    endtask
  endclass
  ```

  **Implementation highlights**
  - Lines 2-12 show the monitor claiming a virtual interface and instantiating an analysis port so downstream components can subscribe.
  - Lines 14-23 reconstruct each transaction and publish it exactly once through `ap.write()`.
  - Lines 25-37 isolate address/data sampling into tasks, making the protocol timing crystal clear.

  ## Best Practices

  - **Do not drive pins:** Monitors are purely observational—never write to the interface.
  - **Time-stamp:** Capture simulation time for each transaction to help scoreboards align streams.
  - **Error checking:** Use immediate assertions or `uvm_error` when unsupported protocol combinations occur—great early warning for VIP mismatches.
  - **Analysis fanout:** Provide separate ports if you want to split traffic (e.g., `write_ap`, `read_ap`) to avoid downstream filtering costs.
  - **Connectivity rehearsal:** Walk through the [Scoreboard Connector exercise](/exercises/scoreboard-connector) to validate analysis_port wiring before you wire a complex scoreboard tree.

  ## Checklist

  - [ ] Virtual interface fetched successfully via `uvm_config_db`.
  - [ ] Analysis port is instantiated and every transaction is written exactly once.
  - [ ] Protocol timing is respected (`iff valid && ready`).

  ## Quiz Yourself

  **What happens if the monitor misses `awvalid`/`awready`?**
  - The driver retries automatically
  - The transaction loses its address/length context *(correct)*
  - Nothing—data beats carry the info
  - The sequencer reports an error

  **Where should monitors obtain their virtual interface?**
  - By importing a global handle
  - From the config DB in `build_phase` *(correct)*
  - From the driver directly
  - They do not need one

  > **Keep going:** Once your monitor publishes transactions, plug them into the advanced scoreboard patterns in this module and sample them for functional coverage using the Tier-2 refresher on [coverage options](/curriculum/T2_Intermediate/I-SV-3_Functional_Coverage/coverage-options).

</InfoPage>
