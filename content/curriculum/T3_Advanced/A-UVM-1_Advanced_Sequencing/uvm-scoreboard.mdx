import { InfoPage } from "@/components/templates/InfoPage";

export const metadata = {
  title: "UVM Scoreboard Patterns | Advanced UVM Sequencing",
  description: "Design scoreboards that compare expected vs. observed traffic, manage response queues, and surface mismatches clearly.",
};

<InfoPage
  title="UVM Scoreboard Patterns"
  uvm_concept_tags={["scoreboard", "analysis", "comparison"]}
>

  ## Elevator Pitch

  Scoreboards judge whether stimulus produced the right behaviour. Hook them to analysis streams, build prediction models, and produce forensic logs when actual and expected diverge.

  ## Predict vs. Observe

  ```systemverilog
  `uvm_analysis_imp_decl(_exp)
  `uvm_analysis_imp_decl(_act)

  class mem_scoreboard extends uvm_component;
    `uvm_component_utils(mem_scoreboard)

    uvm_analysis_imp_exp#(mem_item, mem_scoreboard) exp_export;
    uvm_analysis_imp_act#(mem_item, mem_scoreboard) act_export;

    typedef uvm_tlm_analysis_fifo#(mem_item) fifo_t;
    fifo_t exp_fifo;
    fifo_t act_fifo;

    function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      exp_export = new("exp_export", this);
      act_export = new("act_export", this);
      exp_fifo   = fifo_t::type_id::create("exp_fifo", this);
      act_fifo   = fifo_t::type_id::create("act_fifo", this);
    endfunction

    virtual function void write_exp(mem_item t);
      exp_fifo.try_put(t.clone());
    endfunction

    virtual function void write_act(mem_item t);
      act_fifo.try_put(t.clone());
    endfunction

    task run_phase(uvm_phase phase);
      forever begin
        mem_item exp, act;
        exp_fifo.get(exp);
        act_fifo.get(act);

        if (!compare(exp, act)) begin
          `uvm_error("SCB", $sformatf("Mismatch exp=%s act=%s", exp.convert2string(), act.convert2string()))
        end
      end
    endtask

    function bit compare(mem_item exp, mem_item act);
      if (!exp.do_compare(act, null)) return 0;
      return 1;
    endfunction
  endclass
  ```

  **What to keep in mind**
  - Lines 1-12 declare distinct analysis imps and FIFO handles so expected and actual data flow independently.
  - Lines 14-24 clone incoming items before queuing, giving the scoreboard ownership of the objects it compares later.
  - Lines 26-43 pull matching transactions, call `do_compare`, and log mismatches with `convert2string()` output for rapid triage.

  ## Design Considerations

  - **Matching policy:** Use associative arrays keyed by address or ID when order differs, or `uvm_in_order_class_comparer` for in-order streams.
  - **Latency tolerance:** Add timeouts or scoreboard configuration to allow write/read latency before flagging mismatches.
  - **Reference models:** Embed a predictive model (e.g., simple memory model) inside the scoreboard to generate expected responses rather than relying solely on sequences.
  - **Debug artifacts:** Emit transaction trails (`uvm_table_printer`) or JSON logs for failing cases.
  - **Interactive drill:** Rehearse analysis port wiring with the [Scoreboard Connector exercise](/exercises/scoreboard-connector); it mirrors the dual-path topology used here.

  ## Checklist

  - [ ] Expected and actual paths are independent analysis connections.
  - [ ] Transactions are cloned before storing.
  - [ ] Mismatch logs include enough context (address, data, sequence ID).

  ## Quiz Yourself

  **Why push transactions through `uvm_tlm_analysis_fifo`?**
  - To randomize their order
  - To decouple producers and consumers with blocking semantics *(correct)*
  - Because monitors require it
  - To convert them to responses

  **Your scoreboard logs mismatches but no context. What should you add first?**
  - Grab the sequencer
  - A custom `convert2string()` on the sequence item *(correct)*
  - Randomize the expected item
  - Disable the scoreboard

</InfoPage>
