import { InfoPage } from "@/components/templates/InfoPage";
import { InteractiveCode, Quiz } from "@/components/ui";

export const metadata = {
  title: "Connecting the Agent Components | Advanced UVM Sequencing",
  description: "Wire sequencers, drivers, monitors, and scoreboards with robust connect_phase patterns and analysis backbones.",
};

<InfoPage
  title="Connecting the Agent Components"
  uvm_concept_tags={["agent", "connect_phase", "analysis ports"]}
>

  ## Elevator Pitch

  Building components is half the battle; wiring them correctly is what turns a collection of classes into a cohesive UVM environment. A disciplined `connect_phase` prevents lost transactions, preserves timing, and makes layered sequences observable.

  ## The Standard Wiring Blueprint

  <InteractiveCode
    language="systemverilog"
    fileName="agent_connect_phase.sv"
    code={`
class my_agent extends uvm_agent;
  `uvm_component_utils(my_agent)

  my_driver    drv;
  my_sequencer sqr;
  my_monitor   mon;

  uvm_analysis_port#(my_item) analysis_port;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    if (is_active == UVM_ACTIVE) begin
      drv = my_driver   ::type_id::create("drv", this);
      sqr = my_sequencer::type_id::create("sqr", this);
    end
    mon = my_monitor::type_id::create("mon", this);
    analysis_port = new("analysis_port", this);
  endfunction

  function void connect_phase(uvm_phase phase);
    if (is_active == UVM_ACTIVE) begin
      drv.seq_item_port.connect(sqr.seq_item_export);
      drv.rsp_port.connect(sqr.rsp_export);
    end
    mon.ap.connect(analysis_port);
  endfunction
endclass

class my_env extends uvm_env;
  `uvm_component_utils(my_env)

  my_agent      agt;
  my_scoreboard scb;

  function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    agt.analysis_port.connect(scb.exp_fifo.analysis_export);
  endfunction
endclass
    `}
    explanationSteps={[
      { target: "1-24", title: "Factory + build", explanation: "Instantiate driver/sequencer only for active agents and create an analysis port regardless of activity." },
      { target: "26-34", title: "Sequencer ↔ driver wiring", explanation: "Always connect both `seq_item_port`/`seq_item_export` and the response channel." },
      { target: "35-44", title: "Analysis fanout", explanation: "Monitor pushes transactions through an analysis port that the environment re-broadcasts to scoreboards or coverage." }
    ]}
  />

  ## Patterns for Complex Environments

  - **Hierarchical fanout:** Environments can own a central `uvm_analysis_port` fed by many agents. Use `uvm_analysis_export` + `uvm_analysis_imp` to branch subscribers.
  - **TLM FIFOs:** Insert `uvm_tlm_fifo` between driver and sequencer when the driver needs to decouple request/response timings.
  - **Virtual sequencer setup:** During `connect_phase`, assign real sequencer handles into the virtual sequencer via `uvm_config_db::set(this, "vseq", "mem_sqr", agt.sqr);`.
  - **Pass-through monitors:** For passive agents, forward monitor data directly to the environment-level port—no driver wiring needed.

  ## Debug Checklist

  - Enable `uvm_set_verbosity` at `UVM_FULL` to ensure `connect_phase` logs appear—missing logs usually mean the method never ran.
  - Call `uvm_top.print_topology()` after build to confirm the expected connections exist.
  - Add assertions that critical handles (`sqr`, `drv`) are non-null before connecting.

  ## Quiz Yourself

  <Quiz questions={[
    {
      question: "Which connection is required for drivers to return read data to sequences?",
      answers: [
        { text: "`drv.seq_item_port.connect(sqr.seq_item_export);`", correct: false },
        { text: "`drv.rsp_port.connect(sqr.rsp_export);`", correct: true },
        { text: "`mon.ap.connect(analysis_port);`", correct: false },
        { text: "`analysis_port.connect(scb.analysis_export);`", correct: false }
      ],
      explanation: "The response channel carries items back to sequences waiting in `get_response()`." }
    },
    {
      question: "A passive agent should still...",
      answers: [
        { text: "Instantiate a driver for completeness", correct: false },
        { text: "Expose its monitor analysis port so scoreboards receive traffic", correct: true },
        { text: "Disable the monitor to avoid conflicting with active agents", correct: false },
        { text: "Grab the sequencer", correct: false }
      ],
      explanation: "Passive agents omit the driver/sequencer but remain the source of observation data." }
    }
  ]} />

</InfoPage>
