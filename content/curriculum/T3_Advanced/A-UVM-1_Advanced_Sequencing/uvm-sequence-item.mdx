import { InfoPage } from "@/components/templates/InfoPage";

export const metadata = {
  title: "uvm_sequence_item Mastery | Advanced UVM Sequencing",
  description: "Engineer rich transaction objects with constraints, deep copy behaviour, and response tracking so every layer of the testbench stays in sync.",
};

<InfoPage
  title="uvm_sequence_item Mastery"
  uvm_concept_tags={["uvm_sequence_item", "transaction modeling", "set_id_info"]}
>

  ## Elevator Pitch

  `uvm_sequence_item` defines the payload every component shares. Thoughtful modeling—constraints, packing, IDs, logging—lets sequences randomize safely, drivers drive accurately, and scoreboards compare confidently without reimplementing protocol knowledge.

  ## Shape the Transaction Class

  ```systemverilog
  class mem_item extends uvm_sequence_item;
    `uvm_object_utils_begin(mem_item)
      `uvm_field_int(addr, UVM_ALL_ON | UVM_HEX)
      `uvm_field_int(len,  UVM_ALL_ON)
      `uvm_field_enum(op_t, op, UVM_ALL_ON)
      `uvm_field_queue_int(data_q, UVM_ALL_ON)
    `uvm_object_utils_end

    typedef enum bit [1:0] { READ, WRITE, FLUSH } op_t;

    rand bit [31:0] addr;
    rand int unsigned len;
    rand op_t op;
    rand byte data_q[$];

    constraint c_len { len inside {[1:8]}; }
    constraint c_write_payload { (op == WRITE) -> data_q.size() == len; }
    constraint c_read_payload  { (op != WRITE) -> data_q.size() == 0; }

    function new(string name = "mem_item");
      super.new(name);
    endfunction

    virtual function void do_copy(uvm_object rhs);
      mem_item rhs_cast;
      if (!$cast(rhs_cast, rhs))
        `uvm_fatal("COPY", "Type mismatch in mem_item::do_copy")
      super.do_copy(rhs);
      data_q = rhs_cast.data_q;
    endfunction

    virtual function bit do_compare(uvm_object rhs, uvm_comparer comparer);
      mem_item rhs_cast;
      if (!$cast(rhs_cast, rhs)) return 0;
      if (!super.do_compare(rhs, comparer)) return 0;
      return (data_q == rhs_cast.data_q);
    endfunction

    virtual function string convert2string();
      return $sformatf("[%s addr=%h len=%0d data=%p]", op.name(), addr, len, data_q);
    endfunction
  endclass
  ```

  **What this covers**
  - Lines 2-10 register every field so factory overrides, printing, and compare hooks “just work.”
  - Lines 12-24 keep protocol legality with built-in constraints so every sequence inherits safe defaults.
  - Lines 26-37 handle deep copy/compare for the byte queue and provide a readable `convert2string()` for log output.

  ## IDs, Responses, and Outstanding Traffic

  - **ID propagation:** Drivers should call `rsp.set_id_info(req);` before returning responses. Sequences waiting on `get_response()` or `item_done(rsp)` rely on matching IDs.
  - **Cloning safety:** Drivers often clone a request before mutating soft fields (timestamps, ready bits). Override `clone()` or rely on `do_copy` to keep deep fields intact.
  - **Response depth:** Set `response_queue_depth` in sequences when expecting multiple outstanding items; otherwise the sequencer warns when the queue overflows.

  ## Serialization & Analysis Integration

  - Implement `do_pack()` when the scoreboard or coverage collector needs a byte-level representation (useful for DPI, memory model bridges, or coverage hashing).
  - Expose helper APIs (`function bit is_read();`) so sequences and scoreboards stay expressive without digging through fields.
  - Record creation timestamps or UUIDs when debugging ordering issues—store them in non-random fields (set `rand_mode(0)` if necessary).

  ## Checklist

  - [ ] All dynamic fields are handled in `do_copy`/`do_compare`.
  - [ ] `set_id_info` is consistently used for responses.
  - [ ] `convert2string` outputs meaningful, terse descriptions.

  ## Quiz Yourself

  **Why call `set_id_info(req)` on a response item?**
  - To randomize the response again
  - To copy the sequence and transaction IDs so the sequencer can route it *(correct)*
  - To pack the data into bytes
  - To clear the request payload

  **Your item owns a queue of bytes. What happens if you skip overriding `do_copy()`?**
  - The clone receives an empty queue
  - Both the original and clone point to the same queue instance *(correct)*
  - The factory override fails
  - Compilation fails

</InfoPage>
