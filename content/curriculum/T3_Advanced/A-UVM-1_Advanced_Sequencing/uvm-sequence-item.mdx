import { InfoPage } from "@/components/templates/InfoPage";
import { InteractiveCode, Quiz } from "@/components/ui";

export const metadata = {
  title: "uvm_sequence_item Mastery | Advanced UVM Sequencing",
  description: "Engineer rich transaction objects with constraints, deep copy behaviour, and response tracking so every layer of the testbench stays in sync.",
};

<InfoPage
  title="uvm_sequence_item Mastery"
  uvm_concept_tags={["uvm_sequence_item", "transaction modeling", "set_id_info"]}
>

  ## Elevator Pitch

  `uvm_sequence_item` defines the payload every component shares. Thoughtful modeling—constraints, packing, IDs, logging—lets sequences randomize safely, drivers drive accurately, and scoreboards compare confidently without reimplementing protocol knowledge.

  ## Shape the Transaction Class

  <InteractiveCode
    language="systemverilog"
    fileName="mem_item.sv"
    code={`
class mem_item extends uvm_sequence_item;
  `uvm_object_utils_begin(mem_item)
    `uvm_field_int(addr, UVM_ALL_ON | UVM_HEX)
    `uvm_field_int(len,  UVM_ALL_ON)
    `uvm_field_enum(op_t, op, UVM_ALL_ON)
    `uvm_field_queue_int(data_q, UVM_ALL_ON)
  `uvm_object_utils_end

  typedef enum bit [1:0] { READ, WRITE, FLUSH } op_t;

  rand bit [31:0] addr;
  rand int unsigned len;
  rand op_t op;
  rand byte data_q[$];

  constraint c_len { len inside {[1:8]}; }
  constraint c_write_payload { (op == WRITE) -> data_q.size() == len; }
  constraint c_read_payload  { (op != WRITE) -> data_q.size() == 0; }

  function new(string name = "mem_item");
    super.new(name);
  endfunction

  virtual function void do_copy(uvm_object rhs);
    mem_item rhs_cast;
    if (!$cast(rhs_cast, rhs))
      `uvm_fatal("COPY", "Type mismatch in mem_item::do_copy")
    super.do_copy(rhs);
    data_q = rhs_cast.data_q;
  endfunction

  virtual function bit do_compare(uvm_object rhs, uvm_comparer comparer);
    mem_item rhs_cast;
    if (!$cast(rhs_cast, rhs)) return 0;
    if (!super.do_compare(rhs, comparer)) return 0;
    return (data_q == rhs_cast.data_q);
  endfunction

  virtual function string convert2string();
    return $sformatf("[%s addr=%h len=%0d data=%p]", op.name(), addr, len, data_q);
  endfunction
endclass
    `}
    explanationSteps={[
      { target: "2-9", title: "Field automation", explanation: "Field macros register metadata for factory overrides, printing, recording, and comparison." },
      { target: "11-20", title: "Protocol constraints", explanation: "Keep legality rules inside the item so any sequence or scoreboard clone inherits them automatically." },
      { target: "22-35", title: "Deep copy/compare", explanation: "Queues need explicit copy + compare logic; default behaviour only performs shallow operations." },
      { target: "37-39", title: "Readable logging", explanation: "Custom `convert2string()` output keeps run logs human friendly during debug." }
    ]}
  />

  ## IDs, Responses, and Outstanding Traffic

  - **ID propagation:** Drivers should call `rsp.set_id_info(req);` before returning responses. Sequences waiting on `get_response()` or `item_done(rsp)` rely on matching IDs.
  - **Cloning safety:** Drivers often clone a request before mutating soft fields (timestamps, ready bits). Override `clone()` or rely on `do_copy` to keep deep fields intact.
  - **Response depth:** Set `response_queue_depth` in sequences when expecting multiple outstanding items; otherwise the sequencer warns when the queue overflows.

  ## Serialization & Analysis Integration

  - Implement `do_pack()` when the scoreboard or coverage collector needs a byte-level representation (useful for DPI, memory model bridges, or coverage hashing).
  - Expose helper APIs (`function bit is_read();`) so sequences and scoreboards stay expressive without digging through fields.
  - Record creation timestamps or UUIDs when debugging ordering issues—store them in non-random fields (set `rand_mode(0)` if necessary).

  ## Checklist

  - [ ] All dynamic fields are handled in `do_copy`/`do_compare`.
  - [ ] `set_id_info` is consistently used for responses.
  - [ ] `convert2string` outputs meaningful, terse descriptions.

  ## Quiz Yourself

  <Quiz questions={[
    {
      question: "Why call `set_id_info(req)` on a response item?",
      answers: [
        { text: "To randomize the response again", correct: false },
        { text: "To copy the sequence and transaction IDs so the sequencer can route it", correct: true },
        { text: "To pack the data into bytes", correct: false },
        { text: "To clear the request payload", correct: false }
      ],
      explanation: "`set_id_info` ensures responses flow back to the correct waiting sequence or response handler." }
    },
    {
      question: "Your item owns a queue of bytes. What happens if you skip overriding `do_copy()`?",
      answers: [
        { text: "The clone receives an empty queue", correct: false },
        { text: "Both the original and clone point to the same queue instance", correct: true },
        { text: "The factory override fails", correct: false },
        { text: "Compilation fails", correct: false }
      ],
      explanation: "Without a custom `do_copy`, the queue reference is duplicated, so mutating one transaction mutates the other." }
    }
  ]} />

</InfoPage>
