---
title: "A-UVM-1: Advanced UVM Sequencing"
description: "Coordinate layered stimulus with virtual sequences, arbitration hooks, and reusable sequence libraries across complex UVM testbenches."
flashcards: "A-UVM-1_Advanced_Sequencing"
---

import { InteractiveCode } from '@/components/ui';

## Quick Take
- **What it is:** Advanced sequencing patterns orchestrate multiple sequencers, layer reusable sub-sequences, and encapsulate stimulus policy without rewriting drivers.
- **Why it matters:** Complex SoCs need synchronized activity across interfaces—virtual sequences keep agents in lockstep while arbitration hooks guarantee safe access.
- **The Analogy:** Picture a director with assistant directors. Virtual sequences call the shots, while helper sequences deliver scenes when scheduled.

> **Signal:** If a test relies on `#delays` to coordinate agents, graduate to a virtual sequencer.

## Build Your Mental Model
### Where virtual sequences fit
Simple environments launch a single sequence on one agent. At SoC scale you need a coordinator that knows about *all* sequencers. A virtual sequence runs on a lightweight virtual sequencer whose only job is to store handles to real sequencers; it creates and starts specialized sub-sequences in a precise order.

<InteractiveCode
  language="systemverilog"
  fileName="soc_virtual_seq.sv"
  code={`
class soc_virtual_seq extends uvm_sequence;
  `uvm_object_utils(soc_virtual_seq)

  // Injected handles to the "real" sequencers
  config_seqr_h cfg_sqr;
  data_seqr_h   data_sqr;

  task body();
    cfg_program_seq cfg = cfg_program_seq::type_id::create("cfg");
    burst_data_seq  burst = burst_data_seq::type_id::create("burst");

    cfg.start(cfg_sqr);
    cfg.wait_for_completion();

    fork
      burst.start(data_sqr);
      begin
        credit_watchdog_seq credits = credit_watchdog_seq::type_id::create("credits");
        credits.start(data_sqr);
      end
    join
  endtask
endclass
  `}
  explanationSteps={[
    { target: "1-4", title: "Orchestrator sequence", explanation: "Virtual sequences typically omit an item type. Their job is to coordinate other sequences instead of generating transactions directly." },
    { target: "7-8", title: "Handles supplied at runtime", explanation: "Virtual sequencers hold pointers to the actual sequencers. Tests populate these handles through `uvm_config_db` during `connect_phase`." },
    { target: "10-15", title: "Reusable building blocks", explanation: "Atomic sequences focus on narrow tasks (configure or stream data). Virtual sequences decide when each should run." },
    { target: "17-26", title: "Event-driven coordination", explanation: "Forking lets stimulus and watchdog logic run concurrently—use events or completion methods instead of raw delays." }
  ]}
/>

### Layered sequence libraries
- **Atomic layer:** rock-solid micro-sequences (`write_reg_seq`, `send_token_seq`).
- **Scenario layer:** combines atomic pieces with looping, error injection, or arbitration tweaks (`link_training_seq`).
- **Test layer:** virtual sequences orchestrating scenario building blocks across agents.

Register these families with `uvm_sequence_library_utils` or publish defaults via `uvm_config_db` so tests pick behavior declaratively.

### Arbitration control & fairness
- `lock()` / `unlock()` wraps critical bursts so other sequences wait gracefully.
- `grab()` / `ungrab()` forces exclusive control across phases—reserve for debugging and rare one-offs.
- Override `mid_do()` or `pre_do()` to adjust priority or veto requests before they leave the sequencer.
- Enable the UVM Command Line Processor (`+UVM_CMDLINE_PROC`) to inspect (`uvm_report_sequences`) or reprioritize sequences live.

> **Need a playground?** Launch the [Sequencer Arbitration Sandbox](/exercises/sequencer-arbitration) to visualize how FIFO, weighted, and random policies respond when multiple sequences contend for the same driver. The sandbox mirrors the code patterns in this module so you can experiment safely before editing your bench.

### Accuracy toolkit

| Goal | Technique | Coverage / Metric |
| --- | --- | --- |
| Prove fairness of weighted arbitration | Instrument `pre_do()` to log `sequence_ptr.get_name()` and build a per-sequence histogram | Functional coverage bin on `current_sequence.kind` with min hits per weight |
| Detect stale lock ownership | Add an assertion that `locked_sequence` matches the sequence requesting item in `mid_do()` | Immediate assertion or scoreboard check incrementing a “lock misuse” counter |
| Validate virtual sequences honor handshake contracts | Trigger analysis events from drivers and wait on them inside the virtual sequence instead of `#delays` | Functional coverage on event ordering + watcher sequences that fail if monitor event arrives late |

Before sign-off, capture these metrics in your verification plan so stakeholders see concrete evidence that arbitration tweaks did not starve critical stimulus streams.

## Make It Work
1. **Expose sequencer handles:** Add a virtual sequencer component in your environment, wire agent sequencers into it during `connect_phase`.
2. **Author atomic + scenario sequences:** Keep helpers small so virtual sequences simply choose the right combinations.
3. **Build the virtual sequence:** Extend `uvm_sequence`, use `p_sequencer` to access the virtual sequencer, and coordinate via events/analysis ports instead of `#delays`.
4. **Schedule from tests:** Start the virtual sequence in `run_phase`, or set it as the `default_sequence` on the virtual sequencer through `uvm_config_db`.

**Checklist before moving on:**
- [ ] You can explain how a virtual sequence gains access to two different sequencers.
- [ ] You know when to reach for `lock()` versus `grab()`.
- [ ] You have a layered plan for combining atomic, scenario, and test-level sequences.

## Push Further
- **Event-driven synchronization:** Wait on monitor-driven events before triggering dependent stimulus.
- **Sequence libraries:** Register families of related sequences to randomize or weight scenario mixes.
- **Live debugging:** Use the command line processor to tweak priorities or pause sequencers mid-simulation.
- **Scale to SoC:** Combine VIP sequences with custom agents by driving them from a single SoC virtual sequencer.
- **Fairness scorecard:** Export the arbitration histogram from the sandbox or from your bench’s logging hook and attach it to your regression dashboard. Target a 95th-percentile latency that meets spec for every critical sequence class.

## Practice & Reinforce
- Study the layering patterns in [/curriculum/T3_Advanced/A-UVM-1_Advanced_Sequencing/layered-sequences](./layered-sequences).
- Revisit the handshake deep-dive: [/curriculum/T3_Advanced/A-UVM-1_Advanced_Sequencing/sequencer-driver-handshake](./sequencer-driver-handshake).
- Build your own virtual sequencer using [/curriculum/T3_Advanced/A-UVM-1_Advanced_Sequencing/virtual-sequences](./virtual-sequences) as a starting point.
- Experiment with arbitration in [/curriculum/T3_Advanced/A-UVM-1_Advanced_Sequencing/sequence-arbitration](./sequence-arbitration).
- Wire the environment/test contract in [/curriculum/T3_Advanced/A-UVM-1_Advanced_Sequencing/environment-test-classes](./environment-test-classes).
- Route asynchronous events using [/curriculum/T3_Advanced/A-UVM-1_Advanced_Sequencing/interrupt-handling](./interrupt-handling).
- Strengthen the analysis fabric with [/curriculum/T3_Advanced/A-UVM-1_Advanced_Sequencing/uvm-monitor](./uvm-monitor), [/curriculum/T3_Advanced/A-UVM-1_Advanced_Sequencing/uvm-subscriber](./uvm-subscriber), and [/curriculum/T3_Advanced/A-UVM-1_Advanced_Sequencing/uvm-scoreboard](./uvm-scoreboard).
- Curate reusable stimulus pools via [/curriculum/T3_Advanced/A-UVM-1_Advanced_Sequencing/sequence-libraries](./sequence-libraries).

## References & Next Topics
- Accellera *UVM User Guide*, Chapter 5 (sequencers & sequences).
- Verification Academy, *Virtual Sequences and Layered Stimulus* webinar.
- PCIe layered stimulus case study in [/curriculum/T3_Advanced/A-UVM-1_Advanced_Sequencing/sequence-libraries](./sequence-libraries).
- Next: [/curriculum/T3_Advanced/A-UVM-2_The_UVM_Factory_In-Depth/index](../A-UVM-2_The_UVM_Factory_In-Depth/index) to wire factory overrides into these layered sequences.
