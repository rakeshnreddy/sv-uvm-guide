import { InfoPage } from "@/components/templates/InfoPage";

export const metadata = {
  title: "uvm_subscriber in Practice | Advanced UVM Sequencing",
  description: "Leverage uvm_subscriber to capture analysis traffic for coverage, scoreboards, and telemetry without bloating monitors.",
};

<InfoPage
  title="uvm_subscriber in Practice"
  uvm_concept_tags={["uvm_subscriber", "analysis", "coverage"]}
>

  ## Elevator Pitch

  `uvm_subscriber` lets you observe analysis traffic without modifying agents. Use it for coverage, metrics, or interrupt routing: implement `write()`, plug into analysis ports, and keep observers modular.

  ## Subscriber Blueprint

  ```systemverilog
  class txn_cov_sub extends uvm_subscriber#(mem_item);
    `uvm_component_utils(txn_cov_sub)

    covergroup cg @(posedge vif.clk);
      option.per_instance = 1;
      addr_cp : coverpoint tr.addr {
        bins low  = {[0    :16'h0FFF]};
        bins mid  = {[16'h1000:16'h8FFF]};
        bins high = {[16'h9000:16'hFFFF]};
      }
      op_cp   : coverpoint tr.op;
      cross addr_cp, op_cp;
    endgroup

    virtual function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      cg = new();
    endfunction

    // Latest transaction for use inside the covergroup sample
    mem_item tr;

    virtual function void write(mem_item t);
      tr = t.clone();
      cg.sample();
    endfunction
  endclass
  ```

  **Key takeaways**
  - Lines 2-6 show the minimal subscriber shell: factory registration plus a covergroup definition.
  - Lines 8-20 sample coverage directly from analysis traffic—no monitor edits required.
  - Lines 22-29 clone the incoming item before storing it so other subscribers cannot mutate shared state.

  ## Usage Patterns

  - **Coverage collectors:** Each coverage aspect (transactions, interrupts, responses) gets a dedicated subscriber to keep bins focused.
  - **Scoreboard bridges:** Subscribers can push transactions into queues or analysis FIFOs consumed by scoreboards.
  - **Telemetry:** Send statistics to JSON loggers or databases by formatting transactions in `write()`.
  - **Filtering:** Override `write()` to skip noise—for example, ignore idle packets or zero-length bursts.
  - **Interactive rehearsal:** Pair this page with the [Scoreboard Connector exercise](/exercises/scoreboard-connector) and the Tier-2 [coverage options refresher](/curriculum/T2_Intermediate/I-SV-3_Functional_Coverage/coverage-options) to see how subscribers feed both checking and coverage.

  ## Wiring Tips

  - Connect subscribers in the environment’s `connect_phase`: `agent.analysis_port.connect(sub.analysis_export);`.
  - Use the same subscriber in multiple environments by registering via config DB and retrieving handles inside tests.
  - When sampling coverage, get a virtual interface (`vif`) through the config DB if the covergroup needs a clock.

  ## Quiz Yourself

  **Where should a coverage subscriber connect?**
  - Directly to the driver
  - To the agent's analysis port *(correct)*
  - Inside a sequence
  - It doesn't need a connection

  **Why clone the transaction in `write()`?**
  - To randomize it again
  - To avoid aliasing when other subscribers modify the same object *(correct)*
  - Because coverage cannot see original data
  - To change the sequence ID

</InfoPage>
