import { InfoPage } from "@/components/templates/InfoPage";
import { InteractiveCode, Quiz } from "@/components/ui";

export const metadata = {
  title: "Environment & Test Classes | Advanced UVM Sequencing",
  description: "Structure environments and tests to configure agents, publish sequencer handles, and launch layered stimulus cleanly.",
};

<InfoPage
  title="Environment & Test Classes"
  uvm_concept_tags={["environment", "uvm_test", "configuration"]}
>

  ## Elevator Pitch

  The environment aggregates agents, the test orchestrates them. Advanced sequencing hinges on clean contracts between the two: config all knobs in `build_phase`, wire sequencers during `connect_phase`, and let tests focus on selecting stimulus—not plumbing.

  ## Environment Skeleton

  <InteractiveCode
    language="systemverilog"
    fileName="soc_env.sv"
    code={`
class soc_env extends uvm_env;
  `uvm_component_utils(soc_env)

  apb_agent     apb_agt;
  axi_agent     axi_agt;
  irq_agent     irq_agt;
  soc_vseqr     vseqr;
  scoreboard    scb;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);

    apb_agt = apb_agent::type_id::create("apb_agt", this);
    axi_agt = axi_agent::type_id::create("axi_agt", this);
    irq_agt = irq_agent::type_id::create("irq_agt", this);
    vseqr   = soc_vseqr::type_id::create("vseqr", this);
    scb     = scoreboard::type_id::create("scb", this);

    uvm_config_db#(virtual apb_if)::set(this, "apb_agt.drv", "vif", cfg.apb_vif);
    uvm_config_db#(virtual axi_if)::set(this, "axi_agt.drv", "vif", cfg.axi_vif);
  endfunction

  function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);

    vseqr.apb_sqr = apb_agt.sqr;
    vseqr.axi_sqr = axi_agt.sqr;
    vseqr.irq_sqr = irq_agt.sqr;

    apb_agt.analysis_port.connect(scb.exp_apb);
    axi_agt.analysis_port.connect(scb.exp_axi);
  endfunction
endclass
    `}
    explanationSteps={[
      { target: "1-15", title: "Component aggregation", explanation: "Environment instantiates agents, the virtual sequencer, and the scoreboard." },
      { target: "17-23", title: "Configuration injection", explanation: "`uvm_config_db` drives virtual interfaces and knobs into lower components." },
      { target: "25-33", title: "Sequencer publishing", explanation: "Virtual sequencer picks up agent sequencer handles during `connect_phase`." },
      { target: "35-37", title: "Analysis wiring", explanation: "Monitors feed the scoreboard’s expected streams." }
    ]}
  />

  ## Test Responsibilities

  - Choose which sequences run (`default_sequence` or explicit `start`).
  - Configure scenario parameters (`cfg` objects, plusargs, `uvm_cmdline_processor`).
  - Register virtual sequences with the virtual sequencer.
  - Enable scoreboards/coverage components as needed.

  <InteractiveCode
    language="systemverilog"
    fileName="soc_base_test.sv"
    code={`
class soc_base_test extends uvm_test;
  `uvm_component_utils(soc_base_test)
  soc_env    m_env;
  soc_config cfg;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    cfg = soc_config::type_id::create("cfg");
    cfg.randomize() with { boot_mode == DIAGNOSTIC; };
    uvm_config_db#(soc_config)::set(this, "*", "cfg", cfg);

    m_env = soc_env::type_id::create("m_env", this);
  endfunction

  task run_phase(uvm_phase phase);
    super.run_phase(phase);
    phase.raise_objection(this);

    boot_vseq boot = boot_vseq::type_id::create("boot");
    boot.randomize() with { enable_irq_recovery == 1; };
    boot.start(m_env.vseqr);

    phase.drop_objection(this);
  endtask
endclass
    `}
    explanationSteps={[
      { target: "1-11", title: "Configuration object", explanation: "Tests seed configuration, then share it through the config DB." },
      { target: "13-22", title: "Objection control", explanation: "Tests own the simulation timeline—raise before starting sequences, drop when everything is idle." },
      { target: "16-20", title: "Virtual sequence launch", explanation: "Tests start the top-level virtual sequence on the environment’s virtual sequencer." }
    ]}
  />

  ## Best Practices

  - **Single source of truth:** Store handles (virtual interfaces, model references) in a config object rather than scattering `uvm_config_db::set` calls.
  - **Layered tests:** Use inheritance: `soc_base_test` sets up environment; derived tests override knobs or choose different virtual sequences.
  - **Objection timeouts:** Add `phase.phase_done.add` with watchdogs to catch hung sequences.
  - **Reporting:** Prefix test names with intent (`diag_`, `stress_`) so regression dashboards group results meaningfully.

  ## Quiz Yourself

  <Quiz questions={[
    {
      question: "Where should the virtual sequencer obtain handles to the agent sequencers?",
      answers: [
        { text: "Inside each sequence", correct: false },
        { text: "In the environment’s `connect_phase`", correct: true },
        { text: "Within the test’s `run_phase`", correct: false },
        { text: "Directly in the driver", correct: false }
      ],
      explanation: "`connect_phase` is the right spot to wire components after they exist but before stimulus starts." }
    },
    {
      question: "A derived test wants to change boot mode. What is the cleanest approach?",
      answers: [
        { text: "Edit the environment", correct: false },
        { text: "Override the config object in the derived test", correct: true },
        { text: "Modify the driver", correct: false },
        { text: "Set a global variable", correct: false }
      ],
      explanation: "Tests own configuration—override or randomize the config object before the environment reads it." }
    }
  ]} />

</InfoPage>
