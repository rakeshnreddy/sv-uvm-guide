---
title: "E-CUST-1: UVM Methodology Customization"
description: "Design project-wide extensions to UVM—custom bases, phases, and governance—to keep large teams aligned without forking the methodology."
flashcards: "E-CUST-1_Methodology_Customization"
---

import { InteractiveCode } from '@/components/ui';

## Quick Take
- **What it is:** A blueprint for tailoring UVM to your organisation—custom base classes, phases, and guardrails that scale across projects.
- **Why it matters:** Enterprise verification breaks down when every team reinvents the environment; a curated methodology keeps stimulus consistent and debuggable.
- **The Analogy:** Imagine a bespoke software framework: you package utilities, logging, and policy into a base layer so feature teams focus on design-specific checks.

> **Signal:** If every new block duplicates config plumbing or logging conventions, invest in a methodology layer.

## Build Your Mental Model
### Custom base classes
Wrap standard UVM components with project behaviour—configuration handles, logging, metrics—so every derived component inherits the same posture.

<InteractiveCode
  language="systemverilog"
  fileName="proj_component.sv"
  code={`class proj_config extends uvm_object;
  `uvm_object_utils(proj_config)
  bit enable_scoreboard_hooks;
endclass

class proj_component extends uvm_component;
  `uvm_component_utils(proj_component)

  proj_config cfg;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    if (!uvm_config_db#(proj_config)::get(this, "", "proj_cfg", cfg))
      `uvm_fatal("NO_CFG", "Project config missing—ensure base test seeds it")
  endfunction

  virtual function void post_configure();
    // Hook subclasses override
  endfunction
endclass

class proj_driver extends proj_component;
  `uvm_component_utils(proj_driver)

  virtual function void post_configure();
    if (cfg.enable_scoreboard_hooks) begin
      // Register additional analysis exports, instrumentation, etc.
    end
  endfunction
endclass`}
  explanationSteps={[
    { target: "1-6", title: "Central config", explanation: "Establish a single object carrying policy toggles for every component." },
    { target: "8-24", title: "Reusable base", explanation: "Custom base class fetches the config and exposes overridable hooks." },
    { target: "26-35", title: "Lightweight hooks", explanation: "Downstream components override `post_configure` without fiddling with config plumbing." }
  ]}
/>

### Custom phases & schedules
Insert bespoke phases to coordinate activities (firmware load, security attestation, traffic ramp-up) without shoehorning code into `run_phase`.

<InteractiveCode
  language="systemverilog"
  fileName="load_fw_phase.sv"
  code={`class load_fw_phase extends uvm_task_phase;
  `uvm_object_utils(load_fw_phase)
  static load_fw_phase m_inst;

  static function load_fw_phase get();
    if (m_inst == null) m_inst = new("load_fw");
    return m_inst;
  endfunction
endclass

function void base_test::build_phase(uvm_phase phase);
  super.build_phase(phase);
  uvm_phase reset = uvm_reset_phase::get();
  uvm_domain::get_common_domain()
    .add(load_fw_phase::get(), .after_phase(reset));
endfunction

task soc_env::load_fw_phase(uvm_phase phase);
  // Backdoor load firmware images before main stimulus
endtask`}
  explanationSteps={[
    { target: "1-10", title: "Phase singleton", explanation: "Define a single shared instance of the custom phase." },
    { target: "12-18", title: "Schedule insertion", explanation: "Add the phase after reset so everyone participates consistently." },
    { target: "20-23", title: "Opt-in implementation", explanation: "Environment implements the phase task to inject custom behaviour." }
  ]}
/>

## Make It Work
1. **Codify policy:** Publish a methodology package (base classes, utilities, adapters) with versioning and CI tests.
2. **Seed configuration early:** Base tests push `proj_config` and any shared services (coverage bus, scoreboards) via `uvm_config_db`.
3. **Offer extension hooks:** Provide virtual methods or callbacks instead of hard-coded behaviour so block teams extend safely.
4. **Enforce adoption:** Create linting/check scripts that forbid raw `uvm_component` inheritance or missing custom phases.

**Checklist before moving on:**
- [ ] You know where methodology overrides live (base tests, packages, repos).
- [ ] You have a plan to distribute configs and shared services automatically.
- [ ] You can describe how teams add behaviour via hooks/callbacks instead of editing core code.

## Push Further
- **CI governance:** Automate regression of methodology examples to catch breaking changes before they hit projects.
- **Documentation portal:** Host API docs and playbooks so new hires ramp quickly.
- **Metrics integration:** Instrument base classes with telemetry (coverage snapshots, performance counters).
- **Multi-site scaling:** Pair methodology releases with change logs, migration guides, and support rotations.

## Practice & Reinforce
- Extend the base class hook to register security monitors only when a flag is set.
- Prototype a `load_fw_phase` on your SoC bench and measure boot-time savings.
- Add a lint rule ensuring all components inherit from `proj_component`.
- Review [/curriculum/T3_Advanced/A-UVM-2_The_UVM_Factory_In-Depth/index](../../T3_Advanced/A-UVM-2_The_UVM_Factory_In-Depth/index) to align factory policy with methodology layers.

## References & Next Topics
- Accellera *UVM User Guide*, Section 7 (Phases) and Annex for methodology tips.
- Internal methodology portal or coding standards.
- Next: tackle Tier-4 debug and performance modules to round out expert-level infrastructure.
