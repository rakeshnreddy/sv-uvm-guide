---
title: "E-DBG-1: Advanced UVM Debug Methodologies"
description: "Instrument complex UVM environments with reporting, objections, and transaction timelines so failures localize themselves." 
flashcards: "E-DBG-1_Advanced_Debug"
---

import { InteractiveCode } from '@/components/ui';
import DebuggingSimulator from '@/components/ui/DebuggingSimulator';
import UvmTestbenchVisualizer from '@/components/diagrams/UvmTestbenchVisualizer';

## Quick Take
- **What it is:** A stack of debug tactics—reporting filters, objection tracing, transaction recording, and performance profiling—for deep UVM environments.
- **Why it matters:** Overnight regressions stall when hangs and race conditions hide; disciplined instrumentation surfaces root causes quickly.
- **The Analogy:** Think of an air-traffic control center: correlated radar (transactions), radio transcripts (logs), and black boxes (waveforms) keep the investigation focused when something goes wrong.

> **Signal:** When your team relies on rerunning with `$display` to diagnose issues, upgrade the debug toolkit.

## Build Your Mental Model
### Layered instrumentation
- **Logs first:** Structured `uvm_info` with component IDs + verbosity controls.
- **Objection tracing:** Watch the lifecycle of phase objections to pinpoint hangs.
- **Transaction timelines:** Record sequence_items to waveform or database so cross-interface events align.
- **Environment snapshotting:** Use factory prints, config dumps, and coverage checkpoints to verify setup.

<InteractiveCode
  language="systemverilog"
  fileName="debug_instrumentation.sv"
  code={`class debug_base_test extends uvm_test;
  `uvm_component_utils(debug_base_test)

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    uvm_config_db#(int)::set(null, "*", "recording_detail", UVM_HIGH);
    uvm_report_server server = uvm_report_server::get_server();
    server.set_max_quit_count(1);
  endfunction

  function void end_of_elaboration_phase(uvm_phase phase);
    super.end_of_elaboration_phase(phase);
    uvm_top.set_objection_trace(1);
    factory.print(" +overrides");
  endfunction

  function void start_of_simulation_phase(uvm_phase phase);
    super.start_of_simulation_phase(phase);
    `uvm_info("DEBUG", "Transaction recording enabled", UVM_LOW)
  endfunction
endclass`}
  explanationSteps={[
    { target: "4-9", title: "Config-driven logging", explanation: "Set recording/detail knobs once in the base test so all components inherit the policy." },
    { target: "11-16", title: "Objection trace & factory snapshot", explanation: "Enable objection trace and dump active overrides before stimulus starts." },
    { target: "18-21", title: "Narrate instrumentation", explanation: "Log that recording is on so teammates know where to find timelines." }
  ]}
/>

### Systematic hang triage
Objection drains, watchdogs, and command-line tracing expose components that forget `item_done()` or leave objections raised. Pair with simulators’ live phase viewers (e.g., DVE, Verdi) for real-time insight.

<InteractiveCode
  language="systemverilog"
  fileName="hang_watchdog.sv"
  code={`task debug_base_test::run_phase(uvm_phase phase);
  phase.raise_objection(this);
  fork
    begin
      #1ms;
      `uvm_fatal("WATCHDOG", "Simulation exceeded 1ms without completing")
    end
    super.run_phase(phase);
  join_any;
  disable fork;
  phase.drop_objection(this);
endtask`}
  explanationSteps={[
    { target: "1-3", title: "Proactive objection", explanation: "Base test holds the run phase open while watchers execute." },
    { target: "4-8", title: "Timeout thread", explanation: "Watchdog terminates runaway simulations instead of hanging regressions." },
    { target: "10-11", title: "Clean exit", explanation: "Drop the objection once either branch completes." }
  ]}
/>

### Transaction correlation
Use UVM recording (`UVM_RECORD`) or tool-specific APIs (Verdi `FSDB`, DVE TCL) to align stimulus, monitor data, and scoreboard results. Visuals like `UvmTestbenchVisualizer` reinforce the data flow.

<UvmTestbenchVisualizer />

## Make It Work
1. **Standardize logging:** Define report macros, verbosity defaults, and message IDs in a shared package; ban raw `$display` in code reviews.
2. **Enable tracing knobs:** Always allow `+UVM_OBJECTION_TRACE`, `+UVM_VERBOSITY`, and transaction recording toggles; document recommended settings per debug scenario.
3. **Record what matters:** Annotate sequence items with `UVM_RECORD`, sample analysis FIFOs into debug buffers, and limit waveform scope to reduce noise.
4. **Automate watchdogs:** Install base-test timeouts and phase drains so hung tests fail quickly with actionable context.

**Checklist before moving on:**
- [ ] Logs include component path + unique message IDs.
- [ ] Objection trace plusargs are exercised regularly.
- [ ] You can generate a merged transaction timeline across interfaces.
- [ ] Watchdogs or drain times cap regression hangs.

## Push Further
- **Tool scripts:** Integrate Verdi/DVE macros that auto-load relevant waveforms and bookmarks for failing seeds.
- **Performance profiling:** Schedule regular simulator profiling runs to keep debug from introducing bottlenecks.
- **Debug dashboards:** Stream key metrics (active objections, pending transactions) to a live dashboard during long runs.
- **Cross-team playbooks:** Document debug recipes (hang triage, scoreboard mismatch, factory confusion) in a shared portal.

## Practice & Reinforce
- Exercise objection tracing on a failing test and inspect the trace output.
- Use `DebuggingSimulator` to rehearse hang resolution scenarios in [/curriculum/T4_Expert/E-DBG-1_Advanced_UVM_Debug_Methodologies/hang-lab](./hang-lab) (create as needed).
- Configure transaction recording on one agent and replay the timeline in your waveform viewer.
- Pair with [/curriculum/T4_Expert/E-PERF-1_UVM_Performance/index](../E-PERF-1_UVM_Performance/index) to ensure debug instrumentation doesn’t tank performance.

## References & Next Topics
- Accellera *UVM User Guide*, Appendix C (command-line processor) and debug sections.
- Mentor/Siemens Verdi, Synopsys Verdi, Cadence SimVision user guides for UVM-aware debug.
- Internal debug playbooks and regression dashboards.
- Next: explore expert-level performance tuning (E-PERF-1) to keep instrumented benches fast.
