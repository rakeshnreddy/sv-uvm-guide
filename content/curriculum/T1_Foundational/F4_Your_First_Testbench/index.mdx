---
title: 'Module F-4: Your First Testbench'
description: 'A guided, hands-on lab to build your first simple, self-checking SystemVerilog testbench.'
---

import { Card } from '@/components/ui/Card';
import { CodeBlock } from '@/components/ui/CodeBlock';

## Module F-4: Your First Testbench

Welcome to the capstone of Tier 1! It's time to apply what you've learned and have your first "Hello, World!" moment in functional verification. In this guided lab, you will write a complete, self-checking testbench for a simple 2-input AND gate.

This process will introduce you to the three fundamental pillars of any simulation-based verification task:
1.  **Instantiating the DUT**: Creating an instance of the hardware design you want to test.
2.  **Generating Stimulus**: Driving signals into the DUT's inputs.
3.  **Checking Correctness**: Observing the DUT's outputs and comparing them against expected values.

### The Device Under Test (DUT)

Our DUT is the simple `and_gate` module you saw in a previous module. The code, which is provided for you in `/labs/common/rtl/and_gate.sv`, looks like this:

<CodeBlock language="systemverilog">{`
// Provided in: /labs/common/rtl/and_gate.sv
module and_gate (
  input  logic a,
  input  logic b,
  output logic y
);

  // This is the design's logic
  assign y = a & b;

endmodule
`}</CodeBlock>

### Step 1: Instantiate the DUT

First, we need a testbench module to contain our test. We'll call it `tb_and_gate`. Inside this module, we need to create an *instance* of the `and_gate` DUT.

We've provided a skeleton file for you in `/labs/simple_dut/lab1_first_tb/work/tb_and_gate.sv`. It already contains the DUT instantiation. Notice how we declare signals within the testbench (`tb_a`, `tb_b`, `tb_y`) and connect them to the DUT's ports.

<CodeBlock language="systemverilog">{`
// From: /labs/simple_dut/lab1_first_tb/work/tb_and_gate.sv
module tb_and_gate;

  // Declare signals to connect to the DUT
  logic tb_a;
  logic tb_b;
  logic tb_y;

  // Instantiate the DUT, mapping its ports to our testbench signals
  and_gate dut (
    .a(tb_a),
    .b(tb_b),
    .y(tb_y)
  );

  // ... Your stimulus and checking code will go here ...

endmodule
`}</CodeBlock>

### Step 2: Generate Stimulus

Now it's your turn to write some code. Inside the `tb_and_gate` module, we need an `initial` block to drive a sequence of values to the DUT's inputs. We'll use simulation delays (`#10`) to wait for 10 time units between input changes, giving the DUT time to respond.

**Your Task:** Add the following `initial` block to your `tb_and_gate.sv` file.

<CodeBlock language="systemverilog">{`
  // Your stimulus generation code
  initial begin
    $display("Starting simulation...");

    // Test case 1: a=0, b=0
    tb_a = 0; tb_b = 0; #10;

    // Test case 2: a=0, b=1
    tb_a = 0; tb_b = 1; #10;

    // Test case 3: a=1, b=0
    tb_a = 1; tb_b = 0; #10;

    // Test case 4: a=1, b=1
    tb_a = 1; tb_b = 1; #10;

    $display("Simulation finished.");
  end
`}</CodeBlock>

### Step 3: Implement a Self-Check

Driving stimulus is great, but a test is useless if it doesn't check for correctness. We need a way to see the DUT's output (`tb_y`) and compare it against the *expected* result.

We can do this with a separate `always` block that continuously monitors the DUT's output and compares it to a calculated "golden" value. We'll use the `$display` and `$error` system tasks to print pass/fail messages.

**Your Task:** Add the following `always` block to your `tb_and_gate.sv` file. This is your "checker."

<CodeBlock language="systemverilog">{`
  // Self-checking logic
  always @(tb_y) begin
    logic expected_y;
    expected_y = tb_a & tb_b; // Calculate the expected value

    if (tb_y === expected_y) begin
      $display("PASSED: a=%b, b=%b -> y=%b", tb_a, tb_b, tb_y);
    end else begin
      $error("FAILED: a=%b, b=%b -> y=%b, expected=%b", tb_a, tb_b, tb_y, expected_y);
    end
  end
`}</CodeBlock>

### Putting It All Together

Once you've added both the `initial` block for stimulus and the `always` block for checking, you'll have a complete, self-checking testbench! The full solution is available for you to check your work in `/labs/simple_dut/lab1_first_tb/solution/tb_and_gate.sv`.

Running this test in a simulator would produce a log file showing the pass/fail messages, giving you immediate feedback on whether your DUT is behaving as expected.

---

### Key Takeaways
- **Instantiate, Drive, Check**: This is the fundamental loop of all verification. You create the DUT, provide it with inputs, and check if its outputs are correct.
- **Testbenches are Active**: A testbench isn't just passive code; it actively drives stimulus and performs checks using procedural blocks (`initial`, `always`).
- **Self-Checking is Critical**: A good testbench doesn't require a human to read waveforms. It programmatically determines pass or fail, making it perfect for automated "regression" testing.
