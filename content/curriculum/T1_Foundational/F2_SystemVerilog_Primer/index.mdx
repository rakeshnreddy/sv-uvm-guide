---
title: 'Module F-2: Digital Logic & HDL Primer'
description: 'A crash course in the essential digital logic and HDL concepts for verification.'
---

import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@/components/ui/Accordion';
import { Card } from '@/components/ui/Card';
import { Quiz } from '@/components/ui/Quiz';
import { CodeBlock } from '@/components/ui/CodeBlock';

## Module F-2: Digital Logic & HDL Primer

### Level 1: The Elevator Pitch

How does a computer actually "think"? At the most basic level, all complex digital hardware, from your phone to a supercomputer, is built from two simple things: **logic gates** and **memory elements**.

- **Logic Gates** are like tiny decision-makers. They take in simple electrical signals (on or off, 1 or 0) and produce a new signal based on a simple rule (like "AND" or "OR").
- **Flip-Flops** are the fundamental memory elements. They can "remember" a single bit of information (a 1 or a 0).

So how do we design a blueprint for billions of these tiny components? We use a **Hardware Description Language (HDL)**, like SystemVerilog. An HDL is a specialized programming language used to describe this hardware blueprint, specifying how the gates and memory should be connected to perform a complex task.

### Level 2: A Practical Explanation

<Accordion type="single" collapsible className="w-full">
  <AccordionItem value="item-1">
    <AccordionTrigger>Combinational Logic</AccordionTrigger>
    <AccordionContent>
      Combinational logic components have outputs that depend *only* on their current inputs. They have no memory of the past. The most common gates are:
      - **AND**: Output is 1 only if *all* inputs are 1.
      - **OR**: Output is 1 if *any* input is 1.
      - **XOR** (Exclusive OR): Output is 1 if inputs are *different*.

      **Truth Table for a 2-input AND gate:**
      | A | B | A AND B |
      |---|---|---------|
      | 0 | 0 |    0    |
      | 0 | 1 |    0    |
      | 1 | 0 |    0    |
      | 1 | 1 |    1    |
    </AccordionContent>
  </AccordionItem>
  <AccordionItem value="item-2">
    <AccordionTrigger>Sequential Logic</AccordionTrigger>
    <AccordionContent>
      Sequential logic components have outputs that depend on both current inputs and their previous state. They have memory. The fundamental building block is the **D-type Flip-Flop**.
      - A **Flip-Flop** captures the value on its 'D' (data) input and holds it on its 'Q' (output) at the precise moment of a **clock edge** (usually the rising edge).
      - A **Register** is simply a collection of flip-flops that stores a multi-bit value.
      This ability to store information, or *state*, is what allows hardware to perform sequential tasks.
    </AccordionContent>
  </AccordionItem>
  <AccordionItem value="item-3">
    <AccordionTrigger>Finite State Machines (FSMs)</AccordionTrigger>
    <AccordionContent>
      An FSM is a design pattern that uses sequential and combinational logic to implement a system that moves between a finite number of defined "states". A simple traffic light is a perfect example: it transitions between Green, Yellow, and Red states based on timers. FSMs are a fundamental concept in controlling the behavior of digital systems.
    </AccordionContent>
  </AccordionItem>
  <AccordionItem value="item-4">
    <AccordionTrigger>HDL Introduction: SystemVerilog</AccordionTrigger>
    <AccordionContent>
      We use HDLs to describe these hardware structures. Here is a minimal, complete SystemVerilog module for a 2-input AND gate.
      <CodeBlock language="systemverilog">{`
module and_gate (
  input  logic a,
  input  logic b,
  output logic y
);

  assign y = a & b;

endmodule
      `}</CodeBlock>
      This code describes a hardware block named `and_gate` with two inputs (`a`, `b`) and one output (`y`). The `assign` statement describes the combinational logic relationship between them.
    </AccordionContent>
  </AccordionItem>
</Accordion>

### Level 3: A 10-Year Veteran's Perspective

The single most important concept to unlearn from a software background is the idea of sequential execution. When you write a Python or C++ program, you know that line 1 executes before line 2. In an HDL, you are not writing a program; you are *describing hardware*.

If you write 100 `assign` statements in a SystemVerilog module, you are describing 100 pieces of combinational logic. In the real hardware, all 100 of these are "executing" simultaneously, all the time. This **inherent parallelism** is the reason hardware is so fast. For a verification engineer, this is critical. You have to constantly think about concurrency: what happens if this signal changes at the exact same time as that signal? These parallel interactions are where the most subtle and dangerous bugs hide. You aren't just testing an algorithm; you are testing a physical machine with countless moving parts all operating at once.

---

### Key Takeaways
- **Combinational vs. Sequential**: Combinational logic depends only on current inputs (e.g., AND gate). Sequential logic depends on current inputs and stored state (e.g., a flip-flop).
- **HDLs Describe Hardware**: Languages like SystemVerilog are used to create a blueprint for a physical, parallel machine.

---

### Test Your Understanding

<Quiz questions={[
  {
    question: "A component whose output depends only on its current inputs is an example of:",
    options: [
      "Sequential Logic",
      "Combinational Logic",
      "A Finite State Machine",
      "A Clock"
    ],
    answer: "Combinational Logic"
  },
  {
    question: "What is the primary purpose of a D-type flip-flop?",
    options: [
      "To perform logical AND operations.",
      "To store a single bit of information on a clock edge.",
      "To describe the physical layout of a chip.",
      "To generate the system clock."
    ],
    answer: "To store a single bit of information on a clock edge."
  },
  {
    question: "Why is the concept of 'parallelism' so important in hardware verification?",
    options: [
      "It makes the simulation run faster.",
      "All hardware operations happen concurrently, creating complex interactions that must be tested.",
      "It refers to running multiple tests at the same time.",
      "It is a software-only concept that doesn't apply to hardware."
    ],
    answer: "All hardware operations happen concurrently, creating complex interactions that must be tested."
  }
]} />
