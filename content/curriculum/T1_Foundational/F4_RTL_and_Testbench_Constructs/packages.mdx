import { InfoPage } from "@/components/templates/InfoPage";
import { Quiz } from "@/components/ui";

export const metadata = {
  title: "Packages and Compilation Scopes | SystemVerilog Language Foundations",
  description: "Group shared declarations into reusable namespaces and manage visibility.",
};

<InfoPage
  title="Packages and Compilation Scopes"
  sv_concept_tags={["packages", "compilation scopes"]}
>
  ## Elevator Pitch

  Packages bundle related declarations—types, parameters, and functions—so they can be shared like a toolbox across many files.

  ## Practical Explanation

  ```systemverilog
  package math_pkg;
    typedef enum {ADD, SUB} op_t;
    function int do_math(op_t op, int a, b);
      return (op == ADD) ? a + b : a - b;
    endfunction
  endpackage : math_pkg

  import math_pkg::*;   // bring everything into scope

  module top;
    initial $display("%0d", do_math(ADD, 2, 1));
  endmodule
  ```

  Declaring code inside a `package` keeps names organized. Other files access its contents using `import pkg::*` or `import pkg::symbol`. Packages are often placed in separate files and compiled before modules that use them.

  ## Advanced Notes

  * Packages form their own compilation scope; identical names in different packages coexist peacefully.
  * Use `export pkg::*;` within a package to re-export symbols from another package.
  * Avoid wildcard imports in large projects to prevent name collisions; list needed symbols explicitly.

  <Quiz questions={[
    {
      question: "Which statement brings all declarations from `my_pkg` into the current scope?",
      answers: [
        { text: "use my_pkg::*;", correct: false },
        { text: "import my_pkg::*;", correct: true },
        { text: "include my_pkg;", correct: false },
        { text: "export my_pkg::*;", correct: false }
      ],
      explanation: "`import my_pkg::*;` makes every symbol in `my_pkg` visible in the current scope."
    }
  ]} />

</InfoPage>