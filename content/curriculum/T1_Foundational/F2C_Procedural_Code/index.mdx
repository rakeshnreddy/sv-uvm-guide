---
title: "F2C: Procedural Code and Flow Control"
description: "Author deterministic `initial`/`always` blocks, choose the right assignment style, and master control flow."
flashcards: "F2_Data_Types"
---

import { InteractiveCode, Card, CardContent, CardHeader, CardTitle } from '@/components/ui';
import BlockingSimulator from '@/components/animations/BlockingSimulator';

## Quick Take
- **Concurrency baseline:** `initial` and `always_*` blocks execute in parallel; use them to model resets, clocks, and monitors (IEEE 1800-2023 §9.2).
- **Assignment choice:** Blocking (`=`) executes immediately; non-blocking (`<=`) schedules updates at the end of the time step—critical for sequential logic race avoidance (IEEE 1800-2023 §10.4).
- **Flow control toolkit:** `if/else`, `case`, and loop statements organize algorithmic stimulus and checking (IEEE 1800-2023 §12.4–§12.7).

## Build Your Mental Model
Hardware description is inherently parallel. Each procedural block reacts to events while respecting SystemVerilog's scheduling regions. Understanding when an assignment updates is key to matching hardware intent.

### Procedural Blocks
- **`initial`** runs once at time 0—perfect for reset sequences and testbench bring-up (§9.2.1).
- **`always_ff`/`always_comb`/`always_latch`** provide intent-specific templates that guard against mixed sensitivity lists (§9.2.2).
- Multiple blocks can write the same signal; use non-blocking assignments and well-defined arbitration to avoid races.

### Blocking vs. Non-Blocking Assignments
- **Blocking (`=`):** Executes sequentially; later statements in the same block see the updated value immediately (IEEE 1800-2023 §10.4.1).
- **Non-blocking (`<=`):** Schedules the update for the non-blocking assignment (NBA) region, letting all RHS values evaluate before any LHS updates (§10.4.2).
- Rule of thumb: use blocking for combinational logic inside `always_comb`, non-blocking for sequential logic triggered by a clock edge.

<BlockingSimulator />

### Flow Control Patterns
<Card className="my-6 border-emerald-400/40 bg-emerald-500/5">
  <CardHeader>
    <CardTitle>Control Flow At a Glance (IEEE 1800-2023 §12)</CardTitle>
  </CardHeader>
  <CardContent className="grid gap-4 md:grid-cols-3 text-sm">
    <div>
      <p className="font-semibold">Conditionals</p>
      <ul className="list-disc pl-5 space-y-1">
        <li>`if/else` for binary decisions (§12.4).</li>
        <li>`unique`/`priority case` enforce exclusivity and priority (§12.5.2).</li>
        <li>Use default branches to catch unexpected stimulus.</li>
      </ul>
    </div>
    <div>
      <p className="font-semibold">Loops</p>
      <ul className="list-disc pl-5 space-y-1">
        <li>`for` iterates known counts; declare loop variables in the header (§12.7.1).</li>
        <li>`foreach` traverses arrays, including dynamic containers (§12.7.3).</li>
        <li>`while`/`do while` respond to runtime conditions.</li>
      </ul>
    </div>
    <div>
      <p className="font-semibold">Timing</p>
      <ul className="list-disc pl-5 space-y-1">
        <li>`@` event controls align with clocks and handshakes (§9.2.3).</li>
        <li>`#` delays model propagation or waiting periods.</li>
        <li>Combine with assertions to catch misaligned protocols.</li>
      </ul>
    </div>
  </CardContent>
</Card>

### Example: Stimulus Sequencer
<InteractiveCode
  language="systemverilog"
  code={`
module sequencer(input logic clk, reset_n);
  logic [7:0] counter;
  logic       trigger;

  // Reset logic (§9.2.1)
  initial begin
    trigger = 0;
    counter = '0;
    wait (reset_n); // Wait for DUT reset deassertion
    repeat (4) @(posedge clk);
    trigger = 1;
  end

  // Sequential logic using non-blocking assignments (§10.4.2)
  always_ff @(posedge clk or negedge reset_n) begin
    if (!reset_n) begin
      counter <= '0;
    end else if (trigger) begin
      counter <= counter + 1;
    end
  end

  // Combinational check with blocking assignments (§10.4.1)
  always_comb begin
    if (counter == 8'hff) begin
      $warning("Counter saturated");
    end
  end
endmodule
  `}
/>

## Practice Prompts
1. Rewrite a race-prone block using non-blocking assignments and observe the difference in the simulator waveform.
2. Build a sequence driver that uses `foreach` to iterate over a queue of transactions.
3. Replace nested `if/else` constructs with a `unique case` and record how coverage improves.

## LRM References
- IEEE Std 1800-2023 §9 — Procedural blocks, event controls, and scheduling semantics.
- IEEE Std 1800-2023 §10.4 — Blocking vs. non-blocking assignment rules.
- IEEE Std 1800-2023 §12 — Flow control statements and loop constructs.
