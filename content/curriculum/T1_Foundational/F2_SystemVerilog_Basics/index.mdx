---
title: "F2: SystemVerilog Basics"
description: "A comprehensive introduction to the fundamental building blocks of the SystemVerilog language."
---

import { Quiz, InteractiveCode } from '@/components/ui';
import { DiagramPlaceholder } from '@/components/templates/InfoPage';

## Introduction

Welcome to the second module in our foundational tier. Now that you understand *why* we verify, it's time to learn the basic vocabulary of the language we use to do it: **SystemVerilog**. SystemVerilog is a Hardware Description and Verification Language (HDVL), meaning it's used for both designing and testing digital circuits. This module will cover the absolute essentials you need to start reading and writing basic SystemVerilog code.

### Data Types: The Building Blocks

In SystemVerilog, data types define what kind of data a variable or net can hold.

#### `logic`: The Modern Standard

The most important data type for modern SystemVerilog is `logic`. It is a 4-state type, meaning it can hold one of four values:
* `0`: Logic zero
* `1`: Logic one
* `X` or `x`: An unknown or uninitialized value
* `Z` or `z`: High-impedance (tri-stated, like a disconnected wire)

In older Verilog, you had to use `reg` for variables used in procedural blocks and `wire` for signals connecting different parts of a design. SystemVerilog's `logic` type can be used in both contexts, simplifying the language.

**Rule of Thumb:** Always use `logic` unless you have a specific reason to use `wire` (e.g., for a multi-driver net).

<InteractiveCode>
```systemverilog
module data_type_example;
  logic my_variable; // A single bit 4-state variable
  logic [7:0] my_vector; // An 8-bit vector (from bit 7 down to 0)

  initial begin
    my_variable = 'z; // Assign high-impedance
    $display("my_variable is %b", my_variable);

    my_vector = 8'b1010_XXXX; // Assign a value with unknown bits
    $display("my_vector is %h", my_vector);
  end
endmodule
```
</InteractiveCode>

#### Integer Types

SystemVerilog provides several integer types for when you need to work with whole numbers that don't need to model hardware behavior directly (e.g., for loop counters, array indices). These are typically 2-state (0 or 1) and can be more efficient in simulation.

*   `int`: A 32-bit signed integer. The most common choice.
*   `byte`: An 8-bit signed integer.
*   `shortint`: A 16-bit signed integer.
*   `longint`: A 64-bit signed integer.

<InteractiveCode>
```systemverilog
module integer_example;
  initial begin
    int cycle_count = 0;
    for (cycle_count = 0; cycle_count < 5; cycle_count++) begin
      $display("Cycle: %0d", cycle_count);
    end
  end
endmodule
```
</InteractiveCode>

#### Arrays

Arrays are used to hold collections of data.

*   **Fixed-size arrays:** Have a declared, constant size.
*   **Dynamic arrays:** Can grow or shrink at run-time.

<InteractiveCode>
```systemverilog
module array_example;
  logic [7:0] fixed_array [4]; // A fixed-size array of 4 8-bit logic vectors
  int         dynamic_array[]; // A dynamic array of integers

  initial begin
    // Initialize fixed-size array
    fixed_array[0] = 8'hAA;
    fixed_array[3] = 8'h55;
    $display("fixed_array[0] = %h", fixed_array[0]);

    // Initialize and use dynamic array
    dynamic_array = new[3]; // Allocate space for 3 integers
    dynamic_array = '{10, 20, 30};
    $display("Dynamic array size: %0d, contents: %p", dynamic_array.size(), dynamic_array);
  end
endmodule
```
</InteractiveCode>

### Operators

Operators perform operations on variables and values.

#### Logical vs. Bitwise

This is a common point of confusion.
*   **Logical operators (`&&`, `||`, `!`)**: Treat the entire operand as a single TRUE or FALSE value. Used for conditional checks.
*   **Bitwise operators (`&`, `|`, `~`)**: Perform the operation on each bit of the operands individually.

<InteractiveCode>
```systemverilog
module operator_example;
  logic [3:0] a = 4'b1010;
  logic [3:0] b = 4'b0101;

  initial begin
    // Logical AND: (a is non-zero, b is non-zero) -> TRUE
    if (a && b) $display("Logical AND is TRUE");

    // Bitwise AND: 1010 & 0101 -> 0000
    $display("Bitwise AND: %b", a & b);
  end
endmodule
```
</InteractiveCode>

#### Relational and Equality

These operators compare two values.

*   `==` (equality), `!=` (inequality): Standard comparison. Can result in `X` if either operand has `X` or `Z` bits.
*   `===` (case equality), `!==` (case inequality): Compares for an exact match, including `X` and `Z` bits. Will always result in `0` or `1`.

<InteractiveCode>
```systemverilog
module equality_example;
  logic [3:0] a = 4'b101X;
  logic [3:0] b = 4'b101X;
  logic [3:0] c = 4'b1010;

  initial begin
    // Standard equality with X results in X (unknown)
    $display("a == b: %b", a == b);

    // Case equality checks for an exact bit-for-bit match
    $display("a === b: %b", a === b);
    $display("a === c: %b", a === c);
  end
endmodule
```
</InteractiveCode>

### Syntax and Structure

#### Modules

A `module` is the fundamental building block in SystemVerilog. It's a container for your design or testbench code.

```systemverilog
module my_module;
  // Your code goes here
endmodule
```

#### Comments

*   `//`: Single-line comment
*   `/* ... */`: Multi-line comment

#### Literals

Literals are how you define constant values. The syntax is `size'base_format`value.

*   `4'b1010` // 4-bit binary value
*   `8'hFF`   // 8-bit hexadecimal value
*   `100`      // 32-bit decimal value by default

### Simulation Basics

#### Timescale

The `` `timescale `` directive specifies the time units and precision for the simulation. `` `timescale 1ns / 1ps `` means that `#1` corresponds to 1 nanosecond, and the simulation precision is 1 picosecond.

#### Delays

The `#` symbol is used to introduce delays. `#10` pauses the execution for 10 time units.

#### Displaying Information

*   `$display`: Prints a message and adds a newline character.
*   `$write`: Prints a message without a newline.
*   **Format Specifiers**: `%d` (decimal), `%h` (hex), `%b` (binary), `%t` (time).

<InteractiveCode>
```systemverilog
`timescale 1ns/1ps

module display_example;
  initial begin
    $write("Time: %0t: ", $time);
    $display("Starting simulation...");
    #10;
    $write("Time: %0t: ", $time);
    $display("Finished after 10ns.");
  end
endmodule
```
</InteractiveCode>

## Key Takeaways

*   Use `logic` as your default data type for hardware modeling.
*   Use `int` for simulation-only counters and loops.
*   Understand the difference between logical (`&&`, `||`) and bitwise (`&`, `|`) operators.
*   Use `===` when you need to explicitly check for `X` or `Z` values.
*   Modules are the basic building blocks of SystemVerilog code.
*   The `$display` command is your primary tool for printing information.

## Check Your Understanding

<Quiz questions={[
    {
      "question": "What is the main advantage of using `logic` over the older `reg` and `wire` types?",
      "answers": [
        {"text": "`logic` can hold more values.", "correct": false},
        {"text": "`logic` can be used in both procedural blocks and continuous assignments, simplifying the code.", "correct": true},
        {"text": "`logic` is a 2-state type, which is more efficient.", "correct": false},
        {"text": "`logic` is a new name for `wire`.", "correct": false}
      ],
      "explanation": "`logic` unifies the concepts of `reg` and `wire`, allowing it to be driven by both procedural assignments (like `reg`) and continuous assignments (like `wire`), which makes writing code more straightforward."
    },
    {
      "question": "If `a = 4'b1100` and `b = 4'b1010`, what is the result of `a & b` (bitwise AND)?",
      "answers": [
        {"text": "`1` (TRUE)", "correct": false},
        {"text": "`4'b1000`", "correct": true},
        {"text": "`4'b1110`", "correct": false},
        {"text": "`0` (FALSE)", "correct": false}
      ],
      "explanation": "A bitwise AND compares each bit individually: (1&1=1), (1&0=0), (0&1=0), (0&0=0). So, the result is `4'b1000`."
    }
  ]} />
