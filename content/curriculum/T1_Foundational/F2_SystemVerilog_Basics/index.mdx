---
title: "F2: SystemVerilog Language Basics"
description: "A comprehensive introduction to the fundamental building blocks of the SystemVerilog language."
flashcards: "F2_Data_Types"
---

import { Quiz, InteractiveCode } from '@/components/ui';
import DataTypeComparisonChart from '@/components/charts/DataTypeComparisonChart';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/Card';
import ProceduralBlocksSimulator from '@/components/animations/ProceduralBlocksSimulator';

## Introduction

Welcome to the second module in our foundational tier. Now that you understand *why* we verify, it's time to learn the basic vocabulary of the language we use to do it: **SystemVerilog**. SystemVerilog is a Hardware Description and Verification Language (HDVL), meaning it's used for both designing and testing digital circuits. This module will cover the absolute essentials you need to start reading and writing basic SystemVerilog code.

## Quick Take
- **Why it matters:** SystemVerilog powers both the DUT and the testbench—choosing the right construct keeps designs faithful and verification nimble.
- **Two worlds:** 4-state types (`logic`) mirror uncertain hardware; 2-state types (`bit`, `int`) keep verification math fast.
- **Analogy:** Think laboratory gear—`logic` is the rugged oscilloscope probe, `wire` is the shared power rail, and `bit`/`int` are precision tweezers for algorithmic work.

> **Visual cue:** Keep the comparison chart and interactive snippet below handy—treat them as your quick-reference cheat sheet.


## Legacy Intro Spotlight


**What is it?** SystemVerilog is the universal language of modern chip design. It's used to both design and verify hardware.

**The Analogy:** Think of SystemVerilog as the "English" of the hardware world. It's the language that everyone speaks, whether they're designing the chip or testing it.

**Why this matters:** To be a verification engineer, you need to be fluent in SystemVerilog. It's the language you'll use every day to write testbenches, create stimulus, and check for bugs.

## Level 2: A Practical Explanation

### Module Structure

The fundamental building block of any SystemVerilog design or testbench is the `module`. A module is a self-contained block with a defined set of `ports` (inputs and outputs) that allow it to connect to other modules.

<InteractiveCode
  code={`
module my_module (
  input  logic clk,
  input  logic reset,
  output logic [7:0] data_out
);
  // Module content goes here
endmodule
  `}
  language="systemverilog"
/>

### The 'logic' Data Type

The most common data type in SystemVerilog is `logic`, which is a **4-state** type.
- **0**: Logic zero.
- **1**: Logic one.
- **X**: An unknown value.
- **Z**: High-impedance.

### Procedural Blocks

Procedural blocks are chunks of code that execute in a more "program-like" way.
- **`initial` block**: Executes once at the beginning of the simulation.
- **`always_comb` block**: Models combinational logic.
- **`always_ff` block**: Models sequential, or clocked, logic.

## Level 3: A 10-Year Veteran's Perspective

A common point of confusion is the difference between "synthesizable" and "non-synthesizable" SystemVerilog.
- **Synthesizable code** is a subset of the language that can be automatically converted into a physical hardware implementation.
- **Non-synthesizable code** includes the full power of the language, with many abstract constructs that are incredibly useful for verification but have no direct hardware equivalent.

As a verification engineer, you have the freedom to use the entire language to its fullest extent to stress the DUT.

## Digital Logic & HDL Primer

### Combinational Logic

Digital designs start with combinational logic—gates whose outputs depend only on the current inputs. AND, OR, and XOR gates are the building blocks you will still model day to day when you sanity-check DUT behaviour.

<InteractiveCode
  code={`
module and_gate (
  input  logic a,
  input  logic b,
  output logic y
);
  assign y = a & b;
endmodule
  `}
  language="systemverilog"
  fileName="and_gate.sv"
/>

- **AND** emits `1` only when every input is `1`.
- **OR** drives `1` when any input is `1`.
- **XOR** highlights mismatches—perfect for parity and quick error detection.

When you read a DUT spec, translate each logical requirement into simple gate-level relationships like this. It keeps checkers honest and catches typos in truth tables before they become silicon bugs.

### Sequential Building Blocks

Sequential logic remembers the past. Flip-flops and registers capture data on a clock edge and hold it for later comparison.

<InteractiveCode
  code={`
module register #(parameter WIDTH = 8) (
  input  logic clk,
  input  logic rst,
  input  logic [WIDTH-1:0] d,
  output logic [WIDTH-1:0] q
);
  always_ff @(posedge clk or posedge rst) begin
    if (rst) begin
      q <= '0;
    end else begin
      q <= d;
    end
  end
endmodule
  `}
  language="systemverilog"
  fileName="register.sv"
/>

- Use non-blocking assignments inside sequential blocks so every flop samples the same timestep.
- Parameterise width early; your future self will repurpose the module for buses of different sizes.

### Think in Parallel

Hardware does not execute line by line—every `assign`, `always_ff`, and concurrent block runs together. When you add ten assignments to a module you just described ten pieces of always-on logic.

> This mindset shift is essential for verification. Race conditions, simultaneous edges, and handshake skew only appear when you imagine **all** blocks toggling at once. Build tiny mental timelines or wave sketches as you read RTL so your assertions cover the right windows.

## Build Your Mental Model

Start by separating the hardware-friendly subset from the verification helpers, then map out the core data structures you'll reach for every day.

## Synthesizable vs. Verification Code

SystemVerilog lives a double life. A subset of the language maps directly to hardware gates—**synthesizable code**. Another subset exists purely for testbenches—**non-synthesizable verification code** that only the simulator understands.

- *Design side:* RTL modules, always blocks, and signals must obey synthesizable rules so tools can convert them into transistors.
- *Verification side:* Classes, randomization, mailboxes, `initial` blocks, and `$display` calls make simulations smarter but never turn into silicon.

> **Mental model:** Think of synthesizable code as the blueprint the fabrication plant reads, while verification code is the inspection checklist the shop floor uses to prove the blueprint works.

Knowing which constructs belong to each world keeps your designs portable and your testbenches expressive. As you read the rest of this module, ask yourself: *Would this line run in hardware, or only in the simulator?*

| Common Construct | Synthesizable? | Why it matters |
| --- | --- | --- |
| `always_ff`, `always_comb`, continuous `assign` | ✅ | Infers flip-flops, combinational logic, and net drivers the tool can synthesize. |
| `initial`, `final`, classes, randomization | ❌ | Simulator-only helpers that provide testbench behavior but cannot map to hardware. |
| Interfaces, packages | ✅ (structure) | Great for design partitioning; contents may still include non-synthesizable helpers. |
| Mailboxes, semaphores, queues | ❌ | Behavioral verification constructs—the DUT will never “see” them. |

## Data Types: The Building Blocks

In SystemVerilog, data types define what kind of data a variable or net can hold.

### `logic`: The Modern Standard

The most important data type for modern SystemVerilog is `logic`. It is a 4-state type, meaning it can hold one of four values:
* `0`: Logic zero
* `1`: Logic one
* `X` or `x`: An unknown or uninitialized value
* `Z` or `z`: High-impedance (tri-stated, like a disconnected wire)

In older Verilog, you had to use `reg` for variables used in procedural blocks and `wire` for signals connecting different parts of a design. SystemVerilog's `logic` type can be used in both contexts, simplifying the language.

**Rule of Thumb:** Always use `logic` unless you have a specific reason to use `wire` (e.g., for a multi-driver net).

> **Two-state alternative:** Reach for `bit` when you need a fast, 2-state scalar for counters and flags. Keep `logic` where you care about modelling `X`/`Z` conditions that expose resets or bus contention.

`logic` intentionally disallows multiple procedural drivers so that contention turns into compile errors. If you really do need wired-OR behavior or tri-stated outputs, declare the net as `wire`/`tri` and drive it with `assign` statements or interface modports.

<InteractiveCode>
```systemverilog
module data_type_example;
  logic my_variable; // A single bit 4-state variable
  logic [7:0] my_vector; // An 8-bit vector (from bit 7 down to 0)

  initial begin
    my_variable = 'z; // Assign high-impedance
    $display("my_variable is %b", my_variable);

    my_vector = 8'b1010_XXXX; // Assign a value with unknown bits
    $display("my_vector is %h", my_vector);
  end
endmodule
```
</InteractiveCode>

### Integer Types

SystemVerilog provides several integer types for when you need to work with whole numbers that don't need to model hardware behavior directly (e.g., for loop counters, array indices). These are typically 2-state (0 or 1) and can be more efficient in simulation.

*   `int`: A 32-bit signed integer. The most common choice.
*   `byte`: An 8-bit signed integer.
*   `shortint`: A 16-bit signed integer.
*   `longint`: A 64-bit signed integer.

<InteractiveCode>
```systemverilog
module integer_example;
  initial begin
    int cycle_count = 0;
    for (cycle_count = 0; cycle_count < 5; cycle_count++) begin
      $display("Cycle: %0d", cycle_count);
    end
  end
endmodule
```
</InteractiveCode>

### Arrays

Arrays are used to hold collections of data.

*   **Fixed-size arrays:** Have a declared, constant size.
*   **Dynamic arrays:** Can grow or shrink at run-time.
*   **Queues:** Dynamic arrays that provide easy ways to add and remove elements from the beginning or end.
*   **Associative arrays:** Use a key of any type to store and retrieve values.

<InteractiveCode>
```systemverilog
module array_example;
  logic [7:0] fixed_array [4]; // A fixed-size array of 4 8-bit logic vectors
  int         dynamic_array[]; // A dynamic array of integers
  string      queue[$];        // A queue of strings
  int         assoc_array[string]; // An associative array mapping strings to integers

  initial begin
    // Initialize fixed-size array
    fixed_array[0] = 8'hAA;
    fixed_array[3] = 8'h55;
    $display("fixed_array[0] = %h", fixed_array[0]);

    // Initialize and use dynamic array
    dynamic_array = new[3]; // Allocate space for 3 integers
    dynamic_array = '{10, 20, 30};
    $display("Dynamic array size: %0d, contents: %p", dynamic_array.size(), dynamic_array);

    // Use a queue
    queue.push_back("hello");
    queue.push_front("world");
    $display("Queue: %p", queue);
    string popped = queue.pop_back();
    $display("After pop_back(): %p (removed %s)", queue, popped);

    // Use an associative array
    assoc_array["foo"] = 123;
    $display("Associative array entry for 'foo': %d", assoc_array["foo"]);
    $display("Does 'bar' exist? %0d", assoc_array.exists("bar"));
  end
endmodule
```
</InteractiveCode>

- **Dynamic helpers:** `size()`, `delete()`, `foreach`, and `exists()` (for associative arrays) keep runtime structures flexible without manual bookkeeping.
- **Packed on the left:** Declare packed dimensions to the left of the identifier (`logic [7:0] data_q [4]`) so bit slicing behaves as expected while leaving software-style indexing on the right.
- **Queues for FIFOs:** `push_back`/`pop_front` (and their `front` counterparts) make queues a perfect stand-in for drivers, scoreboards, or trace buffers.

<div className="my-6">
  <DataTypeComparisonChart />
</div>

### User-Defined Types

SystemVerilog allows you to create your own complex data types.

*   **`struct`**: A collection of variables of different types, grouped together.
*   **`enum`**: A set of named constants.

<InteractiveCode>
```systemverilog
module user_defined_example;
  typedef enum { IDLE, DECODE, EXECUTE } state_t;
  state_t current_state;

  typedef struct {
    logic [31:0] addr;
    logic [31:0] data;
    bit          rw;
  } bus_transaction_t;

  bus_transaction_t transaction;

  initial begin
    current_state = IDLE;
    $display("Current state: %s", current_state.name());
    current_state = current_state.next();
    $display("Next state: %s", current_state.name());

    transaction.addr = 32'h1000;
    transaction.data = 32'hdeadbeef;
    transaction.rw = 1;
    $display("Transaction: %p", transaction);
  end
endmodule
```
</InteractiveCode>

- Tagged unions (`union tagged`) give you safer type switching when you must reinterpret the same bits.
- Keep common typedefs in packages so monitors, scoreboards, and sequences stay aligned.
- Enums expose helper methods like `name()`/`next()` that make logging and assertions readable.

> **Combine for clarity:** Pair enums with arrays or structs to model state machines; your scoreboard logs will thank you when they print `state.name()` instead of raw numbers.

### Operators

Operators perform operations on variables and values.

#### Logical vs. Bitwise

This is a common point of confusion.
*   **Logical operators (`&&`, `||`, `!`)**: Treat the entire operand as a single TRUE or FALSE value. Used for conditional checks.
*   **Bitwise operators (`&`, `|`, `~`)**: Perform the operation on each bit of the operands individually.

<InteractiveCode>
```systemverilog
module operator_example;
  logic [3:0] a = 4'b1010;
  logic [3:0] b = 4'b0101;

  initial begin
    // Logical AND: (a is non-zero, b is non-zero) -> TRUE
    if (a && b) $display("Logical AND is TRUE");

    // Bitwise AND: 1010 & 0101 -> 0000
    $display("Bitwise AND: %b", a & b);
  end
endmodule
```
</InteractiveCode>

#### Relational and Equality

These operators compare two values.

*   `==` (equality), `!=` (inequality): Standard comparison. Can result in `X` if either operand has `X` or `Z` bits.
*   `===` (case equality), `!==` (case inequality): Compares for an exact match, including `X` and `Z` bits. Will always result in `0` or `1`.

<InteractiveCode>
```systemverilog
module equality_example;
  logic [3:0] a = 4'b101X;
  logic [3:0] b = 4'b101X;
  logic [3:0] c = 4'b1010;

  initial begin
    // Standard equality with X results in X (unknown)
    $display("a == b: %b", a == b);

    // Case equality checks for an exact bit-for-bit match
    $display("a === b: %b", a === b);
    $display("a === c: %b", a === c);
  end
endmodule
```
</InteractiveCode>

### Syntax and Structure

#### Modules

A `module` is the fundamental building block in SystemVerilog. It's a container for your design or testbench code.

```systemverilog
module my_module;
  // Your code goes here
endmodule
```

#### Comments

*   `//`: Single-line comment
*   `/* ... */`: Multi-line comment

#### Literals

Literals are how you define constant values. The syntax is `size'base_format`value.

*   `4'b1010` // 4-bit binary value
*   `8'hFF`   // 8-bit hexadecimal value
*   `100`      // 32-bit decimal value by default

### Simulation Basics

#### Timescale

The `` `timescale `` directive specifies the time units and precision for the simulation. `` `timescale 1ns / 1ps `` means that `#1` corresponds to 1 nanosecond, and the simulation precision is 1 picosecond.

A more modern style is to place the settings directly inside a module or package with `timeunit/timeprecision`. That keeps the scope local and avoids macro leakage.

```systemverilog
module timer;
  timeunit 1ns;
  timeprecision 1ps;

  initial begin
    #0.2ns $display("200ps elapsed");
  end
endmodule
```

#### Delays

The `#` symbol is used to introduce delays. `#10` pauses the execution for 10 time units.

#### Displaying Information

*   `$display`: Prints a message and adds a newline character.
*   `$write`: Prints a message without a newline.
*   **Format Specifiers**: `%d` (decimal), `%h` (hex), `%b` (binary), `%t` (time).

<InteractiveCode>
```systemverilog
`timescale 1ns/1ps

module display_example;
  initial begin
    $write("Time: %0t: ", $time);
    $display("Starting simulation...");
    #10;
    $write("Time: %0t: ", $time);
    $display("Finished after 10ns.");
  end
endmodule
```
</InteractiveCode>

---

## Procedural Constructs

Procedural constructs are the parts of SystemVerilog that look and feel like a traditional programming language. They allow you to write sequential, algorithmic code to control the flow of your testbench and model complex behavior.

### `initial`, `always`, and `final` blocks

- **`initial` blocks** are executed only once at the beginning of a simulation.
- **`always` blocks** are executed continuously throughout a simulation. SystemVerilog introduces specialized `always` blocks like `always_comb`, `always_ff`, and `always_latch` to make the design intent clearer.
- **`final` blocks** are executed only once at the end of a simulation.

### Blocking vs. Non-blocking Assignments

A critical concept in procedural blocks is the difference between blocking (`=`) and non-blocking (`<=`) assignments.

- **Blocking assignments (`=`)** are executed in the order they appear in the code.
- **Non-blocking assignments (`<=`)** are scheduled to occur at the end of the current time step.

<InteractiveCode>
```systemverilog
// Example of always_ff for a simple flip-flop
logic clk, reset, d_in, q_out;
always_ff @(posedge clk or posedge reset) begin
  if (reset) begin
    q_out <= 1'b0; // Use non-blocking for state elements
  end else begin
    q_out <= d_in;
  end
end

// Example of always_comb for combinational logic
logic a, b, c, y_comb;
always_comb begin
  y_comb = a & b | c; // Use blocking for combinational logic
end
```
</InteractiveCode>

<ProceduralBlocksSimulator />

### Flow Control

SystemVerilog supports standard flow control statements:
- `if-else`
- `case`, `casex`, `casez`
- `for` loops, `while` loops, `do-while` loops, `foreach` loops

### Tasks and Functions

Tasks and functions allow you to create reusable blocks of procedural code.
- **Functions** execute in zero time and cannot contain delays. They return a single value.
- **Tasks** can contain delays and do not return a value (but can have output arguments).

### Process Control: `fork-join`

The `fork-join` construct allows you to create parallel processes.
- `fork-join`: Waits for all parallel processes to complete.
- `fork-join_any`: Waits for any one of the parallel processes to complete.
- `fork-join_none`: Does not wait for any processes to complete; execution continues immediately.

---

## RTL and Testbench Constructs

SystemVerilog provides a set of building blocks for creating both the hardware design (RTL) and the testbench that verifies it.

### Modules and Interfaces

- **Modules:** The basic building block of a SystemVerilog design.
- **Interfaces:** A way to bundle related signals into a single port. This simplifies connections and improves reusability.

### Packages

Packages are used to group related declarations, such as classes, functions, and tasks. This helps to organize your code and to prevent naming conflicts.

<InteractiveCode>
```systemverilog
package my_pkg;
  // All the declarations in this package can be imported
  // into other modules or packages.

  class my_transaction extends uvm_sequence_item;
    // ...
  endclass
endpackage
```
</InteractiveCode>

### Program and Clocking Blocks

- **Program blocks:** Used to separate the testbench from the DUT, helping to avoid race conditions.
- **Clocking blocks:** Used to define a set of signals that are synchronous to a specific clock, specifying input and output skews to ensure predictable timing.

<InteractiveCode>
```systemverilog
interface my_if(input logic clk);
  logic req, gnt;

  clocking tb_cb @(posedge clk);
    default input #1step output #2;
    output req;
    input gnt;
  endclocking
endinterface
```
</InteractiveCode>

> **When to reach for program blocks?** Modern UVM environments manage ordering internally, so dedicated `program` blocks show up mostly in legacy benches or directed tests. Use one when you need a guaranteed \"testbench runs after DUT\" scheduling wall.

## Make It Work

1. **Map your signals:** Sketch each DUT interface and choose types deliberately—tri-state nets as `wire`, single drivers as `logic`, counters and scoreboards as `bit`/`int`.
2. **Instrument uncertainty:** Add simple assertions or `$fatal` calls when a `logic` value goes `X/Z` outside reset; you will spot wiring mistakes instantly.
3. **Prototype data structures:** Spin up queues, associative arrays, and packed structs in a scratch file to mirror how your testbench will store transactions.

**Checklist before moving on:**
- [ ] You can explain when to grab `logic`, `wire`, or `bit` without peeking at docs.
- [ ] Your sandbox shows how queues/dynamic arrays grow and shrink at runtime.
- [ ] Unknown (`X/Z`) states are either expected or trapped with assertions.

## Push Further

- Benchmark a small regression using `logic` payloads versus `bit` payloads and record the runtime delta.
- Explore nettypes (`tri`, `wand`, `wor`) and document how they behave inside interfaces and scoreboards.
- Serialize a packed struct into a mailbox and reconstruct it in a monitor—compare against your transaction typedef to ensure fidelity.

## Key Takeaways

*   Use `logic` as your default data type for hardware modeling.
*   Understand the difference between logical (`&&`, `||`) and bitwise (`&`, `|`) operators.
*   Use `===` when you need to explicitly check for `X` or `Z` values.
*   Use non-blocking assignments (`<=`) for sequential logic and blocking assignments (`=`) for combinational logic and testbench code.
*   Separate combinational logic from sequential state and remember that every concurrent block runs together.
*   Use interfaces to simplify connections and improve reusability.
*   Use packages to organize your code.
*   Prefer `timeunit/timeprecision` inside scopes instead of a global `` `timescale `` when you can.
*   Reach for queues and associative arrays when verification logic needs elastic storage—keep payloads 2-state when hardware fidelity isn’t required.
*   Define shared structs/enums via `typedef` so every component speaks the same language.

## Check Your Understanding

<Quiz questions={[
    {
      "question": "A block whose output depends only on its current inputs is classified as what?",
      "answers": [
        {"text": "Sequential logic", "correct": false},
        {"text": "Combinational logic", "correct": true},
        {"text": "A Finite State Machine", "correct": false},
        {"text": "A clock divider", "correct": false}
      ],
      "explanation": "Combinational logic reacts instantly to its inputs—there is no stored state across clock edges."
    },
    {
      "question": "What does a D-type flip-flop capture?",
      "answers": [
        {"text": "The logical AND of its inputs", "correct": false},
        {"text": "A single bit on the active clock edge", "correct": true},
        {"text": "An entire transaction payload", "correct": false},
        {"text": "Only rising edges on asynchronous resets", "correct": false}
      ],
      "explanation": "Flip-flops sample `D` on a triggering clock edge and hold it on `Q` until the next edge—this is how sequential state is stored."
    },
    {
      "question": "Why must verification engineers think about parallel execution when reading RTL?",
      "answers": [
        {"text": "Because simulators execute statements sequentially like software.", "correct": false},
        {"text": "Because all concurrent blocks evaluate together and can race or interact in surprising ways.", "correct": true},
        {"text": "Because non-blocking assignments disable concurrency.", "correct": false},
        {"text": "Because clocks only update every other cycle.", "correct": false}
      ],
      "explanation": "Hardware is inherently parallel; understanding simultaneous updates is the only way to write meaningful checks and assertions."
    },
    {
      "question": "What is the main advantage of using `logic` over the older `reg` and `wire` types?",
      "answers": [
        {"text": "`logic` can hold more values.", "correct": false},
        {"text": "`logic` works in both always blocks and continuous assignments, simplifying the code.", "correct": true},
        {"text": "`logic` is a 2-state type, which is more efficient.", "correct": false},
        {"text": "`logic` is a new name for `wire`.", "correct": false}
      ],
      "explanation": "`logic` unifies the concepts of `reg` and `wire`, allowing it to be driven by both procedural assignments (like `reg`) and continuous assignments (like `wire`), which makes writing code more straightforward."
    },
    {
      "question": "If `a = 4'b1100` and `b = 4'b1010`, what is the result of `a & b` (bitwise AND)?",
      "answers": [
        {"text": "`1` (TRUE)", "correct": false},
        {"text": "`4'b1000`", "correct": true},
        {"text": "`4'b1110`", "correct": false},
        {"text": "`0` (FALSE)", "correct": false}
      ],
      "explanation": "A bitwise AND compares each bit individually: (1&1=1), (1&0=0), (0&1=0), (0&0=0). So, the result is `4'b1000`."
    },
    {
      "question": "What is the primary purpose of an interface?",
      "answers": [
        {"text": "To make simulations run faster.", "correct": false},
        {"text": "To bundle related signals into a single, reusable port.", "correct": true},
        {"text": "To define the clocking for a module.", "correct": false},
        {"text": "To replace the need for a testbench.", "correct": false}
      ],
      "explanation": "Interfaces are used to simplify connections between modules and to create clean, modular designs."
    },
    {
      "question": "Which array type lets you push and pop from either end with built-in methods?",
      "answers": [
        {"text": "Packed array", "correct": false},
        {"text": "Dynamic array", "correct": false},
        {"text": "Queue", "correct": true},
        {"text": "Associative array", "correct": false}
      ],
      "explanation": "Queues expose `push_back`, `push_front`, and matching pop operations—perfect for elastic FIFOs in drivers or scoreboards."
    },
    {
      "question": "Why wrap state encodings in an enum instead of raw integers?",
      "answers": [
        {"text": "Enums randomize automatically", "correct": false},
        {"text": "Enums provide symbolic names and helper methods like `name()`", "correct": true},
        {"text": "Enums synthesize faster", "correct": false},
        {"text": "Enums remove the need for typedefs", "correct": false}
      ],
      "explanation": "Enums make logs readable, prevent invalid values, and offer helper utilities—ideal for state machines and coverage." 
    }
  ]} />

## Practice & Reinforce

- Flashcards – Drill `logic` vs. `bit` rules and datatype trade-offs with the linked deck.
- Visual notebook – Capture waveform snapshots showing how `X/Z` propagate, then repeat with 2-state types to compare behaviour.
- Mini-lab – Extend the array example to randomize queue depth and measure runtime differences when payloads switch between `logic` and `bit`.

## References & Next Topics

- Chris Spear & Greg Tumbush, *SystemVerilog for Verification*, Chapter 2 (data types) and Chapter 3 (procedural code).
- Siemens Verification Academy video, “SystemVerilog Data Types in Practice.”
- Ray Salemi, *The UVM Primer*, sections on transaction field design.
- Next: [`/curriculum/T1_Foundational/F3_Procedural_Constructs`](../F3_Procedural_Constructs/) to master the sequential side of SystemVerilog.
