# Procedural Constructs

SystemVerilog provides a variety of procedural constructs for controlling the flow of execution in a testbench. These constructs are essential for creating complex stimulus and for building reactive testbenches that can respond to the behavior of the DUT.

## `initial`, `always`, and `final` blocks

*   **`initial` blocks** are executed only once at the beginning of a simulation. They are often used for initialization tasks, such as setting up the testbench environment and applying initial stimulus to the DUT.
*   **`always` blocks** are executed continuously throughout a simulation. They are used to model combinational and sequential logic, and to create reactive testbenches that can respond to changes in the DUT's state.
*   **`final` blocks** are executed only once at the end of a simulation. They are often used for cleanup tasks, such as printing simulation statistics and closing files.

## Blocking vs. Non-blocking Assignments

A critical concept in procedural blocks is the difference between blocking (`=`) and non-blocking (`<=`) assignments.

*   **Blocking assignments (`=`)** are executed in the order they appear in the code. The next statement is "blocked" until the current one completes. Use these for combinational logic (`always_comb`) and in testbench procedural code where you want sequential execution.
*   **Non-blocking assignments (`<=`)** are scheduled to occur at the end of the current time step. All right-hand side expressions are evaluated first, and then the assignments are made. Use these for sequential logic (`always_ff`) to avoid race conditions and correctly model how flip-flops behave.

<InteractiveCode>
```systemverilog
// Example of always_ff for a simple flip-flop
logic clk, reset, d_in, q_out;
always_ff @(posedge clk or posedge reset) begin
  if (reset) begin
    q_out <= 1'b0; // Use non-blocking for state elements
  end else begin
    q_out <= d_in;
  end
end

// Example of always_comb for combinational logic
logic a, b, c, y_comb;
always_comb begin
  y_comb = a & b | c; // Use blocking for combinational logic
end

// Example illustrating the swap behavior
logic x, y;
// Non-blocking: Correctly swaps x and y
always_ff @(posedge clk) begin
  x <= y; // scheduled update
  y <= x; // scheduled update (uses old value of x)
end

// Blocking: Incorrectly assigns y to x, then the new x back to y
// logic reg_a, reg_b;
// always @(posedge clk) begin
//   reg_a = reg_b;
//   reg_b = reg_a; // reg_b gets the new value of reg_a
// end
```
</InteractiveCode>

<DiagramPlaceholder title="Blocking vs. Non-blocking Assignment Timing" />

## Procedural Flow Control

SystemVerilog provides a variety of procedural flow control statements, including:

*   `if-else`
*   `case`
*   `for`
*   `while`
*   `do-while`
*   `forever`
*   `repeat`

## Tasks and Functions

*   **Tasks** are subroutines that can have input, output, and inout arguments. They can also consume time, which makes them useful for modeling sequential behavior.
*   **Functions** are subroutines that can have input arguments and must return a value. They cannot consume time, which makes them useful for modeling combinational logic.

## Process Control

SystemVerilog provides a variety of process control statements, including:

*   `fork-join`
*   `fork-join_any`
*   `fork-join_none`
*   `disable`
*   `wait`

These statements are used to control the execution of concurrent processes in a testbench.
