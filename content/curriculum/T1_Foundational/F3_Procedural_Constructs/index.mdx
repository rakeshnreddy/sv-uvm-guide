---
title: "F3: Procedural Constructs"
description: "Master the procedural heart of SystemVerilog—initial/always/final blocks, flow control, and assignment semantics that drive every testbench."
flashcards: "F3_Procedural_Constructs"
---

import { InteractiveCode, Quiz } from '@/components/ui';
import ProceduralBlocksSimulator from '@/components/animations/ProceduralBlocksSimulator';

## Quick Take
- **What it is:** Procedural constructs are SystemVerilog’s sequential code paths—`initial`, `always`, `final`, loops, and conditionals—that choreograph stimulus and checking.
- **Why it matters:** Misusing blocking vs. non-blocking assignments or mis-scoping procedural code leads to race conditions, false failures, and weeks of lost debug time.
- **The Analogy:** Picture a stage production: `initial` is the stage manager’s countdown, `always_ff` and `always_comb` are the actors following scripted cues, and flow control is the choreography keeping every move in sync.

> **Visual cue:** This page pairs simulators, code overlays, and animated timelines with the narrative so you can *see* how procedural elements run frame by frame.

## Build Your Mental Model
### Timeline of a Simulation Tick
<div className="my-8 rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur shadow-2xl">
  <ProceduralBlocksSimulator />
</div>

SystemVerilog simulators run every timestep through distinct event regions: **active** (procedural code executes), **inactive** (zero-delay updates), **NBA** (non-blocking assignments commit), and **postponed** (assertion sampling & `final`). Knowing where your code lands explains why a `<=` update appears “later” than a blocking `=`—the simulator is honoring those regions. Internalizing that timeline eliminates the feeling that the tool is acting randomly.

| Region | Who runs here | Debug cue |
| --- | --- | --- |
| Active | `initial`, blocking assignments, tasks | Watch waveform edges jump immediately |
| Inactive | Zero-delay updates (`#0`), event rescheduling | Rare today, but legacy code may rely on it |
| NBA (non-blocking assign) | Sequential `<=` updates | Values “snap” after the active region finishes |
| Postponed | Assertions, `final`, `$strobe` | Perfect spot for end-of-tick checks |

### Interactive Core Patterns
<InteractiveCode
  language="systemverilog"
  fileName="procedural_constructs.sv"
  code={`
logic clk, reset_n, d_in, q_out;

// Sequential region: non-blocking keeps flip-flops in sync
always_ff @(posedge clk or negedge reset_n) begin
  if (!reset_n)
    q_out <= 1'b0;
  else
    q_out <= d_in;
end

// Combinational region: blocking to model logic equations
logic [2:0] state_next;
always_comb begin
  unique case (q_out)
    1'b0: state_next = 3'b001;
    1'b1: state_next = 3'b010;
    default: state_next = 3'b000;
  endcase
end

// Testbench stimulus using initial + fork/join_none
initial begin
  reset_n = 0;
  d_in = 0;
  #10 reset_n = 1;
  fork
    begin // drive pattern
      repeat (5) begin
        #5 d_in = $random;
      end
    end
    begin // monitor
      forever @(posedge clk) $display("time=%0t q_out=%0b", $time, q_out);
    end
  join_none
end

final begin
  $display("Simulation complete. Final state=%0b", q_out);
end
  `}
  explanationSteps={[
    { target: "1-8", title: "Sequential Rules", explanation: "`always_ff` with non-blocking (`<=`) mirrors flip-flop behavior and keeps updates aligned with the clock." },
    { target: "10-16", title: "Combinational Intent", explanation: "`always_comb` and blocking assignments evaluate instantly, catching missing sensitivity list issues automatically." },
    { target: "18-34", title: "Concurrency with Fork/Join", explanation: "Testbenches routinely spawn concurrent threads—one drives stimulus, another checks results—using `fork ... join_none`." },
    { target: "36-38", title: "Graceful Shutdown", explanation: "`final` blocks run once at simulation end—perfect for summaries, coverage dumps, or resource cleanup." }
  ]}
/>

> **Process hygiene:** When you use `fork ... join_none`, give the block a name so you can clean it up later. Pair `disable <label>;` or `process::kill()` with timeouts so runaway threads do not block simulation end.

```systemverilog
fork : stimulus
  begin : driver
    repeat (5) begin
      #5 d_in = $urandom_range(0, 1);
    end
  end
  begin : monitor
    forever @(posedge clk) $display("q_out=%0b", q_out);
  end
join_none

#100 disable stimulus; // tidy up if the threads outlive their usefulness
```

### Common Pitfalls
- Mixing blocking and non-blocking assignments to the same signal, causing races. **Fix:** pick one style per signal—`<=` for sequential flops, `=` for combinational/testbench code.
- Using `always` instead of `always_ff`/`always_comb`, hiding missing signals in sensitivity lists. **Fix:** swap to the intent-specific variants so the compiler enforces reset/clock rules for you.
- Forgetting to terminate `fork/join` threads, leaving simulations hanging. **Fix:** manage spawned processes with `join`, `disable fork`, or `process::kill()` from a handle.

### Case Study: Sequence Detector FSM
Put the guidelines into context with a classic problem: detect the bit pattern `101` on a serial input. A clean implementation separates sequential state updates (`always_ff`) from combinational next-state logic.

<InteractiveCode
  language="systemverilog"
  fileName="sequence_detector.sv"
  code={`
module sequence_detector (
  input  logic clk,
  input  logic reset,
  input  logic din,
  output logic detected
);

  typedef enum logic [1:0] {
    S_IDLE,
    S_GOT_1,
    S_GOT_10
  } state_t;

  state_t state, state_next;

  // Sequential evolution of the state register
  always_ff @(posedge clk or posedge reset) begin
    if (reset)
      state <= S_IDLE;
    else
      state <= state_next;
  end

  // Combinational next-state logic
  always_comb begin
    state_next = state;
    detected = 1'b0;
    unique case (state)
      S_IDLE:   state_next = din ? S_GOT_1  : S_IDLE;
      S_GOT_1:  state_next = din ? S_GOT_1  : S_GOT_10;
      S_GOT_10: begin
        detected   = din;
        state_next = din ? S_GOT_1 : S_IDLE;
      end
    endcase
  end

endmodule
  `}
/>

**What to notice:**
- State updates use non-blocking assignments in `always_ff`, mirroring flip-flop behavior.
- The combinational block seeds `state_next` and `detected` with safe defaults, preventing unintended latches.
- Using `unique case` catches missing branches while documenting intent for tools and reviewers.

### Flow-Control Building Blocks
- **Conditionals (`if`, `case`, `unique case`)** gate behavior inside procedural blocks. Use `unique`/`priority` to signal intent to tools and catch missing branches.
- **Loops (`for`, `foreach`, `while`, `repeat`)** generate structured stimulus. `foreach` shines with dynamic arrays, while `repeat` crafts reset pulses or pattern bursts.
- **Tasks & Functions** wrap procedural logic for reuse. Functions must stay side-effect free; tasks can launch timing controls. Distinguish them so your scoreboard or sequence code remains predictable.

## Make It Work
1. **Set the stage:** Draft a timing diagram for your DUT, marking where sequential and combinational regions live. Annotate which constructs you’ll use (`always_ff`, `always_comb`, `initial`).
2. **Instrument aggressively:** Add assertions that fail if a sequential block uses `=` or if a combinational block uses `<=`. Tools like Verilator and SpyGlass can automate these checks.
3. **Prototype the flow:** Use the interactive snippet above as a template. Swap in your DUT signals and run a quick sim to validate ordering.

**Checklist before moving on:**
- [ ] You can explain why sequential logic needs non-blocking assignments and combinational logic prefers blocking.
- [ ] You’ve run a mini-simulation that includes `initial`, `always_ff`, and `final` blocks working together.
- [ ] You can describe the event scheduling order (active → inactive → NBA → postponed) and place each construct within it.

## Push Further
- Model a multi-threaded sequencer using `fork/join_any` and observe how join semantics affect stimulus timing.
- Rewrite legacy `always @(*)` code with `always_comb` and document the tool warnings that disappear.
- Experiment with `disable fork` to clean up auxiliary threads—visualize the effect in a waveform viewer.

## Practice & Reinforce
- Flashcards – Review definitions for blocking/non-blocking, `always_ff`, `fork/join` semantics.
- Quiz – Complete the knowledge check below.
- Animation lab – Capture a screen recording of the procedural simulator while toggling assignments to see race conditions surface.
- Code kata – Convert a buggy `always` block using blocking assignments into a clean `always_ff` implementation.

## References & Next Topics
- Spear & Tumbush, *SystemVerilog for Verification*, Chapter 3.
- Accellera, *SystemVerilog LRM*, sections on process scheduling.
- Verification Academy session: “Avoiding Race Conditions in SystemVerilog.”
- Next: [`/curriculum/T1_Foundational/F4_RTL_and_Testbench_Constructs`](../F4_RTL_and_Testbench_Constructs/).

<Quiz
  questions={[
    {
      question: 'When should you use a non-blocking assignment (`<=`)?',
      answers: [
        { text: 'In combinational logic (`always_comb`)', correct: false },
        { text: 'In sequential logic (`always_ff`)', correct: true },
        { text: 'Inside `final` blocks', correct: false },
        { text: 'Inside `initial` blocks for stimulus', correct: false }
      ],
      explanation:
        'Non-blocking assignments align with flip-flop behavior and prevent races between concurrent sequential blocks.'
    },
    {
      question: 'Which procedural block runs exactly once after time zero?',
      answers: [
        { text: '`always_comb`', correct: false },
        { text: '`initial`', correct: true },
        { text: '`final`', correct: false },
        { text: '`always_ff`', correct: false }
      ],
      explanation:
        '`initial` executes a single time at simulation startup—it is ideal for reset sequences or configuration setup.'
    },
    {
      question: 'Why prefer `always_comb` over `always @(*)`?',
      answers: [
        { text: 'It allows non-blocking assignments', correct: false },
        { text: 'It automatically infers the sensitivity list and checks for latches', correct: true },
        { text: 'It runs in the NBA region', correct: false },
        { text: 'It is synthesizable for flip-flops', correct: false }
      ],
      explanation:
        '`always_comb` generates the correct sensitivity list and warns when storage elements sneak in—ideal for robust combinational modeling.'
    }
  ]}
/>
