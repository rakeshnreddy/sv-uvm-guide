---
title: "F3: Procedural Constructs"
description: "Master the procedural heart of SystemVerilog—initial/always/final blocks, flow control, and assignment semantics that drive every testbench."
flashcards: "F3_Procedural_Constructs"
---

import { InteractiveCode, Quiz, Card, CardContent, CardHeader, CardTitle } from '@/components/ui';
import ProceduralBlocksSimulator from '@/components/animations/ProceduralBlocksSimulator';

## Quick Take
- **What it is:** Procedural constructs are SystemVerilog’s sequential code paths—`initial`, `always`, `final`, loops, and conditionals—that choreograph stimulus and checking.
- **Why it matters:** Misusing blocking vs. non-blocking assignments or mis-scoping procedural code leads to race conditions, false failures, and weeks of lost debug time.
- **The Analogy:** Picture a stage production: `initial` is the stage manager’s countdown, `always_ff` and `always_comb` are the actors following scripted cues, and flow control is the choreography keeping every move in sync.

> **Visual cue:** This page pairs simulators, code overlays, and animated timelines with the narrative so you can *see* how procedural elements run frame by frame.

## Build Your Mental Model

### Timeline of a Simulation Tick
<div className="my-8 rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur shadow-2xl">
  <ProceduralBlocksSimulator />
</div>

SystemVerilog simulators run every timestep through distinct event regions. Internalizing this timeline eliminates the feeling that the tool is acting randomly.

| Region | Who runs here | Debug cue |
| --- | --- | --- |
| **Active** | `initial`, `always`, blocking assignments (`=`) | Watch waveform edges jump immediately. |
| **Inactive** | Zero-delay updates (`#0`) | Rare today; legacy code only. |
| **NBA** | Non-blocking assignments (`<=`) | Values "snap" to their new state *after* all active code finishes. |
| **Postponed** | `final`, `$strobe`, assertions | Perfect spot for end-of-tick checks. |

### Challenge: The Scheduler Game
<EventRegionGame />

### The Golden Rule: Blocking vs. Non-Blocking
One of the most common sources of race conditions is using the wrong assignment type.

<Card className="my-6 border-amber-400/40 bg-amber-500/5">
  <CardHeader>
    <CardTitle>Assignment Semantics (IEEE 1800-2023 §10.4)</CardTitle>
  </CardHeader>
  <CardContent className="grid gap-4 md:grid-cols-2 text-sm">
    <div>
      <p className="font-semibold text-amber-300">Blocking (`=`)</p>
      <p className="italic text-xs mb-2">"Do this NOW."</p>
      <ul className="list-disc pl-5 space-y-1">
        <li>Executes sequentially.</li>
        <li>Blocks the process until complete.</li>
        <li>**Use for:** Combinational logic (`always_comb`), testbench variables, and functions.</li>
      </ul>
    </div>
    <div>
      <p className="font-semibold text-emerald-300">Non-Blocking (`<=`)</p>
      <p className="italic text-xs mb-2">"Schedule this for LATER."</p>
      <ul className="list-disc pl-5 space-y-1">
        <li>Schedules update for the NBA region.</li>
        <li>Allows parallel blocks to read old values safely.</li>
        <li>**Use for:** Sequential logic (`always_ff`) and clock-driven stimulus.</li>
      </ul>
    </div>
  </CardContent>
</Card>

### Interactive Core Patterns
<InteractiveCode
  language="systemverilog"
  fileName="procedural_constructs.sv"
  code={`
logic clk, reset_n, d_in, q_out;

// Sequential region: non-blocking keeps flip-flops in sync
always_ff @(posedge clk or negedge reset_n) begin
  if (!reset_n)
    q_out <= 1'b0;
  else
    q_out <= d_in;
end

// Combinational region: blocking to model logic equations
logic [2:0] state_next;
always_comb begin
  unique case (q_out)
    1'b0: state_next = 3'b001;
    1'b1: state_next = 3'b010;
    default: state_next = 3'b000;
  endcase
end

// Testbench stimulus using initial + fork/join_none
initial begin
  reset_n = 0;
  d_in = 0;
  #10 reset_n = 1;
  fork
    begin // drive pattern
      repeat (5) begin
        #5 d_in = $random;
      end
    end
    begin // monitor
      forever @(posedge clk) $display("time=%0t q_out=%0b", $time, q_out);
    end
  join_none
end

final begin
  $display("Simulation complete. Final state=%0b", q_out);
end
  `}
  explanationSteps={[
    { target: "1-8", title: "Sequential Rules", explanation: "`always_ff` with non-blocking (`<=`) mirrors flip-flop behavior and keeps updates aligned with the clock." },
    { target: "10-16", title: "Combinational Intent", explanation: "`always_comb` and blocking assignments evaluate instantly, catching missing sensitivity list issues automatically." },
    { target: "18-34", title: "Concurrency with Fork/Join", explanation: "Testbenches routinely spawn concurrent threads—one drives stimulus, another checks results—using `fork ... join_none`." },
    { target: "36-38", title: "Graceful Shutdown", explanation: "`final` blocks run once at simulation end—perfect for summaries, coverage dumps, or resource cleanup." }
  ]}
/>

> **Process hygiene:** When you use `fork ... join_none`, give the block a name so you can clean it up later. Pair `disable <label>;` or `process::kill()` with timeouts so runaway threads do not block simulation end.

```systemverilog
fork : stimulus
  begin : driver
    repeat (5) begin
      #5 d_in = $urandom_range(0, 1);
    end
  end
  begin : monitor
    forever @(posedge clk) $display("q_out=%0b", q_out);
  end
join_none

#100 disable stimulus; // tidy up if the threads outlive their usefulness
```

### Common Pitfalls
- **Mixing assignments:** Never mix `=` and `<=` on the same signal. It creates unpredictable races.
- **Implicit Latches:** Using `always @(*)` instead of `always_comb` can hide missing default cases, leading to unwanted latches.
- **Zombie Threads:** Forgetting to terminate `fork/join` threads leaves them running forever, potentially hanging the simulation.

### Case Study: Sequence Detector FSM
Put the guidelines into context with a classic problem: detect the bit pattern `101` on a serial input. A clean implementation separates sequential state updates (`always_ff`) from combinational next-state logic.

<InteractiveCode
  language="systemverilog"
  fileName="sequence_detector.sv"
  code={`
module sequence_detector (
  input  logic clk,
  input  logic reset,
  input  logic din,
  output logic detected
);

  typedef enum logic [1:0] {
    S_IDLE,
    S_GOT_1,
    S_GOT_10
  } state_t;

  state_t state, state_next;

  // Sequential evolution of the state register
  always_ff @(posedge clk or posedge reset) begin
    if (reset)
      state <= S_IDLE;
    else
      state <= state_next;
  end

  // Combinational next-state logic
  always_comb begin
    state_next = state;
    detected = 1'b0;
    unique case (state)
      S_IDLE:   state_next = din ? S_GOT_1  : S_IDLE;
      S_GOT_1:  state_next = din ? S_GOT_1  : S_GOT_10;
      S_GOT_10: begin
        detected   = din;
        state_next = din ? S_GOT_1 : S_IDLE;
      end
    endcase
  end

endmodule
  `}
/>

**What to notice:**
- State updates use non-blocking assignments in `always_ff`, mirroring flip-flop behavior.
- The combinational block seeds `state_next` and `detected` with safe defaults, preventing unintended latches.
- Using `unique case` catches missing branches while documenting intent for tools and reviewers.

## Make It Work
1. **Set the stage:** Draft a timing diagram for your DUT, marking where sequential and combinational regions live. Annotate which constructs you’ll use (`always_ff`, `always_comb`, `initial`).
2. **Instrument aggressively:** Add assertions that fail if a sequential block uses `=` or if a combinational block uses `<=`. Tools like Verilator and SpyGlass can automate these checks.
3. **Prototype the flow:** Use the interactive snippet above as a template. Swap in your DUT signals and run a quick sim to validate ordering.

**Checklist before moving on:**
- [ ] You can explain why sequential logic needs non-blocking assignments and combinational logic prefers blocking.
- [ ] You’ve run a mini-simulation that includes `initial`, `always_ff`, and `final` blocks working together.
- [ ] You can describe the event scheduling order (active → inactive → NBA → postponed) and place each construct within it.

## Push Further
- Model a multi-threaded sequencer using `fork/join_any` and observe how join semantics affect stimulus timing.
- Rewrite legacy `always @(*)` code with `always_comb` and document the tool warnings that disappear.
- Experiment with `disable fork` to clean up auxiliary threads—visualize the effect in a waveform viewer.

## Practice & Reinforce
- Flashcards – Review definitions for blocking/non-blocking, `always_ff`, `fork/join` semantics.
- Quiz – Complete the knowledge check below.
- Animation lab – Capture a screen recording of the procedural simulator while toggling assignments to see race conditions surface.
- Code kata – Convert a buggy `always` block using blocking assignments into a clean `always_ff` implementation.

## References & Next Topics
- Spear & Tumbush, *SystemVerilog for Verification*, Chapter 3.
- Accellera, *SystemVerilog LRM*, sections on process scheduling.
- Verification Academy session: “Avoiding Race Conditions in SystemVerilog.”
- Next: [Procedural Flow Control](./flow-control)

<Quiz
  questions={[
    {
      question: 'When should you use a non-blocking assignment (`<=`)?',
      answers: [
        { text: 'In combinational logic (`always_comb`)', correct: false },
        { text: 'In sequential logic (`always_ff`)', correct: true },
        { text: 'Inside `final` blocks', correct: false },
        { text: 'Inside `initial` blocks for stimulus', correct: false }
      ],
      explanation:
        'Non-blocking assignments align with flip-flop behavior and prevent races between concurrent sequential blocks.'
    },
    {
      question: 'Which procedural block runs exactly once after time zero?',
      answers: [
        { text: '`always_comb`', correct: false },
        { text: '`initial`', correct: true },
        { text: '`final`', correct: false },
        { text: '`always_ff`', correct: false }
      ],
      explanation:
        '`initial` executes a single time at simulation startup—it is ideal for reset sequences or configuration setup.'
    },
    {
      question: 'Why prefer `always_comb` over `always @(*)`?',
      answers: [
        { text: 'It allows non-blocking assignments', correct: false },
        { text: 'It automatically infers the sensitivity list and checks for latches', correct: true },
        { text: 'It runs in the NBA region', correct: false },
        { text: 'It is synthesizable for flip-flops', correct: false }
      ],
      explanation:
        '`always_comb` generates the correct sensitivity list and warns when storage elements sneak in—ideal for robust combinational modeling.'
    }
  ]}
/>
