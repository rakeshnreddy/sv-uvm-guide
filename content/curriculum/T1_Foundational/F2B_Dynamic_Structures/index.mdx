---
title: "F2B: Dynamic Data Structures"
description: "Manipulate dynamic arrays, queues, and associative arrays with an IEEE 1800-2023 guided workflow."
flashcards: "F2_Data_Types"
---

import { DynamicStructureVisualizer, PacketSorterGame } from '@/components/curriculum/f2';

## Organizing Data That Doesn't Sit Still

If a fixed array is a pillbox with a set number of compartments, dynamic structures are your expandable verification toolbox. You can snap on an extra tray when you need more slots (dynamic arrays), spin up a conveyor belt that keeps packets in order (queues), or pull open labeled drawers to find the exact transaction you need (associative arrays). These tools keep stimulus generators, scoreboards, and coverage models responsive when the DUT throws unpredictable traffic at you.

Whenever sequences randomize their length or monitors emit bursts of transactions, you want a collection that flexes with the flow. Dynamic structures let testbenches scale without tearing down and rebuilding storage from scratch, which keeps simulations fast and code approachable.

## See Them Move: An Interactive Visualizer

Explore the **DynamicStructureVisualizer** to watch each data structure react to your commands. Every tab couples controls with animations so you can connect the SystemVerilog method call to the data motion you would expect inside the simulator.

### Dynamic Array Tab

- Use `push_back(value)` to append items. When the structure runs out of room, the animation fades the old container and shows a new, larger one appearing—highlighting the hidden cost of copying elements during a resize.
- The new `new[size]` control lets you intentionally resize, padding with zeros when you grow and trimming elements when you shrink. The info tiles track `size()`, `capacity`, and a running `sum()` so you can connect SystemVerilog's built-ins to the animation.
- Try `pop_back()` to remove the last element or `delete()` to free the entire array. Visual cues confirm when memory is released and the telemetry updates immediately.

### Queue Tab

- Picture a FIFO pipe. `push_back(value)` inserts a packet from the right, sliding left to the next free slot. `pop_front()` ejects the oldest packet from the left.
- Toggle between **Bounded** and **Unbounded** modes. Setting a bound reveals an input for the maximum depth and a "Queue Full!" warning animation if you exceed it.
- Drill into more queue methods: `push_front(value)` places urgent packets at the head, `pop_back()` drops the newest entry, and `insert(index, value)` or `delete(index)` reshuffle the middle. The status tile explains every change so you can see why queues are perfect replay buffers.

### Associative Array Tab

- Enter a key/value pair and click **Add / Update** to watch a labeled drawer appear. Updating an existing key highlights the drawer so you can see associative lookup in action.
- The hash panel visualizes how the key passes through a hashing function and points to the computed slot. Deleting a key animates the drawer away and keeps the `num()` counter accurate.

### Packed vs. Unpacked Tab

- Packed arrays keep contiguous bits together and map directly to hardware vectors. Unpacked arrays add higher-level dimensions—perfect for modeling buffers or scoreboards. Use the **Packed vs. Unpacked** tab to step through memory walks that show how each dimension maps onto linear storage.
- A built-in quiz locks in the rules: inner packed dimensions toggle fastest, right-most unpacked dimensions advance before outer ones, and entire packed payloads stay together for each unpacked index.

<DynamicStructureVisualizer />

## Packed vs. Unpacked: Mapping Bits to Memory

Packed arrays behave like vectors—each packed dimension represents contiguous bits stored in order from the most-significant dimension (left-most) down to the least. Unpacked dimensions add array indices around those vectors, and they map in order from right to left when the simulator linearizes memory. The **Packed vs. Unpacked** tab provides three scenarios:

- **Burst Payload Buffer** — `logic [7:0] payload [0:3];` shows that the packed `[7:0]` byte stays intact while the unpacked payload index advances to the next element.
- **Lane Matrix** — `bit [3:0][1:0] lane_matrix [0:1];` highlights two packed dimensions: the innermost `[1:0]` flips fastest (lane 1 then lane 0) while the outer `[3:0]` nibble changes more slowly. Only after the packed bits finish does the unpacked channel index increment.
- **Scoreboard Grid** — `logic [3:0] scoreboard [0:1][0:2];` demonstrates how right-most unpacked dimensions (columns) advance first, letting you visualize row-by-row storage across the grid.

Use the quiz at the bottom of the tab to test your understanding of which dimension steps first. The visual memory walk—complete with bit labels—makes it easy to remember how packed and unpacked indices collapse into linear memory. When you graduate to multi-dimensional register files, these heuristics keep you from flipping indices or accidentally swapping byte lanes.

## When to Use What

Choosing the right structure keeps simulations debuggable and performant:

- **Dynamic Array** — Collect packet lengths, random seeds, or scoreboard snapshots when you need indexed access later. Resize explicitly with `new[size]`, or lean on `sum()`, `sort()`, and iterators for post-run analysis.
- **Queue** — Model FIFOs, transaction mailboxes, or scoreboard pipelines where order matters. Reach for `push_front()`, `pop_back()`, `insert(index, value)`, and `delete(index)` when you need replay buffers or priority inserts.
- **Associative Array** — Mirror sparse memories, track outstanding transactions by ID, or organize coverage bins without wasting space on unused keys. Hash lookups keep access time constant.
- **Packed Array** — Mirror DUT buses and register fields bit-for-bit. Packed dimensions preserve bit ordering and pair perfectly with unpacked dimensions when you need structured storage around each vector.

```systemverilog showLineNumbers
// Handy built-ins to keep on hand
dynamic int packet_lengths[];                 // dynamic array declaration
packet_lengths.push_back(new_length);         // grow as packets arrive
packet_lengths = new[6];                      // resize intentionally
int total = packet_lengths.sum();             // SystemVerilog sums elements for you

int fifo[$];                                  // queue declaration
fifo.push_front(urgent_txn);                  // prioritize urgent traffic
fifo.insert(1, delayed_txn);                  // slip into the middle
int replay_tail = fifo.pop_back();            // drop newest when replaying
fifo.delete(0);                               // remove head without popping

typedef bit [31:0] error_id_t;
string error_notes[error_id_t];               // associative array declaration
if (error_notes.find(id)) begin
  $display("note: %s", error_notes[id]);
end
error_notes.delete(id);                       // remove resolved issues

bit [3:0][1:0] lane_matrix [0:1];             // packed + unpacked combo
lane_matrix[0][3] = '{1'b0, 1'b1};            // lane index toggles fastest
```

## Think on Your Feet: Manage the Data Flow

Step into the **PacketSorterGame** to apply what you learned. Five real-world-inspired scenarios—including a packed-array register mirror prompt and a queue replay drill—drop you into a verification lab. Pick the structure that keeps the packets organized, earn +150 XP, and unlock the **Data Flow Master** badge. Immediate feedback explains each decision so you know why the correct answer fits and when another option would slow you down.

<PacketSorterGame />
