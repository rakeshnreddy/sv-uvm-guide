---
title: "F2B: Dynamic Data Structures"
description: "Manipulate dynamic arrays, queues, and associative arrays with an IEEE 1800-2023 guided workflow."
flashcards: "F2_Data_Types"
---

import { DynamicStructureVisualizer, PacketSorterGame, SystemVerilog3DVisualizer } from '@/components/curriculum/f2';

## Organizing Data That Doesn't Sit Still

If a fixed array is a pillbox with a set number of compartments, dynamic structures are your expandable verification toolbox. You can snap on an extra tray when you need more slots (dynamic arrays), spin up a conveyor belt that keeps packets in order (queues), or pull open labeled drawers to find the exact transaction you need (associative arrays). These tools keep stimulus generators, scoreboards, and coverage models responsive when the DUT throws unpredictable traffic at you.

Whenever sequences randomize their length or monitors emit bursts of transactions, you want a collection that flexes with the flow. Dynamic structures let testbenches scale without tearing down and rebuilding storage from scratch, which keeps simulations fast and code approachable.

## See Them Move: An Interactive Visualizer

Explore the **DynamicStructureVisualizer** to watch each data structure react to your commands. Every tab couples controls with animations so you can connect the SystemVerilog method call to the data motion you would expect inside the simulator.

### Dynamic Array Tab

- Use `push_back(value)` to append items. When the structure runs out of room, the animation fades the old container and shows a new, larger one appearing—highlighting the hidden cost of copying elements during a resize.
- The new `new[size]` control lets you intentionally resize, padding with zeros when you grow and trimming elements when you shrink. The info tiles track `size()`, `capacity`, and a running `sum()` so you can connect SystemVerilog's built-ins to the animation.
- Try `pop_back()` to remove the last element or `delete()` to free the entire array. Visual cues confirm when memory is released and the telemetry updates immediately.

### Queue Tab

- Picture a FIFO pipe. `push_back(value)` inserts a packet from the right, sliding left to the next free slot. `pop_front()` ejects the oldest packet from the left.
- Toggle between **Bounded** and **Unbounded** modes. Setting a bound reveals an input for the maximum depth and a "Queue Full!" warning animation if you exceed it.
- Drill into more queue methods: `push_front(value)` places urgent packets at the head, `pop_back()` drops the newest entry, and `insert(index, value)` or `delete(index)` reshuffle the middle. The status tile explains every change so you can see why queues are perfect replay buffers.

### Associative Array Tab

- Enter a key/value pair and click **Add / Update** to watch a labeled drawer appear. Updating an existing key highlights the drawer so you can see associative lookup in action.
- The hash panel visualizes how the key passes through a hashing function and points to the computed slot. Deleting a key animates the drawer away and keeps the `num()` counter accurate.

### Packed vs. Unpacked Tab

- Packed arrays keep contiguous bits together and map directly to hardware vectors. Unpacked arrays add higher-level dimensions—perfect for modeling buffers or scoreboards. Use the **Packed vs. Unpacked** tab to step through memory walks that show how each dimension maps onto linear storage.
- The **Index placement map** highlights the order you apply indices when writing expressions like `payload[slot][bit]` or `lane_matrix[channel][nibble][lane]`, so you can see which brackets represent unpacked or packed dimensions before you click the quiz.

- A built-in quiz locks in the rules: inner packed dimensions toggle fastest, right-most unpacked dimensions advance before outer ones, and entire packed payloads stay together for each unpacked index.

<DynamicStructureVisualizer />

## Tour the Structures in 3D

Before leaving the lab, walk through a volumetric view of each collection. The **SystemVerilog Data Structures – 3D Explorer** stacks the same array, queue, associative, and packed/unpacked examples into a perspective scene so you can see head/tail markers, reserved capacity, hash collisions, and packed lane ordering at a glance. Prefer a dedicated window? Launch the full-page experience at [SystemVerilog 3D Explorer](/visualizations/systemverilog-3d).

- Rotate mentally around the dynamic array to see the reserved capacity sitting just beyond the active indices.
- Watch queue entries sweep backward in depth as you advance `pop_front()`—the tail warning block lights up whenever you hit a bound.
- Hover over the layered packed/unpacked cube to remember why `[1:0]` flips fastest inside `lane_matrix[channel][nibble][lane]`.
- Jump straight to the **UVM Component Relationships** or **Memory Hub** visualizations from the suggested links when you're ready to see the structures inside a full environment.

<SystemVerilog3DVisualizer />

## Packed vs. Unpacked: Mapping Bits to Memory

Packed arrays behave like vectors—each packed dimension represents contiguous bits stored in order from the most-significant dimension (left-most) down to the least. Unpacked dimensions add array indices around those vectors, and they map in order from right to left when the simulator linearizes memory. The **Packed vs. Unpacked** tab now includes an **Index placement map** that spells out which brackets correspond to which part of the declaration. A reliable mental model: when you reference a variable, index every unpacked dimension from left to right first, then every packed dimension from left to right. The right-most dimension—packed or unpacked—always toggles fastest in memory.

### Declaration vs. Access Order

Take the multi-dimensional declaration the UVM coding guidelines lean on for layered scoreboards:

```systemverilog showLineNumbers
logic [P1-1:0][P2-1:0][P3-1:0] my_array [U1][U2][U3];
```

- The brackets on the **right** (`[U1][U2][U3]`) are **unpacked** dimensions. They wrap whole vectors and control the outer container order: `U1` toggles slowest, `U3` toggles fastest.
- The brackets on the **left** (`[P1-1:0][P2-1:0][P3-1:0]`) are **packed** dimensions. They describe contiguous bits inside each element, with `[P3-1:0]` (the right-most packed dimension) flipping fastest.

Because declarations list packed dimensions first, your accesses reverse the pattern. Index the unpacked dimensions first and keep the packed ones on the end so the simulator can hand you contiguous bit slices:

```systemverilog showLineNumbers
// Correct access order
my_array[u1][u2][u3][p1][p2][p3];
```

- `my_array[u1]` picks the outer unpacked bucket (0 .. U1-1).
- `[u2]` and `[u3]` finish the unpacked selection, from slowest changing to fastest changing unpacked dimension.
- `[p1]`, `[p2]`, and `[p3]` then walk the packed vector from the most-significant slice to the least.

If you try to access `my_array[p1][p2][p3][u1][u2][u3]`, SystemVerilog complains—the packed brackets must stay on the right so the compiler knows you are slicing contiguous bits. Leaving off the trailing packed indices returns the entire packed payload, so `my_array[u1][u2][u3]` hands back all `[P1][P2][P3]` bits in one shot.

### Visual Memory Walks

Memorize the pattern with the index legend inside the visualizer:


- **Burst Payload Buffer** — `logic [7:0] payload [0:3];` shows that the packed `[7:0]` byte stays intact while the unpacked payload index advances to the next element.
- **Lane Matrix** — `bit [3:0][1:0] lane_matrix [0:1];` highlights two packed dimensions: the innermost `[1:0]` flips fastest (lane 1 then lane 0) while the outer `[3:0]` nibble changes more slowly. Only after the packed bits finish does the unpacked channel index increment.
- **Scoreboard Grid** — `logic [3:0] scoreboard [0:1][0:2];` demonstrates how right-most unpacked dimensions (columns) advance first, letting you visualize row-by-row storage across the grid.

Use the quiz at the bottom of the tab to test your understanding of which dimension steps first. The visual memory walk—complete with bit labels—makes it easy to remember how packed and unpacked indices collapse into linear memory. When you graduate to multi-dimensional register files, these heuristics keep you from flipping indices or accidentally swapping byte lanes. You can also revisit the 3D Explorer above to reinforce which axis represents packed bits, unpacked channels, or pending capacity.

## When to Use What

Choosing the right structure keeps simulations debuggable and performant:

- **Dynamic Array** — Collect packet lengths, random seeds, or scoreboard snapshots when you need indexed access later. Resize explicitly with `new[size]`, or lean on `sum()`, `sort()`, and iterators for post-run analysis.
- **Queue** — Model FIFOs, transaction mailboxes, or scoreboard pipelines where order matters. Reach for `push_front()`, `pop_back()`, `insert(index, value)`, and `delete(index)` when you need replay buffers or priority inserts.
- **Associative Array** — Mirror sparse memories, track outstanding transactions by ID, or organize coverage bins without wasting space on unused keys. Hash lookups keep access time constant.
- **Packed Array** — Mirror DUT buses and register fields bit-for-bit. Packed dimensions preserve bit ordering and pair perfectly with unpacked dimensions when you need structured storage around each vector.

```systemverilog showLineNumbers
// Handy built-ins to keep on hand
dynamic int packet_lengths[];                 // dynamic array declaration
packet_lengths.push_back(new_length);         // grow as packets arrive
packet_lengths = new[6];                      // resize intentionally
int total = packet_lengths.sum();             // SystemVerilog sums elements for you

int fifo[$];                                  // queue declaration
fifo.push_front(urgent_txn);                  // prioritize urgent traffic
fifo.insert(1, delayed_txn);                  // slip into the middle
int replay_tail = fifo.pop_back();            // drop newest when replaying
fifo.delete(0);                               // remove head without popping

typedef bit [31:0] error_id_t;
string error_notes[error_id_t];               // associative array declaration
if (error_notes.find(id)) begin
  $display("note: %s", error_notes[id]);
end
error_notes.delete(id);                       // remove resolved issues

bit [3:0][1:0] lane_matrix [0:1];             // packed + unpacked combo
lane_matrix[0][3] = '{1'b0, 1'b1};            // lane index toggles fastest
```

## Think on Your Feet: Manage the Data Flow

Step into the **PacketSorterGame** to apply what you learned. Five real-world-inspired scenarios—including a packed-array register mirror prompt and a queue replay drill—drop you into a verification lab. Pick the structure that keeps the packets organized, earn +150 XP, and unlock the **Data Flow Master** badge. Immediate feedback explains each decision so you know why the correct answer fits and when another option would slow you down.

<PacketSorterGame />
