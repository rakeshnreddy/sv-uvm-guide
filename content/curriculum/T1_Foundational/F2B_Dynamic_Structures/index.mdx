---
title: "F2B: Dynamic Data Structures"
description: "Manipulate dynamic arrays, queues, and associative arrays with an IEEE 1800-2023 guided workflow."
flashcards: "F2_Data_Types"
---

import { DynamicStructureVisualizer, PacketSorterGame } from '@/components/curriculum/f2';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/Card';
import ArrayMethodExplorer from '@/components/visuals/ArrayMethodExplorer';

## Organizing Data That Doesn't Sit Still

If a fixed array is a pillbox with a set number of compartments, dynamic structures are your expandable verification toolbox. You can snap on an extra tray when you need more slots (dynamic arrays), spin up a conveyor belt that keeps packets in order (queues), or pull open labeled drawers to find the exact transaction you need (associative arrays). These tools keep stimulus generators, scoreboards, and coverage models responsive when the DUT throws unpredictable traffic at you.

Whenever sequences randomize their length or monitors emit bursts of transactions, you want a collection that flexes with the flow. Dynamic structures let testbenches scale without tearing down and rebuilding storage from scratch, which keeps simulations fast and code approachable.

## See Them Move: An Interactive Visualizer

Explore the **DynamicStructureVisualizer** to watch each data structure react to your commands. Every tab couples controls with animations so you can connect the SystemVerilog method call to the data motion you would expect inside the simulator.

### Dynamic Array Tab

- Use `push_back(value)` to append items. When the structure runs out of room, the animation fades the old container and shows a new, larger one appearingâ€”highlighting the hidden cost of copying elements during a resize.
- The new `new[size]` control lets you intentionally resize, padding with zeros when you grow and trimming elements when you shrink. The info tiles track `size()`, `capacity`, and a running `sum()` so you can connect SystemVerilog's built-ins to the animation.
- Try `pop_back()` to remove the last element or `delete()` to free the entire array. Visual cues confirm when memory is released and the telemetry updates immediately.

ðŸ’¡ **[Explore in 3D](/visualizations/systemverilog-3d?scene=dynamic-array)** - See how capacity expansion looks in perspective view.

### Queue Tab

- Picture a FIFO pipe. `push_back(value)` inserts a packet from the right, sliding left to the next free slot. `pop_front()` ejects the oldest packet from the left.
- Toggle between **Bounded** and **Unbounded** modes. Setting a bound reveals an input for the maximum depth and a "Queue Full!" warning animation if you exceed it.
- Drill into more queue methods: `push_front(value)` places urgent packets at the head, `pop_back()` drops the newest entry, and `insert(index, value)` or `delete(index)` reshuffle the middle. The status tile explains every change so you can see why queues are perfect replay buffers.

ðŸ’¡ **[Explore in 3D](/visualizations/systemverilog-3d?scene=queue)** - Visualize the FIFO pipeline and boundary conditions.

### Associative Array Tab

- Enter a key/value pair and click **Add / Update** to watch a labeled drawer appear. Updating an existing key highlights the drawer so you can see associative lookup in action.
- The hash panel visualizes how the key passes through a hashing function and points to the computed slot. Deleting a key animates the drawer away and keeps the `num()` counter accurate.

ðŸ’¡ **[Explore in 3D](/visualizations/systemverilog-3d?scene=associative)** - See hash distribution and bucket stacking in action.

### Packed vs. Unpacked Tab

- Packed arrays keep contiguous bits together and map directly to hardware vectors. Unpacked arrays add higher-level dimensionsâ€”perfect for modeling buffers or scoreboards. Use the **Packed vs. Unpacked** tab to step through memory walks that show how each dimension maps onto linear storage.

ðŸ’¡ **[Explore in 3D](/visualizations/systemverilog-3d?scene=packed-matrix)** - Navigate the dimensional layers with visual depth cues.

- The **Index placement map** highlights the order you apply indices when writing expressions like `payload[slot][bit]` or `lane_matrix[channel][nibble][lane]`, so you can see which brackets represent unpacked or packed dimensions before you click the quiz.

- A built-in quiz locks in the rules: inner packed dimensions toggle fastest, right-most unpacked dimensions advance before outer ones, and entire packed payloads stay together for each unpacked index.

<DynamicStructureVisualizer />

## Tour the Structures in 3D

Before leaving the lab, walk through a volumetric view of each collection. The **SystemVerilog Data Structures â€“ 3D Explorer** stacks the same array, queue, associative, and packed/unpacked examples into a perspective scene so you can see head/tail markers, reserved capacity, hash collisions, and packed lane ordering at a glance. 

**Quick Access Links:**
- [ðŸ”— Dynamic Array 3D View](/visualizations/systemverilog-3d?scene=dynamic-array) - See capacity and resize animations
- [ðŸ”— Queue 3D View](/visualizations/systemverilog-3d?scene=queue) - Visualize FIFO depth and bounds  
- [ðŸ”— Associative Array 3D View](/visualizations/systemverilog-3d?scene=associative) - Explore hash buckets and collisions
- [ðŸ”— Packed Matrix 3D View](/visualizations/systemverilog-3d?scene=packed-matrix) - Navigate multi-dimensional indexing

Prefer a dedicated window? Launch the [full-page 3D explorer](/visualizations/systemverilog-3d) and switch between scenes using the tabs.

- Rotate mentally around the dynamic array to see the reserved capacity sitting just beyond the active indices.
- Watch queue entries sweep backward in depth as you advance `pop_front()`â€”the tail warning block lights up whenever you hit a bound.
- Hover over the layered packed/unpacked cube to remember why `[1:0]` flips fastest inside `lane_matrix[channel][nibble][lane]`.
- Jump straight to advanced topics when you're ready to see the structures inside a full verification environment.

**ðŸ’¡ Pro tip:** Bookmark your favorite scene! Each 3D view has a unique URL that preserves your selection when you return or share with others.

<SystemVerilog3DVisualizer />

## Packed vs. Unpacked: Mapping Bits to Memory

Packed arrays behave like vectorsâ€”each packed dimension represents contiguous bits stored in order from the most-significant dimension (left-most) down to the least. Unpacked dimensions add array indices around those vectors, and they map in order from right to left when the simulator linearizes memory. The **Packed vs. Unpacked** tab now includes an **Index placement map** that spells out which brackets correspond to which part of the declaration. A reliable mental model: when you reference a variable, index every unpacked dimension from left to right first, then every packed dimension from left to right. The right-most dimensionâ€”packed or unpackedâ€”always toggles fastest in memory.

### Declaration vs. Access Order

Take the multi-dimensional declaration the UVM coding guidelines lean on for layered scoreboards:

```systemverilog showLineNumbers
logic [P1-1:0][P2-1:0][P3-1:0] my_array [U1][U2][U3];
```

- The brackets on the **right** (`[U1][U2][U3]`) are **unpacked** dimensions. They wrap whole vectors and control the outer container order: `U1` toggles slowest, `U3` toggles fastest.
- The brackets on the **left** (`[P1-1:0][P2-1:0][P3-1:0]`) are **packed** dimensions. They describe contiguous bits inside each element, with `[P3-1:0]` (the right-most packed dimension) flipping fastest.

Because declarations list packed dimensions first, your accesses reverse the pattern. Index the unpacked dimensions first and keep the packed ones on the end so the simulator can hand you contiguous bit slices:

```systemverilog showLineNumbers
// Correct access order
my_array[u1][u2][u3][p1][p2][p3];
```

- `my_array[u1]` picks the outer unpacked bucket (0 .. U1-1).
- `[u2]` and `[u3]` finish the unpacked selection, from slowest changing to fastest changing unpacked dimension.
- `[p1]`, `[p2]`, and `[p3]` then walk the packed vector from the most-significant slice to the least.

If you try to access `my_array[p1][p2][p3][u1][u2][u3]`, SystemVerilog complainsâ€”the packed brackets must stay on the right so the compiler knows you are slicing contiguous bits. Leaving off the trailing packed indices returns the entire packed payload, so `my_array[u1][u2][u3]` hands back all `[P1][P2][P3]` bits in one shot.

### Visual Memory Walks

Memorize the pattern with the index legend inside the visualizer:


- **Burst Payload Buffer** â€” `logic [7:0] payload [0:3];` shows that the packed `[7:0]` byte stays intact while the unpacked payload index advances to the next element.
- **Lane Matrix** â€” `bit [3:0][1:0] lane_matrix [0:1];` highlights two packed dimensions: the innermost `[1:0]` flips fastest (lane 1 then lane 0) while the outer `[3:0]` nibble changes more slowly. Only after the packed bits finish does the unpacked channel index increment.
- **Scoreboard Grid** â€” `logic [3:0] scoreboard [0:1][0:2];` demonstrates how right-most unpacked dimensions (columns) advance first, letting you visualize row-by-row storage across the grid.

Use the quiz at the bottom of the tab to test your understanding of which dimension steps first. The visual memory walkâ€”complete with bit labelsâ€”makes it easy to remember how packed and unpacked indices collapse into linear memory. When you graduate to multi-dimensional register files, these heuristics keep you from flipping indices or accidentally swapping byte lanes. You can also revisit the 3D Explorer above to reinforce which axis represents packed bits, unpacked channels, or pending capacity.

## When to Use What

Choosing the right structure keeps simulations debuggable and performant:

- **Dynamic Array** â€” Collect packet lengths, random seeds, or scoreboard snapshots when you need indexed access later. Resize explicitly with `new[size]`, or lean on `sum()`, `sort()`, and iterators for post-run analysis.
- **Queue** â€” Model FIFOs, transaction mailboxes, or scoreboard pipelines where order matters. Reach for `push_front()`, `pop_back()`, `insert(index, value)`, and `delete(index)` when you need replay buffers or priority inserts.
- **Associative Array** â€” Mirror sparse memories, track outstanding transactions by ID, or organize coverage bins without wasting space on unused keys. Hash lookups keep access time constant.
- **Packed Array** â€” Mirror DUT buses and register fields bit-for-bit. Packed dimensions preserve bit ordering and pair perfectly with unpacked dimensions when you need structured storage around each vector.

```systemverilog showLineNumbers
// Handy built-ins to keep on hand
dynamic int packet_lengths[];                 // dynamic array declaration
packet_lengths.push_back(new_length);         // grow as packets arrive
packet_lengths = new[6];                      // resize intentionally
int total = packet_lengths.sum();             // SystemVerilog sums elements for you

int fifo[$];                                  // queue declaration
fifo.push_front(urgent_txn);                  // prioritize urgent traffic
fifo.insert(1, delayed_txn);                  // slip into the middle
int replay_tail = fifo.pop_back();            // drop newest when replaying
fifo.delete(0);                               // remove head without popping

typedef bit [31:0] error_id_t;
string error_notes[error_id_t];               // associative array declaration
if (error_notes.find(id)) begin
  $display("note: %s", error_notes[id]);
end
error_notes.delete(id);                       // remove resolved issues

bit [3:0][1:0] lane_matrix [0:1];             // packed + unpacked combo
lane_matrix[0][3] = '{1'b0, 1'b1};            // lane index toggles fastest
```

## Array Manipulation Methods
_Built-in superpowers for your arrays._

SystemVerilog arrays (dynamic and queues) come with powerful built-in methods for searching, sorting, and reducing data. These are optimized in C++ and are much faster than writing your own loops.

<ArrayMethodExplorer />

### Key Methods
- **Ordering:** `sort()`, `rsort()`, `reverse()`, `shuffle()`.
- **Reduction:** `sum()`, `product()`, `and()`, `or()`, `xor()`.
- **Locator:** `find()`, `find_index()`, `find_first()`, `find_last()`.
- **Constraint:** `unique()`.

```systemverilog
int q[$] = {1, 5, 2, 5};
int res[$];

res = q.find(x) with (x > 3); // {5, 5}
q.sort();                     // {1, 2, 5, 5}
q.unique();                   // {1, 2, 5}
```

## Performance Corner

> [!CAUTION]
> **Queue Performance Trap**
> Queues are optimized for pushing/popping at the ends. Using `insert()` or `delete()` in the middle of a large queue is an $O(N)$ operation and can kill simulation performance. If you need random access insertion/deletion, consider a linked list (via classes) or an associative array.

> [!TIP]
> **Associative Array Overhead**
> Associative arrays have higher memory overhead per element than dynamic arrays. Use them for sparse data (e.g., a 64-bit address space with only 100 active entries). If your indices are dense (0 to N), use a dynamic array.

## Interview Questions

<Card className="mt-8 border-slate-700 bg-slate-900">
  <CardHeader>
    <CardTitle>Ready for the Interview?</CardTitle>
  </CardHeader>
  <CardContent className="space-y-4">
    <details className="group rounded-lg bg-slate-800 p-4 open:bg-slate-800/80">
      <summary className="flex cursor-pointer items-center justify-between font-medium text-slate-200">
        When would you use a queue vs. a dynamic array?
        <span className="text-slate-400 transition group-open:rotate-180">â–¼</span>
      </summary>
      <div className="mt-4 text-sm text-slate-300 leading-relaxed">
        <p>Use a <strong>queue</strong> when you need to push/pop from both ends (FIFO/LIFO) or when the size changes frequently during simulation. Use a <strong>dynamic array</strong> when the size is fixed for a duration (e.g., a payload) or when you need random access without the overhead of a linked list structure.</p>
      </div>
    </details>

    <details className="group rounded-lg bg-slate-800 p-4 open:bg-slate-800/80">
      <summary className="flex cursor-pointer items-center justify-between font-medium text-slate-200">
        What happens if you read a non-existent key from an associative array?
        <span className="text-slate-400 transition group-open:rotate-180">â–¼</span>
      </summary>
      <div className="mt-4 text-sm text-slate-300 leading-relaxed">
        <p>It returns the <strong>default value</strong> for the element type (e.g., 0 for `int`, `x` for `logic`). It does <em>not</em> issue a warning. Always check `exists()` or `first()`/`next()` if you aren't sure a key is present.</p>
      </div>
    </details>
  </CardContent>
</Card>

## Think on Your Feet: Manage the Data Flow

Step into the **PacketSorterGame** to apply what you learned. Five real-world-inspired scenariosâ€”including a packed-array register mirror prompt and a queue replay drillâ€”drop you into a verification lab. Pick the structure that keeps the packets organized, earn +150 XP, and unlock the **Data Flow Master** badge. Immediate feedback explains each decision so you know why the correct answer fits and when another option would slow you down.

<PacketSorterGame />
