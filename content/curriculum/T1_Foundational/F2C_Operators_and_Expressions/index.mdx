---
title: "F2C: Operators and Expressions"
description: "Master the art of bit manipulation with SystemVerilog's powerful operator set."
flashcards: "F2C_Operators"
---

import { InteractiveCode } from '@/components/ui';
import OperatorVisualizer from '@/components/visuals/OperatorVisualizer';
import { OperatorDrill } from '@/components/curriculum/f2';

## Quick Take
- **What it is:** The verbs of SystemVerilog—bitwise vs. logical operators, reductions, set membership, and streaming concatenations.
- **Why it matters:** Misusing `==` vs `===` or `&` vs `&&` hides X-propagation bugs and breaks control flow. Precise operators make intent obvious to readers and tools.
- **The Analogy:** Operators are the choreography that moves bits around; the same dancers perform very different routines depending on the steps you call.

## Build Your Mental Model
### The Bitwise Playground
<OperatorVisualizer />

- Use bitwise operators when you mean per-bit math; use logical operators when you’re steering control flow with truthiness.
- Reductions collapse vectors to parity, OR, or AND checks—perfect for flags.

### Precedence and Exact Matching
- `==`/`!=` return `X` on unknowns; `===`/`!==` treat X/Z as data and return 0/1. Reach for case equality on resets and CDC monitors.
- Parentheses beat precedence surprises: `a & b == c` parses as `a & (b == c)`.

### Set Membership and Streaming
- `inside` expresses range checks concisely and uses case equality semantics. Great for opcode guards and constraint clauses.
- Streaming concatenations (`{<<{payload}}`) reshape buses without manual slicing; specify direction (`<<` or `>>`) to keep bit order explicit.

### Operator Drill Station
<OperatorDrill />

- Click through scenarios to compare bitwise vs logical, case equality, set membership, and streaming concatenations with ready-made operands.

## Make It Work
<InteractiveCode>
```systemverilog
module alu (
  input  logic [3:0] a,
  input  logic [3:0] b,
  input  logic [2:0] op,
  output logic [3:0] result,
  output logic       zero
);

  always_comb begin
    unique case (op)
      3'b000: result = a + b;                 // Add
      3'b001: result = a - b;                 // Sub
      3'b010: result = a & b;                 // Bitwise AND
      3'b011: result = a | b;                 // Bitwise OR
      3'b100: result = a ^ b;                 // XOR
      3'b101: result = {a[2:0], b[3]};        // Concatenate slices
      default: result = '0;
    endcase

    // Reduction operator for zero flag
    zero = ~(|result); // NOR reduction: 1 if result is 0
  end
endmodule
```
</InteractiveCode>

- Prefer `unique/priority` cases with `inside` when opcodes live in ranges.
- Use arithmetic shifts (`>>>`) only on signed operands; logical shifts (`>>`) fill with zeros.
- Keep intermediate math in wider, signed types to avoid truncation before assigning back to packed logic.

## Practice & Reinforce
- Rework a scoreboard compare to use `===` and `inside` so X/Z is never dropped silently.
- Sketch precedence ladders for a favorite expression, then simplify with parentheses or helper wires.

## References & Next Topics
- IEEE 1800-2023 §11 (Operators and Expressions)
- Next: [`F3: Procedural Constructs`](../F3_Procedural_Constructs/)
