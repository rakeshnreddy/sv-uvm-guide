---
title: "F2D: Reusable Code and Parallelism"
description: "Factor stimulus into tasks/functions and coordinate parallel threads with fork-join semantics."
flashcards: "F2_Data_Types"
---

import { InteractiveCode, Card, CardContent, CardHeader, CardTitle } from '@/components/ui';

## Quick Take
- **Reusable intent:** Tasks and functions encapsulate behavior, making benches easier to maintain and reuse (IEEE 1800-2023 §13.4, §13.5).
- **Side-effect control:** Functions return values and cannot advance simulation time; tasks may contain timing and spawn additional threads (§13.5.1, §13.4.1).
- **Parallel orchestration:** `fork-join` families schedule threads and define when execution resumes—critical for coordinating drivers, monitors, and scoreboards (§9.3).

## Build Your Mental Model
Verification environments juggle stimulus, checking, and scoreboarding simultaneously. Reusable procedures keep intent clean, while `fork` constructs let you run them in parallel without writing bespoke scheduler code.

### Tasks vs. Functions
<Card className="my-6 border-sky-400/40 bg-sky-500/5">
  <CardHeader>
    <CardTitle>Comparison (IEEE 1800-2023 §13)</CardTitle>
  </CardHeader>
  <CardContent className="grid gap-4 md:grid-cols-2 text-sm">
    <div>
      <p className="font-semibold">Functions</p>
      <ul className="list-disc pl-5 space-y-1">
        <li>Return a single value and must execute in zero time (§13.5.1).</li>
        <li>Cannot call tasks or use `@`/`wait`/`#` delays.</li>
        <li>Great for combinational scoreboarding or data transforms.</li>
      </ul>
    </div>
    <div>
      <p className="font-semibold">Tasks</p>
      <ul className="list-disc pl-5 space-y-1">
        <li>May consume time, call other tasks, and launch parallel threads (§13.4.1).</li>
        <li>Support input/output/inout arguments and `ref` for handles.</li>
        <li>Use `automatic` to avoid static variable reuse across calls (§13.4.3).</li>
      </ul>
    </div>
  </CardContent>
</Card>

### Example: Factoring Stimulus into a Task
<InteractiveCode
  language="systemverilog"
  code={`
module refactored_tb;
  logic clk;
  logic [7:0] data;
  logic valid;

  task automatic send_packet(input byte payload, input int repeat_count);
    for (int i = 0; i < repeat_count; i++) begin
      @(posedge clk);
      data  <= payload;
      valid <= 1'b1;
      @(posedge clk);
      valid <= 1'b0;
    end
  endtask // May consume time (§13.4.1)

  function automatic bit parity(input byte payload);
    parity = ^payload; // XOR reduce (§11.4)
  endfunction

  initial begin
    clk = 0;
    forever #5 clk = ~clk;
  end

  initial begin
    valid = 0;
    send_packet(8'hA5, 2);
    $display("Parity=%0b", parity(8'hA5));
  end
endmodule
  `}
/>

### Parallel Execution with `fork`/`join`
<InteractiveCode
  language="systemverilog"
  code={`
initial begin
  fork : stimulus_threads // Named fork (§9.3)
    begin
      drive_reset();
    end
    begin
      send_traffic();
    end
    begin
      monitor_responses();
    end
  join_any
  disable stimulus_threads; // Clean up remaining threads when any completes (§9.3.1)
end
  `}
/>

- `fork...join` waits for all spawned threads—use when every action must finish (§9.3).
- `fork...join_any` returns when any thread completes—great for timeout/watchdog patterns.
- `fork...join_none` lets the parent continue immediately; remember to `disable fork` or keep handles to manage lifetime.

## Gamified Lab: The Refactoring Challenge
Ready to apply the concepts? Head to [labs/basics/lab1_refactoring](/labs/basics/lab1_refactoring/) and refactor the provided testbench by extracting a reusable task that removes the copy-pasted stimulus (IEEE 1800-2023 §13.4). The lab grading harness checks that your task takes arguments and that the bench still passes.

## Practice Prompts
1. Convert a repetitive scoreboard checker into a function that returns a status bit.
2. Use `fork...join_any` to race a completion event against a `#100ns` timeout.
3. Wrap your favorite stimulus pattern inside a task and reuse it across regressions.

## LRM References
- IEEE Std 1800-2023 §13 — Tasks, functions, argument types, and `automatic` semantics.
- IEEE Std 1800-2023 §9.3 — `fork`/`join` scheduling and disabling semantics.
- IEEE Std 1800-2023 §11.4 — Reduction operators often used inside functions.
