# SystemVerilog Data Types

SystemVerilog provides a rich set of data types for modeling hardware. Understanding these data types is crucial for writing efficient and accurate RTL and testbench code.

## 4-State vs. 2-State Data Types

One of the most important concepts in SystemVerilog is the distinction between 4-state and 2-state data types.

*   **4-state data types** can have four possible values:
    *   `0`: Logic zero
    *   `1`: Logic one
    *   `X`: Unknown value
    *   `Z`: High-impedance

    These types are essential for modeling hardware, as they can accurately represent the behavior of uninitialized memory, bus contention, and other real-world scenarios. The most common 4-state data type is `logic`.

*   **2-state data types** can only have two possible values:
    *   `0`: Logic zero
    *   `1`: Logic one

    These types are more memory-efficient and faster to simulate than 4-state types. They are often used in testbenches for things like loop counters and other variables that don't need to model hardware behavior. The most common 2-state data type is `bit`.

## Arrays

SystemVerilog supports several types of arrays:

*   **Packed arrays:** These are arrays of bits that are packed together into a single word. They are useful for modeling things like registers and memories.
*   **Unpacked arrays:** These are arrays of any data type, including other arrays. They are useful for creating complex data structures.
*   **Dynamic arrays:** These are arrays that can be resized at runtime.
*   **Associative arrays:** These are arrays that use a key of any data type to access their elements.
*   **Queues:** These are arrays that provide a FIFO (first-in, first-out) interface.

## User-Defined Types

SystemVerilog also allows you to define your own data types using `typedef`. This is useful for creating reusable data structures and for improving the readability of your code. You can use `struct`, `union`, and `enum` to create complex user-defined types.
