---
title: "F4A: Structuring Designs with Modules and Packages"
description: "Wire up designs and verification harnesses with modules and packages that keep signal intent crystal clear."
flashcards: "F4A_Modules_and_Packages"
---

import { InteractiveCode, Quiz } from '@/components/ui';

## Quick Take
- **What it is:** The fundamental building blocks of SystemVerilog—**modules** for hierarchy and **packages** for shared definitions.
- **Why it matters:** Modules encapsulate behavior and structure, while packages prevent "copy-paste" errors by centralizing types and constants.
- **The Analogy:** Think of a **module** as a circuit board with specific inputs and outputs. A **package** is the technical manual or standard library that defines the connectors and protocols used across all those boards.

## Build Your Mental Model
### The Hierarchy and the Library
<div className="my-8 rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur shadow-2xl">
  <Image
    src="/visuals/rtl-testbench-blueprint.svg"
    alt="Diagram showing module and package relationships"
    width={720}
    height={360}
    sizes="(min-width: 1024px) 720px, 100vw"
    className="w-full"
  />
</div>

### Interactive Example: Shared Definitions
<InteractiveCode
  language="systemverilog"
  fileName="modules_and_packages.sv"
  code={`
package bus_pkg;
  // LRM Clause 26: Packages
  typedef enum logic [1:0] {IDLE, READ, WRITE} bus_cmd_e;
  
  typedef struct packed {
    bus_cmd_e cmd;
    logic [31:0] addr;
    logic [31:0] data;
  } bus_txn_s;
  
  function automatic logic [31:0] get_default_addr();
    return 32'h1000_0000;
  endfunction
endpackage

module dut (
  input logic clk,
  input bus_pkg::bus_txn_s txn, // Direct package reference
  output logic ready
);
  // LRM Clause 23: Modules
  import bus_pkg::*; // Wildcard import for convenience
  
  always_ff @(posedge clk) begin
    if (txn.cmd == WRITE) begin
      // ... handle write ...
    end
  end
endmodule

module tb_top;
  import bus_pkg::*;
  
  logic clk = 0;
  bus_txn_s txn; // Type available via import
  logic ready;
  
  always #5 clk = ~clk;
  
  dut u_dut (
    .clk(clk),
    .txn(txn),
    .ready(ready)
  );
  
  initial begin
    txn.addr = get_default_addr(); // Function from package
    txn.cmd = READ;
    // ...
  end
endmodule
  `}
  explanationSteps={[
    { target: "1-14", title: "Packages Centralize Knowledge", explanation: "Instead of redefining `bus_cmd_e` in every file, we define it once in `bus_pkg`. This ensures the DUT and Testbench agree on the protocol." },
    { target: "16-29", title: "Modules Encapsulate Behavior", explanation: "The `dut` module defines a hardware boundary. It uses types from `bus_pkg` to define its ports, ensuring type safety." },
    { target: "31-51", title: "Top-Level Integration", explanation: "`tb_top` imports the package to drive the DUT. Note how `bus_txn_s` is used for the connection signal `txn`." }
  ]}
/>

## Key Concepts

### Modules (LRM Clause 23)
The `module` is the basic unit of hierarchy in SystemVerilog. It can contain:
- **Ports:** Inputs, outputs, and inouts.
- **Parameters:** Constants to customize the module instance.
- **Processes:** `initial`, `always`, `always_ff`, `always_comb`.
- **Instances:** Sub-modules.

### Packages (LRM Clause 26)
A `package` is a namespace for shared declarations. It allows you to:
- **Share Types:** `typedef`, `enum`, `struct`.
- **Share Constants:** `parameter`, `localparam`.
- **Share Logic:** `function`, `task`.

**Best Practice:** Always put user-defined types in a package. Never define a `struct` or `enum` inside a port list or module if it needs to be shared.

## Make It Work
1.  **Identify Shared Types:** Look for `struct`s, `enum`s, or `const`s that are used in multiple modules or the testbench.
2.  **Create a Package:** Move these definitions into a `package my_pkg; ... endpackage` block.
3.  **Import:** Use `import my_pkg::*;` in your modules or interfaces to access the definitions.
4.  **Compile Order:** Ensure the package file is compiled *before* any file that imports it.

## Practice & Reinforce
- **Quiz:** Check your understanding of modules and packages.
- **Refactor:** Take a legacy design with scattered `typedef`s and consolidate them into a package.

## Compiler Directives & Scope
_Commands for the compiler, not the simulator._

### Macros (`\`define`)
Text substitution before compilation. Use sparingly for constants or simple snippets.

```systemverilog
`define WIDTH 32
`define MAX(a,b) ((a) > (b) ? (a) : (b))

logic [`WIDTH-1:0] data;
```

### Conditional Compilation (`\`ifdef`)
Include or exclude code based on flags. Essential for handling different configurations (e.g., FPGA vs. ASIC, Debug vs. Release).

```systemverilog
`ifdef DEBUG
  initial $display("Debug mode enabled");
`else
  initial $display("Production mode");
`endif
```

### Scope Resolution Operator (`::`)
Access static members, types, or parameters from a package or class without importing the whole thing.

```systemverilog
// Explicitly use a type from a package
my_pkg::my_struct_t data;

// Access a static method in a class
int count = MyClass::get_count();
```

## Interview Questions

<Card className="mt-8 border-slate-700 bg-slate-900">
  <CardHeader>
    <CardTitle>Ready for the Interview?</CardTitle>
  </CardHeader>
  <CardContent className="space-y-4">
    <details className="group rounded-lg bg-slate-800 p-4 open:bg-slate-800/80">
      <summary className="flex cursor-pointer items-center justify-between font-medium text-slate-200">
        What is the difference between `import` and `` `include ``?
        <span className="text-slate-400 transition group-open:rotate-180">▼</span>
      </summary>
      <div className="mt-4 text-sm text-slate-300 leading-relaxed">
        <p><strong>`` `include ``</strong> is a preprocessor directive that literally copies the text of a file into the current file. It is used for macros (` `define `) and sometimes for splitting large modules.</p>
        <p><strong>`import`</strong> is a language construct that makes items from a compiled `package` available in the current scope. Packages are compiled once and can be imported many times, which is more efficient and cleaner than including headers.</p>
      </div>
    </details>

    <details className="group rounded-lg bg-slate-800 p-4 open:bg-slate-800/80">
      <summary className="flex cursor-pointer items-center justify-between font-medium text-slate-200">
        Why should you avoid wildcard imports (`import pkg::*;`) in header files?
        <span className="text-slate-400 transition group-open:rotate-180">▼</span>
      </summary>
      <div className="mt-4 text-sm text-slate-300 leading-relaxed">
        <p>Wildcard imports pollute the namespace. If two packages define the same type name (e.g., `data_t`) and you wildcard import both, you get a collision. It is safer to import only what you need (`import pkg::data_t;`) or use wildcard imports only inside specific scopes (like a module or task) rather than globally.</p>
      </div>
    </details>
  </CardContent>
</Card>

## References & Next Topics
- **IEEE 1800-2023 Standard:**
    - Clause 23: Modules and Hierarchy
    - Clause 26: Packages
- **Next:** [F4B: Bundling Signals with Interfaces and Modports](/curriculum/T1_Foundational/F4B_Interfaces_and_Modports)

<Quiz
  questions={[
    {
      question: 'Why should you use a package for struct definitions?',
      answers: [
        { text: 'It makes the simulation run faster', correct: false },
        { text: 'It ensures the DUT and Testbench use the exact same type definition', correct: true },
        { text: 'It is required by the syntax', correct: false },
        { text: 'It allows you to use the struct in a clocking block', correct: false }
      ],
      explanation:
        'Defining types in a package prevents "type incompatibility" errors and ensures that the producer and consumer of data agree on its format.'
    },
    {
      question: 'How do you make package contents available in a module?',
      answers: [
        { text: 'Using the `include` keyword', correct: false },
        { text: 'Using the `import` keyword', correct: true },
        { text: 'Instantiating the package', correct: false },
        { text: 'Packages are automatically available', correct: false }
      ],
      explanation:
        'The `import` keyword brings package identifiers into the current scope. `import pkg::*` imports everything, while `import pkg::item` imports a specific item.'
    }
  ]}
/>
