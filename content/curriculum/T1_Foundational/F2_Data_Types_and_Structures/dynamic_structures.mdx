---
title: "F2B: Dynamic Data Structures"
description: "Manipulate dynamic arrays, queues, and associative arrays with an IEEE 1800-2023 guided workflow."
flashcards: "F2_Data_Types"
---

import { DynamicStructureVisualizer, PacketSorterGame, QueueOperationLab, PackedUnpackedPlayground, SystemVerilog3DVisualizer } from '@/components/curriculum/f2';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/Card';
import ArrayMethodExplorer from '@/components/visuals/ArrayMethodExplorer';

## Quick Take
- **What it is:** SystemVerilog collections that resize (`dynamic array`), preserve order (`queue`), or map sparse keys (`associative array`).
- **Why it matters:** Choosing the wrong structure wastes sim time, hides ordering bugs, or burns memory. The right choice keeps scoreboards and stimulus responsive when traffic spikes.
- **The Analogy:** Dynamic arrays are expandable trays, queues are conveyor belts, associative arrays are labeled drawers. Packed vs. unpacked tells you how the bits stack inside each drawer.

## Build Your Mental Model
### Choose the Right Structure
<div className="grid gap-4 md:grid-cols-3">
  <Card className="h-full bg-background">
    <CardHeader>
      <CardTitle className="text-base">Dynamic Array</CardTitle>
    </CardHeader>
    <CardContent className="text-sm text-muted-foreground space-y-2">
      <p>Resizable with `new[size]` or `push_back()`. Great for buffers you re-measure mid-sim.</p>
      <p>Indexed access is O(1); resizing copies elements.</p>
    </CardContent>
  </Card>
  <Card className="h-full bg-background">
    <CardHeader>
      <CardTitle className="text-base">Queue</CardTitle>
    </CardHeader>
    <CardContent className="text-sm text-muted-foreground space-y-2">
      <p>FIFO/LIFO with `push_front/back` and `pop_front/back`. Use bounds to model backpressure.</p>
      <p>Middle inserts are O(N); avoid for hot paths.</p>
    </CardContent>
  </Card>
  <Card className="h-full bg-background">
    <CardHeader>
      <CardTitle className="text-base">Associative Array</CardTitle>
    </CardHeader>
    <CardContent className="text-sm text-muted-foreground space-y-2">
      <p>Sparse map keyed by integers, strings, or enums. Perfect for outstanding transactions and coverage bins.</p>
      <p>Constant-time lookups with `exists()`/`find()`.</p>
    </CardContent>
  </Card>
</div>

### See Them Move
<DynamicStructureVisualizer />

- Drive each tab to watch `push_back`, `new[size]`, queue bounds, and associative lookups animate in real time.
- The packed/unpacked tab pairs with the playground below so you can memorize index order before writing code.

### Queue Ops Without the Guesswork
<QueueOperationLab />

- Measure how depth and head/tail respond to `push_front`, `insert(index)`, and `pop_back()`.
- Use the pressure indicator to decide when to assert backpressure in your driver.

### Packed vs. Unpacked—Memory Walks
<PackedUnpackedPlayground />

- Step through declarations like `logic [7:0] payload [0:3];` and `bit [3:0][1:0] lane_matrix [0:1];` to see which dimension advances first.
- Carry that mental model into scoreboards so byte lanes never swap.

### Tour the Structures in 3D
<SystemVerilog3DVisualizer />

- Jump into a volumetric view of capacity, head/tail markers, hash buckets, and packed/unpacked cubes to cement the spatial model.

## Make It Work
- Pre-size dynamic arrays when you know the target (`new[size]`) to avoid silent copies during hot paths.
- Guard queues with bounds and logs so overflow becomes an intentional backpressure event, not a mystery performance cliff.
- Use associative arrays for sparse spaces (transaction IDs, addresses) and delete keys when work completes.
- Double-check packed vs. unpacked ordering before slicing signals for serializers or coverage bins.

<ArrayMethodExplorer />

## Practice & Reinforce
- Apply the structures inside the **PacketSorterGame**—choose the best fit, earn XP, and read the rationale after every scenario.

<PacketSorterGame />

- Drill built-in methods: `find()` for associative arrays, `sum()/sort()` for queues and dynamic arrays, and `insert/delete` when you truly need middle edits.

## References & Next Topics
- IEEE 1800-2023 §7 (Arrays), §11.4 (Array querying & methods)
- Next: [Operators & Expressions](../F2C_Operators_and_Expressions/)
