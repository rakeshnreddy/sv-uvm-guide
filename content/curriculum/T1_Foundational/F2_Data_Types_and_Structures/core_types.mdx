---
title: "F2A: Core Data Types"
description: "Dive deep into SystemVerilog nets, variables, and value systems with interactive explorers grounded in IEEE 1800-2023."
flashcards: "F2_Data_Types"
---

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/Card';
import LogicStateDiagram from '@/components/visuals/LogicStateDiagram';
import SignednessVisualizer from '@/components/visuals/SignednessVisualizer';
import StringMethodExplorer from '@/components/visuals/StringMethodExplorer';
import EnumMethodVisualizer from '@/components/visuals/EnumMethodVisualizer';

## Quick Take
- **What it is:** Nets, variables, and value systems that define how signals resolve, store, and surface contention.
- **Why it matters:** Using 2-state math for DUT busses hides X/Z; driving a net procedurally masks contention bugs. Type intent makes verification observability possible.
- **The Analogy:** Nets are copper traces; variables are flip-flops and RAM cells. Pick the right material before you solder the circuit together.

## Build Your Mental Model
### Value Systems at a Glance
<LogicStateDiagram />

- **2-state (`bit`, `int`, `byte`):** Fast math, no unknowns. Great for counters, scoreboard arithmetic, and randomization helpers.
- **4-state (`logic`, `wire`, `tri`):** Surfaces contention and float. Use on DUT interfaces, resets, and any shared resource.
- Default values are teaching moments: variables start as `'x`, nets as `'z`. They force you to design reset and drive strategy early.

### Nets vs. Variables—Pick the Right Driver
<div className="grid gap-4 md:grid-cols-2">
  <Card className="bg-background">
    <CardHeader>
      <CardTitle className="text-base">Nets (structural)</CardTitle>
    </CardHeader>
    <CardContent className="space-y-2 text-sm text-muted-foreground">
      <p>Continuously driven, allow multiple drivers, resolve to `X` on conflict, default to `'z`.</p>
      <p>Examples: `wire`, `tri`, `wand` for shared buses or pad rings.</p>
    </CardContent>
  </Card>
  <Card className="bg-background">
    <CardHeader>
      <CardTitle className="text-base">Variables (procedural)</CardTitle>
    </CardHeader>
    <CardContent className="space-y-2 text-sm text-muted-foreground">
      <p>Written in `always_comb`/`always_ff` or class methods. Single driver, default to `'x`.</p>
      <p>Examples: `logic`, `bit`, `int`, `byte` for registers, scoreboards, and transactions.</p>
    </CardContent>
  </Card>
</div>

### Signedness and Type Families
<SignednessVisualizer />

- Declare intent up front: `logic signed [WIDTH-1:0] data_s;` or cast with `$signed()` when mixing arithmetic and packed busses.
- Keep math in `int/longint` and only slice into packed logic at the edges. It keeps overflow and sign extension predictable.

### Strings and Enums That Pull Their Weight

<StringMethodExplorer />

- Strings are dynamic—perfect for report formatting and path manipulation.

<EnumMethodVisualizer />

- Enums give type safety and built-in iterators (`first()`, `next()`). They beat magic numbers for FSMs and coverage bins.

## Make It Work
- Use the explorer to test your choices against the simulator:

<CurriculumDataTypeExplorer />

- **Pattern:** 4-state at the interfaces, 2-state in math-heavy logic, cast when crossing the boundary.
- **Guardrails:** Prefer `===`/`!==` for reset checks so X/Z stays visible. Add assertions when collapsing 4-state to 2-state types.
- **Audit:** Does every signal have a reason to be packed or unpacked? If not, clarify now to avoid later lint churn.

## Practice & Reinforce
- Run the quiz before moving on—explanations tie back to the explorer so you see why each answer holds up under the LRM.

<CurriculumDataTypeQuiz />

- Interview drill: explain why `logic` is safer than `reg`, and when `bit` is the right call for counters.

## References & Next Topics
- IEEE 1800-2023 §6–§7 (Nets, variables, value systems)
- Next: [Dynamic Structures](./dynamic_structures)
