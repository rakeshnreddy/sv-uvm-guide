---
title: "F2: Data Types & Structures"
description: "Master SystemVerilog's type system, from physical nets to dynamic collections."
flashcards: "F2_Data_Types"
---

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/Card';

## Quick Take
- **What it is:** The SystemVerilog type toolbox—nets vs. variables, packed vs. unpacked dimensions, and the operators that shape them.
- **Why it matters:** Picking the wrong type hides Xs, breaks bus ordering, or slows sims. Getting it right makes DUT intent obvious and testbenches debuggable.
- **The Analogy:** Types are the vocabulary for hardware. Nets are your wires, packed vectors are your lanes, and queues/associative arrays are the clipboards that keep chaotic traffic organized.

> **Why before how:** Every declaration is a design decision—know what behavior you want to observe before reaching for syntax.

## Build Your Mental Model
<div className="grid gap-4 md:grid-cols-3">
  <Card className="h-full border-primary/40 bg-primary/5">
    <CardHeader>
      <CardTitle className="text-base">Value Systems</CardTitle>
    </CardHeader>
    <CardContent className="text-sm text-muted-foreground space-y-2">
      <p>2-state types (`bit`, `int`) simulate fast; 4-state types (`logic`, `wire`) surface contention and float.</p>
      <p>Reset strategy starts here—defaults are `'x` for variables, `'z` for nets.</p>
    </CardContent>
  </Card>
  <Card className="h-full border-primary/40 bg-primary/5">
    <CardHeader>
      <CardTitle className="text-base">Structures That Flex</CardTitle>
    </CardHeader>
    <CardContent className="text-sm text-muted-foreground space-y-2">
      <p>Dynamic arrays resize, queues preserve order, associative arrays track sparse IDs.</p>
      <p>Packed vs. unpacked dictates bit ordering and how buses map into memory.</p>
    </CardContent>
  </Card>
  <Card className="h-full border-primary/40 bg-primary/5">
    <CardHeader>
      <CardTitle className="text-base">Operators With Intent</CardTitle>
    </CardHeader>
    <CardContent className="text-sm text-muted-foreground space-y-2">
      <p>Bitwise vs. logical, case equality, `inside`, and streaming concatenations keep intent explicit.</p>
      <p>Parentheses beat precedence confusion every time.</p>
    </CardContent>
  </Card>
</div>

## Make It Work
1. **Pick the value system:** Use 4-state types on DUT-facing nets to expose X/Z; use 2-state for scoreboard math and counters.
2. **Shape the storage:** Choose between dynamic arrays, queues, and associative arrays based on access pattern, then confirm packed/unpacked ordering matches the bus.
3. **Apply operators deliberately:** Reach for `===`/`inside` when X/Z matters, and streaming concatenations when rearranging payloads.

## Practice & Reinforce
- Start with **[Core Data Types](./core_types)** to rehearse nets vs. variables and signedness.
- Move to **[Dynamic Structures](./dynamic_structures)** for packed/unpacked memory walks, queue labs, and associative lookups.
- Finish with **[Operators & Expressions](../F2C_Operators_and_Expressions/)** to tighten up precedence and set membership skills.
- Drill the shared flashcards in this module while you click through the interactive explorers.

## References & Next Topics
- IEEE 1800-2023 §6–§7 (Data Types), §11 (Operators)
- Next: [`F3: Procedural Constructs`](../F3_Procedural_Constructs/)
